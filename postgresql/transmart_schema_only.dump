--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- Name: biomart; Type: SCHEMA; Schema: -; Owner: biomart
--

CREATE SCHEMA biomart;


ALTER SCHEMA biomart OWNER TO biomart;

--
-- Name: deapp; Type: SCHEMA; Schema: -; Owner: deapp
--

CREATE SCHEMA deapp;


ALTER SCHEMA deapp OWNER TO deapp;

--
-- Name: i2b2demodata; Type: SCHEMA; Schema: -; Owner: i2b2demodata
--

CREATE SCHEMA i2b2demodata;


ALTER SCHEMA i2b2demodata OWNER TO i2b2demodata;

--
-- Name: i2b2hive; Type: SCHEMA; Schema: -; Owner: i2b2hive
--

CREATE SCHEMA i2b2hive;


ALTER SCHEMA i2b2hive OWNER TO i2b2hive;

--
-- Name: i2b2metadata; Type: SCHEMA; Schema: -; Owner: i2b2metadata
--

CREATE SCHEMA i2b2metadata;


ALTER SCHEMA i2b2metadata OWNER TO i2b2metadata;

--
-- Name: i2b2pm; Type: SCHEMA; Schema: -; Owner: i2b2pm
--

CREATE SCHEMA i2b2pm;


ALTER SCHEMA i2b2pm OWNER TO i2b2pm;

--
-- Name: i2b2workdata; Type: SCHEMA; Schema: -; Owner: i2b2workdata
--

CREATE SCHEMA i2b2workdata;


ALTER SCHEMA i2b2workdata OWNER TO i2b2workdata;

--
-- Name: searchapp; Type: SCHEMA; Schema: -; Owner: searchapp
--

CREATE SCHEMA searchapp;


ALTER SCHEMA searchapp OWNER TO searchapp;

--
-- Name: tm_cz; Type: SCHEMA; Schema: -; Owner: tm_cz
--

CREATE SCHEMA tm_cz;


ALTER SCHEMA tm_cz OWNER TO tm_cz;

--
-- Name: tm_lz; Type: SCHEMA; Schema: -; Owner: tm_lz
--

CREATE SCHEMA tm_lz;


ALTER SCHEMA tm_lz OWNER TO tm_lz;

--
-- Name: tm_wz; Type: SCHEMA; Schema: -; Owner: tm_wz
--

CREATE SCHEMA tm_wz;


ALTER SCHEMA tm_wz OWNER TO tm_wz;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = biomart, pg_catalog;

--
-- Name: bio_assay_analysis_uid(text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_assay_analysis_uid(analysis_name text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'BAA:' || coalesce(ANALYSIS_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_assay_analysis_uid(analysis_name text) OWNER TO biomart;

--
-- Name: bio_assay_platform_uid(text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_assay_platform_uid(platform_name text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'BAP:' || coalesce(PLATFORM_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_assay_platform_uid(platform_name text) OWNER TO biomart;

--
-- Name: bio_asy_analysis_pltfm_uid(text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_asy_analysis_pltfm_uid(platform_name text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'BAAP:' || coalesce(PLATFORM_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_asy_analysis_pltfm_uid(platform_name text) OWNER TO biomart;

--
-- Name: bio_compound_uid(text, text, text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Function to create compound_uid.

  RETURN 'COM:' || coalesce(CAS_REGISTRY, coalesce(JNJ_NUMBER, coalesce(CNTO_NUMBER, 'ERROR')));
END;
$_$;


ALTER FUNCTION biomart.bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) OWNER TO biomart;

--
-- Name: bio_curation_dataset_uid(text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_curation_dataset_uid(bio_curation_type text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'BCD:' || coalesce(BIO_CURATION_TYPE, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_curation_dataset_uid(bio_curation_type text) OWNER TO biomart;

--
-- Name: bio_disease_uid(text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_disease_uid(mesh_code text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates bio_disease_uid.

  RETURN 'DIS:' || coalesce(MESH_CODE, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_disease_uid(mesh_code text) OWNER TO biomart;

--
-- Name: bio_experiment_uid(text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_experiment_uid(primary_id text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'EXP:' || coalesce(PRIMARY_ID, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_experiment_uid(primary_id text) OWNER TO biomart;

--
-- Name: bio_jub_oncol_data_uid(bigint, text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_jub_oncol_data_uid(record_id bigint, bio_curation_name text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'BJOD:' || coalesce(trim(TO_CHAR(RECORD_ID, '9999999999999999999')), 'ERROR') || ':' || coalesce(BIO_CURATION_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_jub_oncol_data_uid(record_id bigint, bio_curation_name text) OWNER TO biomart;

--
-- Name: bio_jub_oncol_sum_data_uid(bigint, text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_jub_oncol_sum_data_uid(record_id bigint, bio_curation_name text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'BJOS:' || coalesce(trim(TO_CHAR(RECORD_ID, '9999999999999999999')), 'ERROR') || ':' || coalesce(BIO_CURATION_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_jub_oncol_sum_data_uid(record_id bigint, bio_curation_name text) OWNER TO biomart;

--
-- Name: biomarker_gene_uid(text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION biomarker_gene_uid(gene_id text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'GENE:' || coalesce(GENE_ID, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.biomarker_gene_uid(gene_id text) OWNER TO biomart;

--
-- Name: biomarker_pathway_uid(text, text); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION biomarker_pathway_uid(p_source text, pathway_id text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'PATHWAY:'|| P_SOURCE || ':' || coalesce(PATHWAY_ID, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.biomarker_pathway_uid(p_source text, pathway_id text) OWNER TO biomart;

--
-- Name: cum_normal_dist(numeric, numeric, numeric); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

 -------------------------------------------------------------------------------
  -- implementation of a cumalative normal distribution
  -- JWS@20090601 - First rev.
  -- param foldChg: fold change ratio from from analysis_data table
  -- param mu: mean of all analsyis_data records for a given analysis
  -- param sigma: std dev of all analsyis_data records for a given analysis
  -------------------------------------------------------------------------------

  -- temporary vars  
  t1 decimal;
  
  -- fractional error dist input
  fract_error_input decimal;
  
  -- return result (i.e. Prob [X<=x])
  ans decimal;  


BEGIN
  t1:= (foldChg-mu)/sigma;  
  fract_error_input:= t1/SQRT(2);
  ans:= 0.5 * (1.0 + biomart.fract_error_dist(fract_error_input));
  return ans; 
END;
$$;


ALTER FUNCTION biomart.cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) OWNER TO biomart;

--
-- Name: fract_error_dist(numeric); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION fract_error_dist(norminput numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE


 -------------------------------------------------------------------------------
  -- implementation of fractional error distribution
  -- JWS@20090601 - First rev.
  -------------------------------------------------------------------------------
  -- temp var
  t1 decimal:= 1.0 / (1.0 + 0.5 * ABS(normInput));
  
  -- exponent input to next equation
  exponent_input decimal:= -normInput*normInput - 1.26551223 + 
                           t1*(1.00002368 + t1*(0.37409196 + t1*(0.09678418 + t1*(-0.18628806 + t1*(0.27886807 + t1*(-1.13520398 + t1*(1.48851587 + t1*(-0.82215223 + t1*(0.17087277)))))))));
  -- Horner's method
  ans decimal:= 1 - t1 * EXP(exponent_input);

  fractError decimal;


BEGIN
  -- handle sign
  IF normInput>0.0 THEN fractError:= ans; ELSE fractError:= -ans; END IF;
  return fractError;

END;
$$;


ALTER FUNCTION biomart.fract_error_dist(norminput numeric) OWNER TO biomart;

--
-- Name: refresh_bio_lit_int_model_mv(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION refresh_bio_lit_int_model_mv() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN

  -- populate the fake "materialized view" (i.e. actually a table) by deleting everything from it and then re-populating
  -- eventually we need a smarter algorithm for doing this

    delete from biomart.bio_lit_int_model_mv;

    insert into biomart.bio_lit_int_model_mv
    (bio_lit_int_data_id, experimental_model)    
    select bio_lit_int_data_id, experimental_model
       from biomart.bio_lit_int_model_view;  

    return true;
END;
 
 
 
$$;


ALTER FUNCTION biomart.refresh_bio_lit_int_model_mv() OWNER TO biomart;

--
-- Name: refresh_bio_marker_correl_mv(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION refresh_bio_marker_correl_mv() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN

  -- populate the fake "materialized view" (i.e. actually a table) by deleting everything from it and then re-populating
  -- eventually we need a smarter algorithm for doing this

    delete from biomart.bio_marker_correl_mv;

    insert into biomart.bio_marker_correl_mv
    (BIO_MARKER_ID, ASSO_BIO_MARKER_ID, CORREL_TYPE, mv_id)    
    select BIO_MARKER_ID, ASSO_BIO_MARKER_ID, CORREL_TYPE, mv_id
       from biomart.bio_marker_correl_view;  

    return true;
END;
$$;


ALTER FUNCTION biomart.refresh_bio_marker_correl_mv() OWNER TO biomart;

--
-- Name: tea_npv_precompute(numeric, numeric, numeric); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE


 -------------------------------------------------------------------------------
  -- used for gene signature TEA algorithm which precomputes normalized p-values
  -- based ON biomart.fold change ratio from analysis_data records
  -- JWS@20090601 - First rev.
  -- param foldChg: input is fold change ratio from from analysis_data table
  -- param mu: mean of all analsyis_data records for a given analysis
  -- param sigma: std dev of all analsyis_data records for a given analysis
  -------------------------------------------------------------------------------
  npv decimal;
  outlier_cutoff decimal:=1.0e-5;
  

BEGIN
  -- normalized p-value 
  npv:= 1.0 - cum_normal_dist(abs(foldChg),mu,sigma);
  
  -- cap outliers to minimum value
  IF npv<outlier_cutoff THEN npv:= outlier_cutoff; END IF;
  
  RETURN npv;
  
END;
$$;


ALTER FUNCTION biomart.tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_analysis_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_analysis_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.BIO_ASSAY_ANALYSIS_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_ANALYSIS_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_analysis_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin    if NEW.BIO_ASSAY_DATA_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_DATA_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_dataset_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_dataset_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.BIO_ASSAY_DATASET_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_DATASET_ID ;       end if; RETURN NEW;  end;

$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_dataset_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_f_g_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_f_g_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.BIO_ASSAY_FEATURE_GROUP_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_FEATURE_GROUP_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_f_g_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin   if NEW.BIO_ASSAY_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_platform_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_platform_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.BIO_ASSAY_PLATFORM_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_PLATFORM_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_platform_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_asy_analysis_pltfm_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_asy_analysis_pltfm_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin  if NEW.BIO_ASY_ANALYSIS_PLTFM_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASY_ANALYSIS_PLTFM_ID ;       end if; RETURN NEW;   end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_asy_analysis_pltfm_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_asy_dt_stats_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_asy_dt_stats_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin    if NEW.BIO_ASSAY_DATA_STATS_ID is null then          select nextval('biomart.SEQ_BIO_DATA_FACT_ID') into NEW.BIO_ASSAY_DATA_STATS_ID ;       end if;  RETURN NEW; end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_asy_dt_stats_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_cell_line_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_cell_line_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin   if NEW.BIO_CELL_LINE_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CELL_LINE_ID ;       end if; RETURN NEW;   end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_cell_line_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_cl_trl_time_pt_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_cl_trl_time_pt_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin  if NEW.BIO_CLINC_TRIAL_TM_PT_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CLINC_TRIAL_TM_PT_ID ;       end if; RETURN NEW;   end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_cl_trl_time_pt_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_clin_trl_pt_grp_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_clin_trl_pt_grp_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin   if NEW.BIO_CLINICAL_TRIAL_P_GROUP_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CLINICAL_TRIAL_P_GROUP_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_clin_trl_pt_grp_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_cln_trl_attr_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_cln_trl_attr_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin   if NEW.BIO_CLINC_TRIAL_ATTR_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CLINC_TRIAL_ATTR_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_cln_trl_attr_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_compound_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_compound_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin if NEW.BIO_COMPOUND_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_COMPOUND_ID ;       end if; RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_compound_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_concept_code_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_concept_code_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.BIO_CONCEPT_CODE_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CONCEPT_CODE_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_concept_code_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_content_ref_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_content_ref_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin      if NEW.BIO_CONTENT_REFERENCE_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CONTENT_REFERENCE_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_content_ref_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_content_repo_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_content_repo_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin if NEW.BIO_CONTENT_REPO_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CONTENT_REPO_ID ;       end if; RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_content_repo_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_curation_dataset_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_curation_dataset_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin      if NEW.BIO_CURATION_DATASET_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CURATION_DATASET_ID ;       end if; RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_curation_dataset_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_data_attr_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_data_attr_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin if NEW.BIO_DATA_ATTRIBUTE_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DATA_ATTRIBUTE_ID ;       end if; RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_data_attr_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_data_correl_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_data_correl_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin       if NEW.BIO_DATA_CORREL_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DATA_CORREL_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_data_correl_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_data_ext_code_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_data_ext_code_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin    if NEW.BIO_DATA_EXT_CODE_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DATA_EXT_CODE_ID ;       end if;   RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_data_ext_code_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_disease_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_disease_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.BIO_DISEASE_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DISEASE_ID ;       end if;   RETURN NEW; end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_disease_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_experiment_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_experiment_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin         if NEW.BIO_EXPERIMENT_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_EXPERIMENT_ID ;       end if; RETURN NEW;   end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_experiment_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_file_content_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_file_content_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin       if NEW.BIO_FILE_CONTENT_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_FILE_CONTENT_ID ;       end if;   RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_file_content_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_alt_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_alt_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_ALT_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_ALT_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_alt_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_amd_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_amd_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_AMD_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_AMD_DATA_ID ;
       end if;
       RETURN NEW;
    end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_amd_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_inh_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_inh_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_INH_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_INH_DATA_ID ;
       end if; 
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_inh_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_int_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_int_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_INT_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_INT_DATA_ID ;
       end if; 
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_int_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_model_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_model_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_MODEL_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_MODEL_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_model_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_pe_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_pe_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_PE_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_PE_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_pe_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_ref_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_ref_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_REF_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_REF_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_ref_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_sum_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_sum_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_SUM_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_SUM_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_sum_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_marker_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_marker_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin  if NEW.BIO_MARKER_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_MARKER_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_marker_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_mkr_correl_descr_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_mkr_correl_descr_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin   if NEW.BIO_DATA_CORREL_DESCR_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DATA_CORREL_DESCR_ID ;       end if;  RETURN NEW;  end;

$$;


ALTER FUNCTION biomart.tf_trg_bio_mkr_correl_descr_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_patient_event_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_patient_event_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin  if NEW.BIO_PATIENT_EVENT_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_PATIENT_EVENT_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_patient_event_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_patient_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_patient_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin  if NEW.BIO_PATIENT_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_PATIENT_ID ;       end if; RETURN NEW;   end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_patient_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_pt_evt_attr_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_pt_evt_attr_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin if NEW.BIO_CLINIC_TRIAL_ATTRIBUTE_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CLINIC_TRIAL_ATTRIBUTE_ID ;       end if; RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_pt_evt_attr_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_sample_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_sample_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin   if NEW.BIO_SAMPLE_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_SAMPLE_ID ;       end if; RETURN NEW;   end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_sample_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_subject_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_subject_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin if NEW.BIO_SUBJECT_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_SUBJECT_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_subject_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_taxon_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_taxon_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN IF NEW.BIO_TAXONOMY_ID IS NULL THEN
  select nextval('biomart.SEQ_BIO_DATA_ID') INTO NEW.BIO_TAXONOMY_ID ;
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_bio_taxon_id() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_clin_inhib_effect(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_clin_inhib_effect() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
 	IF NEW.CTD_CIE_SEQ IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_CIE_SEQ ;  
	END IF;  
	RETURN NEW;  
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_clin_inhib_effect() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_disease(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_disease() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
	IF NEW.CTD_DISEASE_SEQ IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_DISEASE_SEQ ;  
	END IF;    
	RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_disease() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_inhib_details(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_inhib_details() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
	IF NEW.CTD_INHIB_SEQ IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_INHIB_SEQ ;  
	END IF;    
	RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_inhib_details() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_study_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_study_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
	IF NEW.CTD_STUDY_ID IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_STUDY_ID ;  
	END IF;    
	RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_study_id() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_trial_details(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_trial_details() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
	IF NEW.CTD_TD_SEQ IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_TD_SEQ ;  
	END IF;   
	RETURN NEW; 
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_trial_details() OWNER TO biomart;

--
-- Name: tf_trig_clinical_trial_design_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trig_clinical_trial_design_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
    if NEW.CLINICAL_TRIAL_DESIGN_ID is null then          
      select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') into NEW.CLINICAL_TRIAL_DESIGN_ID ;  
    end if; 
    RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trig_clinical_trial_design_id() OWNER TO biomart;

SET search_path = deapp, pg_catalog;

--
-- Name: tf_de_parent_cd_trg(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_de_parent_cd_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  SELECT nextval('deapp.de_parent_cd_seq')
  INTO new.parent_cd
  ;
RETURN NEW;
END;
$$;


ALTER FUNCTION deapp.tf_de_parent_cd_trg() OWNER TO deapp;

--
-- Name: tf_trg_de_snp_info_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_snp_info_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if coalesce(NEW.SNP_INFO_ID::text, '') = '' then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_INFO_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_snp_info_id() OWNER TO deapp;

--
-- Name: tf_trg_de_snp_probe_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_snp_probe_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if coalesce(NEW.SNP_PROBE_ID::text, '') = '' then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_PROBE_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_snp_probe_id() OWNER TO deapp;

--
-- Name: tf_trg_de_snp_probe_sorted_def_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_snp_probe_sorted_def_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if coalesce(NEW.SNP_PROBE_SORTED_DEF_ID::text, '') = '' then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_PROBE_SORTED_DEF_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_snp_probe_sorted_def_id() OWNER TO deapp;

--
-- Name: tf_trg_de_subject_snp_dataset_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_subject_snp_dataset_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if coalesce(NEW.SUBJECT_SNP_DATASET_ID::text, '') = '' then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SUBJECT_SNP_DATASET_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_subject_snp_dataset_id() OWNER TO deapp;

--
-- Name: tf_trg_de_subject_sorted_def_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_subject_sorted_def_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
if coalesce(NEW.SNP_SUBJECT_SORTED_DEF_ID::text, '') = '' then
select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_SUBJECT_SORTED_DEF_ID ;
end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_subject_sorted_def_id() OWNER TO deapp;

--
-- Name: tf_trg_snp_data_by_patient_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_snp_data_by_patient_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if coalesce(NEW.SNP_DATA_BY_PATIENT_ID::text, '') = '' then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_DATA_BY_PATIENT_ID ;
  end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_snp_data_by_patient_id() OWNER TO deapp;

--
-- Name: tf_trg_snp_data_by_pprobe_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_snp_data_by_pprobe_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if coalesce(NEW.SNP_DATA_BY_PROBE_ID::text, '') = '' then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_DATA_BY_PROBE_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_snp_data_by_pprobe_id() OWNER TO deapp;

--
-- Name: tf_trg_snp_subject_sorted_def_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_snp_subject_sorted_def_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
if coalesce(NEW.SNP_SUBJECT_SORTED_DEF_ID::text, '') = '' then
select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_SUBJECT_SORTED_DEF_ID ;
end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_snp_subject_sorted_def_id() OWNER TO deapp;

SET search_path = i2b2demodata, pg_catalog;

--
-- Name: create_temp_concept_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

BEGIN 
execute 'create table ' ||  tempConceptTableName || ' (
        CONCEPT_CD VARCHAR(50) NOT NULL, 
	CONCEPT_PATH VARCHAR(900) NOT NULL , 
	NAME_CHAR VARCHAR(2000), 
	CONCEPT_BLOB TEXT, 
	UPDATE_DATE date, 
	DOWNLOAD_DATE DATE, 
	IMPORT_DATE DATE, 
	SOURCESYSTEM_CD VARCHAR(50)
	 )';

 execute 'CREATE INDEX idx_' || tempConceptTableName || '_pat_id ON ' || tempConceptTableName || '  (CONCEPT_PATH)';
  
   

EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_eid_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

BEGIN 
execute 'create table ' ||  tempPatientMappingTableName || ' (
	ENCOUNTER_MAP_ID       	VARCHAR(200) NOT NULL,
    ENCOUNTER_MAP_ID_SOURCE	VARCHAR(50) NOT NULL,
    PATIENT_MAP_ID          VARCHAR(200), 
	PATIENT_MAP_ID_SOURCE   VARCHAR(50), 
    ENCOUNTER_ID       	    VARCHAR(200) NOT NULL,
    ENCOUNTER_ID_SOURCE     VARCHAR(50) ,
    ENCOUNTER_NUM           NUMERIC, 
    ENCOUNTER_MAP_ID_STATUS    VARCHAR(50),
    PROCESS_STATUS_FLAG     CHAR(1),
	UPDATE_DATE DATE, 
	DOWNLOAD_DATE DATE, 
	IMPORT_DATE DATE, 
	SOURCESYSTEM_CD VARCHAR(50)
)';

execute 'CREATE INDEX idx_' || tempPatientMappingTableName || '_eid_id ON ' || tempPatientMappingTableName || '  (ENCOUNTER_ID, ENCOUNTER_ID_SOURCE, ENCOUNTER_MAP_ID, ENCOUNTER_MAP_ID_SOURCE, ENCOUNTER_NUM)';

 execute 'CREATE INDEX idx_' || tempPatientMappingTableName || '_stateid_eid_id ON ' || tempPatientMappingTableName || '  (PROCESS_STATUS_FLAG)';  
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_patient_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	-- Create temp table to store encounter/visit information
	execute 'create table ' ||  tempPatientDimensionTableName || ' (
		PATIENT_ID VARCHAR(200), 
		PATIENT_ID_SOURCE VARCHAR(50),
		PATIENT_NUM NUMERIC(38,0),
	    VITAL_STATUS_CD VARCHAR(50), 
	    BIRTH_DATE DATE, 
	    DEATH_DATE DATE, 
	    SEX_CD CHAR(50), 
	    AGE_IN_YEARS_NUM NUMERIC(5,0), 
	    LANGUAGE_CD VARCHAR(50), 
		RACE_CD VARCHAR(50 ), 
		MARITAL_STATUS_CD VARCHAR(50), 
		RELIGION_CD VARCHAR(50), 
		ZIP_CD VARCHAR(50), 
		STATECITYZIP_PATH VARCHAR(700), 
		PATIENT_BLOB TEXT, 
		UPDATE_DATE DATE, 
		DOWNLOAD_DATE DATE, 
		IMPORT_DATE DATE, 
		SOURCESYSTEM_CD VARCHAR(50)
	)';

execute 'CREATE INDEX idx_' || tempPatientDimensionTableName || '_pat_id ON ' || tempPatientDimensionTableName || '  (PATIENT_ID, PATIENT_ID_SOURCE,PATIENT_NUM)';
  
     
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_pid_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

BEGIN 
execute 'create table ' ||  tempPatientMappingTableName || ' (
	   	PATIENT_MAP_ID VARCHAR(200), 
		PATIENT_MAP_ID_SOURCE VARCHAR(50), 
		PATIENT_ID_STATUS VARCHAR(50), 
		PATIENT_ID  VARCHAR(200),
	    PATIENT_ID_SOURCE varchar(50),
		PATIENT_NUM NUMERIC(38,0),
	    PATIENT_MAP_ID_STATUS VARCHAR(50), 
		PROCESS_STATUS_FLAG CHAR(1), 
		UPDATE_DATE DATE, 
		DOWNLOAD_DATE DATE, 
		IMPORT_DATE DATE, 
		SOURCESYSTEM_CD VARCHAR(50)

	 )';

execute 'CREATE INDEX idx_' || tempPatientMappingTableName || '_pid_id ON ' || tempPatientMappingTableName || '  ( PATIENT_ID, PATIENT_ID_SOURCE )';

execute 'CREATE INDEX idx_' || tempPatientMappingTableName || 'map_pid_id ON ' || tempPatientMappingTableName || '  
( PATIENT_ID, PATIENT_ID_SOURCE,PATIENT_MAP_ID, PATIENT_MAP_ID_SOURCE,  PATIENT_NUM )';
 
execute 'CREATE INDEX idx_' || tempPatientMappingTableName || 'stat_pid_id ON ' || tempPatientMappingTableName || '  
(PROCESS_STATUS_FLAG)';


    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_provider_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 

execute 'create table ' ||  tempProviderTableName || ' (
    PROVIDER_ID VARCHAR(50) NOT NULL, 
	PROVIDER_PATH VARCHAR(700) NOT NULL, 
	NAME_CHAR VARCHAR(2000), 
	PROVIDER_BLOB TEXT, 
	UPDATE_DATE DATE, 
	DOWNLOAD_DATE DATE, 
	IMPORT_DATE DATE, 
	SOURCESYSTEM_CD VARCHAR(50), 
	UPLOAD_ID NUMERIC(*,0)
	 )';
 execute 'CREATE INDEX idx_' || tempProviderTableName || '_ppath_id ON ' || tempProviderTableName || '  (PROVIDER_PATH)';

    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	execute 'create table ' ||  tempTableName || '  (		
		encounter_id 		varchar(200) not null, 
        encounter_id_source varchar(50) not null,
		encounter_num  		NUMERIC(38,0),
		concept_cd 	 		VARCHAR(50) not null, 
        patient_num 		NUMERIC(38,0), 
		patient_id  		varchar(200) not null,
        patient_id_source  	varchar(50) not null,
		provider_id   		VARCHAR(50),
 		start_date   		DATE, 
		modifier_cd 		VARCHAR(100),
	    instance_num 		NUMERIC(18,0),
 		valtype_cd 			VARCHAR(50),
		tval_char 			varchar(255),
 		nval_num 			NUMERIC(18,5),
		valueflag_cd 		CHAR(50),
 		quantity_num 		NUMERIC(18,5),
		confidence_num 		NUMERIC(18,0),
 		observation_blob 	TEXT,
		units_cd 			VARCHAR(50),
 		end_date    		DATE,
		location_cd 		VARCHAR(50),
 		update_date  		DATE,
		download_date 		DATE,
 		import_date 		DATE,
		sourcesystem_cd 	VARCHAR(50) ,
 		upload_id 			INTEGER
	)';

    
    execute 'CREATE INDEX idx_' || tempTableName || '_pk ON ' || tempTableName || '  ( encounter_num,patient_num,concept_cd,provider_id,start_date,modifier_cd,instance_num)';
    execute 'CREATE INDEX idx_' || tempTableName || '_enc_pat_id ON ' || tempTableName || '  (encounter_id,encounter_id_source, patient_id,patient_id_source )';
    
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_table(temptablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_visit_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	-- Create temp table to store encounter/visit information
	execute 'create table ' ||  tempTableName || ' (
		encounter_id 			VARCHAR(200) not null,
		encounter_id_source 	VARCHAR(50) not null, 
		patient_id  			VARCHAR(200) not null,
		patient_id_source 		VARCHAR(50) not null,
		encounter_num	 		    NUMERIC(38,0), 
		inout_cd   			VARCHAR(50),
		location_cd 			VARCHAR(50),
		location_path 			VARCHAR(900),
 		start_date   			DATE, 
 		end_date    			DATE,
 		visit_blob 				TEXT,
 		update_date  			DATE,
		download_date 			DATE,
 		import_date 			DATE,
		sourcesystem_cd 		VARCHAR(50)
	)';

    execute 'CREATE INDEX idx_' || tempTableName || '_enc_id ON ' || tempTableName || '  ( encounter_id,encounter_id_source,patient_id,patient_id_source )';
    execute 'CREATE INDEX idx_' || tempTableName || '_patient_id ON ' || tempTableName || '  ( patient_id,patient_id_source )';
    
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_visit_table(temptablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_concept_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	--Delete duplicate rows with same encounter and patient combination
	-- smuniraju: Rowid not supported in postgres, using combination of ctid (and gp_segment_id for greenplum)
	-- execute 'DELETE FROM ' || tempConceptTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempConceptTableName || ' t2
	-- 				     WHERE t1.concept_cd = t2.concept_cd 
    --                                         AND t1.concept_path = t2.concept_path
    --                                         )';
	execute 'DELETE FROM ' || tempConceptTableName || ' t1 WHERE ( ctid) not in ( 
			   SELECT   max(ctid) FROM ' || tempConceptTableName || ' t2
			   group by concept_path,concept_cd)';
						
    execute ' 	UPDATE concept_dimension cd set 
				name_char= temp.name_char,
				concept_blob= temp.concept_blob,
				update_date= temp.update_date,
				import_date = now(),
				DOWNLOAD_DATE=temp.DOWNLOAD_DATE,
				SOURCESYSTEM_CD=temp.SOURCESYSTEM_CD,
				UPLOAD_ID = '|| upload_id || '
				from ' || tempConceptTableName || ' temp
				where cd.concept_path = temp.concept_path
				and temp.update_date >= cd.update_date';
   
    --Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	-- smuniraju: not exists results in co-related query.
	-- execute 'insert into concept_dimension  --(concept_cd,concept_path,name_char,concept_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
	-- 		    select concept_cd, concept_path, name_char,concept_blob, update_date,download_date,
    --          sysdate,sourcesystem_cd, ' || upload_id || '  
	--			from ' || tempConceptTableName || '  temp
	-- 			where not exists (select concept_cd from concept_dimension cd where cd.concept_path = temp.concept_path)';
	execute 'insert into concept_dimension  (concept_cd,concept_path,name_char,concept_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  temp.concept_cd, temp.concept_path, temp.name_char,temp.concept_blob, temp.update_date,temp.download_date, current_timestamp,temp.sourcesystem_cd, ' || upload_id || '  
				from ' || tempConceptTableName || '  temp left outer join concept_dimension cd
				on cd.concept_path = temp.concept_path
				where cd.concept_path is null';					
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_eid_map_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

DECLARE
 existingEncounterNum VARCHAR(32);
 maxEncounterNum NUMERIC;
 -- TYPE distinctEIdCurTyp IS REF CURSOR;
 -- distinctEidCur   distinctEIdCurTyp;
 distinctEidCur REFCURSOR;
 sql_stmt  VARCHAR(400); 
 disEncounterId VARCHAR(100); 
 disEncounterIdSource VARCHAR(100);

BEGIN
 sql_stmt := ' SELECT distinct encounter_id,encounter_id_source from ' || tempEidTableName ||' ';

-- smuniraju: rowid not supported in postgres/greenplum, instead using ctid (and gp_segment_id in greenplum)
-- execute ' delete  from ' || tempEidTableName ||  ' t1  where 
-- rowid > (select min(rowid) from ' || tempEidTableName || ' t2 
-- where t1.encounter_map_id = t2.encounter_map_id
-- and t1.encounter_map_id_source = t2.encounter_map_id_source
-- and t1.encounter_id = t2.encounter_id
-- and t1.encounter_id_source = t2.encounter_id_source) ';

 execute 'delete  from ' || tempEidTableName ||  ' t1  
		  where ( ctid) NOT IN (select  max(ctid) from ' || tempEidTableName || ' t2 
		  group by  encounter_map_id,encounter_map_id_source,encounter_id,encounter_id_source )';


 LOCK TABLE  encounter_mapping IN EXCLUSIVE MODE NOWAIT;
 select max(encounter_num) into maxEncounterNum from encounter_mapping ; 
 
if maxEncounterNum is null then 
  maxEncounterNum := 0;
end if;

  open distinctEidCur for EXECUTE(sql_stmt) ;
 
   loop
     FETCH distinctEidCur INTO disEncounterId, disEncounterIdSource;
      -- smuniraju: %NOTFOUND not supported in postgres.
	  -- EXIT WHEN distinctEidCur%NOTFOUND;
	 EXIT WHEN NOT FOUND;
      -- dbms_output.put_line(disEncounterId);
        
  if  disEncounterIdSource = 'HIVE'  THEN    
   begin
    --check if hive NUMERIC exist, if so assign that NUMERIC to reset of map_id's within that pid
    select encounter_num into existingEncounterNum from encounter_mapping where encounter_num = disEncounterId and encounter_ide_source = 'HIVE';
    
    EXCEPTION  
       when NO_DATA_FOUND THEN
           existingEncounterNum := null;
    end;
   
   if existingEncounterNum is not null then 
		-- smuniraju: NOT EXISTS clause reults in a co-related queries which are not supported in greenplum
        -- execute ' update ' || tempEidTableName ||' set encounter_num = encounter_id, process_status_flag = ''P''
        -- where encounter_id = ' || disEncounterId || ' and not exists (select 1 from encounter_mapping em where em.encounter_ide = encounter_map_id
        -- and em.encounter_ide_source = encounter_map_id_source)';		
		execute ' 	update ' || tempEidTableName ||' set 
					encounter_num = encounter_id::numeric, process_status_flag = ''P''
					from encounter_mapping em 
					where em.encounter_ide = encounter_map_id
					and em.encounter_ide_source = encounter_map_id_source
					and encounter_id = ' || disEncounterId || ' 
					and em.encounter_ide is null
					and em.encounter_ide_source is null ';
   else 
        -- generate new patient_num i.e. take max(_num) + 1 
        if maxEncounterNum < disEncounterId then 
            maxEncounterNum := disEncounterId;
        end if ;
		-- smuniraju : NOT EXISTS clause reults in a co-related queries which are not supported in greenplum
        -- execute ' update ' || tempEidTableName ||' set encounter_num = encounter_id, process_status_flag = ''P'' where 
        -- encounter_id = ' || disEncounterId || ' and encounter_id_source = ''HIVE'' and not exists (select 1 from encounter_mapping em where em.encounter_ide = encounter_map_id
        -- and em.encounter_ide_source = encounter_map_id_source)' ;		
		execute '   update ' || tempEidTableName ||' set 
					encounter_num = encounter_id::numeric, process_status_flag = ''P''
					from encounter_mapping em 
					where em.encounter_ide = encounter_map_id
					and em.encounter_ide_source = encounter_map_id_source
					and encounter_id = ' || disEncounterId || ' 
					and encounter_id_source = ''HIVE'' 
					and em.encounter_ide is null
					and em.encounter_ide_source is null ';      
   end if;    
   
   -- test if record fectched
   -- dbms_output.put_line(' HIVE ');

 else 
    begin
       select encounter_num into existingEncounterNum from encounter_mapping where encounter_ide = disEncounterId and 
        encounter_ide_source = disEncounterIdSource ; 

       -- test if record fetched. 
       EXCEPTION
           WHEN NO_DATA_FOUND THEN
           existingEncounterNum := null;
       end;
       if existingEncounterNum is not  null then 
			-- smuniraju: NOT EXISTS clause reults in a co-related queries which are not supported in greenplum
            -- execute ' update ' || tempEidTableName ||' set encounter_num = ' || existingEncounterNum || ' , process_status_flag = ''P''
            -- where encounter_id = ' || disEncounterId || ' and not exists (select 1 from encounter_mapping em where em.encounter_ide = encounter_map_id
			-- and em.encounter_ide_source = encounter_map_id_source)' ;
		execute ' update ' || tempEidTableName ||' set 
				  encounter_num = ' || existingEncounterNum || '::numeric , process_status_flag = ''P''
				  from encounter_mapping em 
				  where em.encounter_ide = encounter_map_id and em.encounter_ide_source = encounter_map_id_source
				  and encounter_id = ' || disEncounterId || ' 
				  and em.encounter_ide is null 
				  and em.encounter_ide_source is null' ;
       else 
            maxEncounterNum := maxEncounterNum + 1 ;
			
			--TODO : add update colunn
             execute ' insert into ' || tempEidTableName ||' (encounter_map_id,encounter_map_id_source,encounter_id,encounter_id_source,encounter_num,process_status_flag
             ,encounter_map_id_status,update_date,download_date,import_date,sourcesystem_cd) 
             values(' || maxEncounterNum || ',''HIVE'',' || maxEncounterNum || ',''HIVE'',' || maxEncounterNum ||',''P'',''A'',current_timestamp,current_timestamp,current_timestamp,''edu.harvard.i2b2.crc'')'; 
             
            -- smuniraju: NOT EXISTS clause reults in a co-related queries which are not supported in greenplum
	        -- execute ' update ' || tempEidTableName ||' set encounter_num =  ' || maxEncounterNum || ' , process_status_flag = ''P'' 
            -- where encounter_id = ' || disEncounterId || ' and  not exists (select 1 from 
            -- encounter_mapping em where em.encounter_ide = encounter_map_id
            -- and em.encounter_ide_source = encounter_map_id_source)' ;
			execute ' update ' || tempEidTableName ||' set 
					  encounter_num = ' || maxEncounterNum || ' , process_status_flag = ''P''
					  from encounter_mapping em 
					  where em.encounter_ide = encounter_map_id and em.encounter_ide_source = encounter_map_id_source
					  and encounter_id = ' || disEncounterId || ' 
					  and em.encounter_ide is null 
					  and em.encounter_ide_source is null' ;
            
       end if ;
 end if; 

END LOOP;
close distinctEidCur ;

-- smuniraju Postgres doesn't allow commit within procedures because it is explicity done upon 'END;'
-- commit;

 -- do the mapping update if the update date is old
   execute 'update encounter_mapping em set 
			encounter_num = temp.encounter_id::numeric,
			patient_ide = temp.patient_map_id ,
			patient_ide_source  = temp.patient_map_id_source ,
			encounter_ide_status = temp.encounter_map_id_status  ,
			update_date = temp.update_date,
			download_date = temp.download_date ,
			import_date = now() ,
			sourcesystem_cd  = temp.sourcesystem_cd ,
			upload_id = ' || upload_id || ' 
			from ' || tempEidTableName || ' temp
            where em.encounter_ide = temp.encounter_map_id 
			and em.encounter_ide_source = temp.encounter_map_id_source 
			and temp.encounter_id_source = ''HIVE'' and temp.process_status_flag is null  
			and coalesce(em.update_date,to_date(''01-JAN-1900'',''DD-MON-YYYY''))<= coalesce(temp.update_date,to_date(''01-JAN-1900'',''DD-MON-YYYY'')) ' ;

-- insert new mapping records i.e flagged P

execute ' insert into encounter_mapping (encounter_ide,encounter_ide_source,encounter_ide_status,encounter_num,patient_ide,patient_ide_source,update_date,download_date,import_date,sourcesystem_cd,upload_id) 
			select 	encounter_map_id,encounter_map_id_source,encounter_map_id_status,encounter_num,patient_map_id,patient_map_id_source,update_date,download_date,current_timestamp,sourcesystem_cd,' || upload_id || ' 
			from ' || tempEidTableName || '  
			where process_status_flag = ''P'' ' ; 

-- smuniraju Postgres doesn't allow commit within procedures because it is explicity done upon 'END;'
-- commit;
EXCEPTION
   WHEN OTHERS THEN
	  -- smuniraju
      /*if distinctEidCur%isopen then
          close distinctEidCur;
      end if;*/
	  RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;
	  
	  begin
		close distinctEidCur;
		EXCEPTION
			WHEN OTHERS THEN
			RAISE NOTICE 'Error occurred when attempting to close cursor.';
	  end;	
      -- smuniraju Postgres doesn't allow rollback within procedures because it is explicity when a transaction fails.
      -- rollback;
      
end;
$$;


ALTER FUNCTION i2b2demodata.insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_encountervisit_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

DECLARE
maxEncounterNum NUMERIC; 
BEGIN 

    --Delete duplicate rows with same encounter and patient combination
	-- smuniraju
	-- execute  'DELETE FROM ' || tempTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempTableName || ' t2
	-- 				     WHERE t1.encounter_id = t2.encounter_id 
    --                   AND t1.encounter_id_source = t2.encounter_id_source
    --                   AND nvl(t1.patient_id,'''') = nvl(t2.patient_id,'''')
    --                   AND nvl(t1.patient_id_source,'''') = nvl(t2.patient_id_source,''''))';
	execute  'DELETE FROM ' || tempTableName || ' t1 
			  WHERE ( ctid) NOT IN (
					SELECT  max(ctid) FROM ' || tempTableName || ' t2
					GROUP BY  encounter_id,encounter_id_source)';
	
	 LOCK TABLE  encounter_mapping IN EXCLUSIVE MODE NOWAIT;
    -- select max(encounter_num) into maxEncounterNum from encounter_mapping ;

	--Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	-- smuniraju
    --  execute  ' insert into encounter_mapping (encounter_ide,encounter_ide_source,encounter_num,patient_ide,patient_ide_source,encounter_ide_status, upload_id)
    --  	(select distinctTemp.encounter_id, distinctTemp.encounter_id_source, distinctTemp.encounter_id,  distinctTemp.patient_id,distinctTemp.patient_id_source,''A'',  '|| upload_id ||'
	-- 			from 
	-- 				(select distinct encounter_id, encounter_id_source,patient_id,patient_id_source from ' || tempTableName || '  temp
	-- 				where 
	-- 			     not exists (select encounter_ide from encounter_mapping em where em.encounter_ide = temp.encounter_id and em.encounter_ide_source = temp.encounter_id_source)
	-- 				 and encounter_id_source = ''HIVE'' )   distinctTemp) ' ;

	execute  ' insert into encounter_mapping (encounter_ide,encounter_ide_source,encounter_num,patient_ide,patient_ide_source,encounter_ide_status, upload_id) (
					select distinctTemp.encounter_id, distinctTemp.encounter_id_source, distinctTemp.encounter_id::numeric,  distinctTemp.patient_id,distinctTemp.patient_id_source,''A'',  '|| upload_id ||'
					from (
						select distinct encounter_id, encounter_id_source,patient_id,patient_id_source 
						from ' || tempTableName || ' temp left outer join encounter_mapping em
						on em.encounter_ide = temp.encounter_id and em.encounter_ide_source = temp.encounter_id_source
						where em.encounter_ide_source is null
						and  em.encounter_ide is null
						and encounter_id_source = ''HIVE'' )   distinctTemp) ' ;
	
	-- update patient_num for temp table
	-- smuniraju: Greenplum doesn't support sub query for setting a column value.
	-- update patient_num for temp table
	-- execute  ' UPDATE ' ||  tempTableName || ' SET encounter_num = (SELECT em.encounter_num
	-- 	     FROM encounter_mapping em
	-- 	     WHERE em.encounter_ide = '|| tempTableName ||'.encounter_id
    --       and em.encounter_ide_source = '|| tempTableName ||'.encounter_id_source 
	-- 	     and coalesce(em.patient_ide_source,'''') = coalesce('|| tempTableName ||'.patient_id_source,'''')
	-- 	     and coalesce(em.patient_ide,'''')= coalesce('|| tempTableName ||'.patient_id,''''))
	-- 	     WHERE EXISTS (SELECT em.encounter_num
	-- 	     FROM encounter_mapping em
	-- 	     WHERE em.encounter_ide = '|| tempTableName ||'.encounter_id
    --   	 and em.encounter_ide_source = '||tempTableName||'.encounter_id_source
	-- 	     and coalesce(em.patient_ide_source,'''') = coalesce('|| tempTableName ||'.patient_id_source,'''')
	-- 	     and coalesce(em.patient_ide,'''')= coalesce('|| tempTableName ||'.patient_id,''''))';	
		     
	execute  ' UPDATE ' ||  tempTableName || ' temp SET encounter_num = em.encounter_num
		     FROM encounter_mapping em
		     WHERE em.encounter_ide = '|| tempTableName ||'.encounter_id
             and em.encounter_ide_source = '|| tempTableName ||'.encounter_id_source 
		     and coalesce(em.patient_ide_source,'''') = coalesce(temp.patient_id_source,'''')
		     and coalesce(em.patient_ide,'''')= coalesce(temp.patient_id,'''')
		     and EXISTS (
				SELECT em.encounter_num
				FROM encounter_mapping em
				WHERE em.encounter_ide = '|| tempTableName ||'.encounter_id
				and em.encounter_ide_source = '||tempTableName||'.encounter_id_source
				and coalesce(em.patient_ide_source,'''') = coalesce(temp.patient_id_source,'''')
				and coalesce(em.patient_ide,'''')= coalesce(temp.patient_id,''''))';	

	 execute  'UPDATE visit_dimension vd set 
				inout_cd = temp.inout_cd,
				location_cd = temp.location_cd,
				location_path = temp.location_path,
				start_date = temp.start_date,
				end_date = temp.end_date,
				visit_blob = temp.visit_blob,
				update_date = temp.update_date,
				download_date = temp.download_date,
				import_date = now(),
				sourcesystem_cd = temp.sourcesystem_cd
				from ' || tempTableName || ' temp
				where vd.encounter_num = temp.encounter_num
				and temp.update_date >= vd.update_date';

	-- smuniraju
    -- execute  'insert into visit_dimension  (encounter_num,patient_num,START_DATE,END_DATE,INOUT_CD,LOCATION_CD,VISIT_BLOB,UPDATE_DATE,DOWNLOAD_DATE,IMPORT_DATE,SOURCESYSTEM_CD, UPLOAD_ID)
	--  	select temp.encounter_num, pm.patient_num, temp.START_DATE,temp.END_DATE,temp.INOUT_CD,temp.LOCATION_CD,temp.VISIT_BLOB,
	-- 		temp.update_date, temp.download_date, sysdate, -- import date temp.sourcesystem_cd, '|| upload_id ||'
	-- 		from ' || tempTableName || '  temp , patient_mapping pm 
	-- 		where temp.encounter_num is not null and 
	-- 	      	 not exists (select encounter_num from visit_dimension vd where vd.encounter_num = temp.encounter_num) and 
	-- 			 pm.patient_ide = temp.patient_id and pm.patient_ide_source = temp.patient_id_source
	-- ';
	execute  'insert into visit_dimension (encounter_num,patient_num,START_DATE,END_DATE,INOUT_CD,LOCATION_CD,VISIT_BLOB,UPDATE_DATE,DOWNLOAD_DATE,IMPORT_DATE,SOURCESYSTEM_CD, UPLOAD_ID)
				select temp.encounter_num, pm.patient_num, temp.START_DATE,temp.END_DATE,temp.INOUT_CD,temp.LOCATION_CD,temp.VISIT_BLOB,
				temp.update_date, temp.download_date, current_timestamp, -- import date temp.sourcesystem_cd, '|| upload_id ||'
				from ' || tempTableName || '  temp left outer join patient_mapping pm  
				on	pm.patient_ide = temp.patient_id and pm.patient_ide_source = temp.patient_id_source
				left outer join visit_dimension vd 
				on vd.encounter_num = temp.encounter_num
				where temp.encounter_num is not null 				
				and vd.encounter_num  is null'; 
				
-- smuniraju: Postgres doesn't allow commit within procedures because it is explicity done upon 'END;'	 
-- commit;
		        
EXCEPTION
	WHEN OTHERS THEN
		-- smuniraju: Postgres doesn't allow rollback within procedures because it is explicity when a transaction fails.	 
		-- rollback;
		Raise exception 'An error(-20001) was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;
$$;


ALTER FUNCTION i2b2demodata.insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_modifier_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	--Delete duplicate rows 
	-- smuniraju rowid not implemented in postgres
	-- execute  'DELETE FROM ' || tempModifierTableName || ' t1 WHERE rowid > 
	-- 				(SELECT  min(rowid) FROM ' || tempModifierTableName || ' t2
	-- 				 WHERE t1.modifier_cd = t2.modifier_cd 
    --               AND t1.modifier_path = t2.modifier_path)';
	execute  'DELETE FROM ' || tempModifierTableName || ' t1 WHERE ( ctid) NOT IN  
			   (SELECT   max(ctid) FROM ' || tempModifierTableName || ' t2
				GROUP BY  modifier_path,modifier_cd)';
						 
    execute 'UPDATE modifier_dimension cd set 
			name_char= temp.name_char,
			modifier_blob= temp.modifier_blob,
			update_date= temp.update_date,
			import_date = now(),
			DOWNLOAD_DATE=temp.DOWNLOAD_DATE,
			SOURCESYSTEM_CD=temp.SOURCESYSTEM_CD,
			UPLOAD_ID = '|| upload_id || '
			from ' || tempModifierTableName || ' temp
			where cd.modifier_path = temp.modifier_path
			and temp.update_date >= cd.update_date';

    --Create new modifier if temp table modifier_path does not exists 
	-- in modifier dimension table.
	-- smuniraju: not exists => co-related query
	-- execute  'insert into modifier_dimension  (modifier_cd,modifier_path,name_char,modifier_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
	-- 		    select  modifier_cd, modifier_path,
    --                     name_char,modifier_blob,
    --                     update_date,download_date,
    --                     sysdate,sourcesystem_cd,
    --                      ' || upload_id || '  from ' || tempModifierTableName || '  temp
	-- 				where not exists (select modifier_cd from modifier_dimension cd where cd.modifier_path = temp.modifier_path)					 
	-- 	';
	
	execute  'insert into modifier_dimension  (modifier_cd,modifier_path,name_char,modifier_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  modifier_cd, modifier_path, name_char,modifier_blob, update_date,download_date, current_timestamp, sourcesystem_cd,' || upload_id || '  
					from ' || tempModifierTableName || '  temp left outer join modifier_dimension cd
					on cd.modifier_path = temp.modifier_path 
					where cd.modifier_path is null)';
	 
EXCEPTION
	WHEN OTHERS THEN
		raise exception 'An error(-20001) was encountered - %-ERROR- %', SQLSTATE, SQLERRM;	
END;
$$;


ALTER FUNCTION i2b2demodata.insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_patient_map_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	
	-- Create new patient mapping entry for HIVE patient's if they are not already mapped in mapping table
	-- smuniraju: not exists => co-related
	-- execute 'insert into patient_mapping (
	-- 		select distinct temp.patient_id, temp.patient_id_source,''A'',temp.patient_id ,' || upload_id || '
	-- 		from ' || tempPatientTableName ||'  temp 
	-- 		where temp.patient_id_source = ''HIVE'' and 
   	-- 		not exists (
	--			select patient_ide from patient_mapping pm where pm.patient_num = temp.patient_id and pm.patient_ide_source = temp.patient_id_source) 
	-- 	)'; 
    
	execute 'insert into patient_mapping (patient_ide, patient_ide_source, patient_ide_status, patient_num, upload_id) (
				select distinct temp.patient_id, temp.patient_id_source,''A'',temp.patient_id::numeric ,' || upload_id || '
				from ' || tempPatientTableName ||'  temp left outer join patient_mapping pm
				on pm.patient_num = temp.patient_id and pm.patient_ide_source = temp.patient_id_source			
				where temp.patient_id_source = ''HIVE'' 
				and pm.patient_num is null 
				and pm.patient_ide_source is null)'; 
		
    --Create new visit for above inserted encounter's
	--If Visit table's encounter and patient num does match temp table,
	--then new visit information is created.
	execute 'UPDATE patient_dimension pd set 
			 VITAL_STATUS_CD= temp.VITAL_STATUS_CD,
			 BIRTH_DATE= temp.BIRTH_DATE,
			 DEATH_DATE= temp.DEATH_DATE,
			 SEX_CD= temp.SEX_CD,
			 AGE_IN_YEARS_NUM=temp.AGE_IN_YEARS_NUM,
			 LANGUAGE_CD=temp.LANGUAGE_CD,
			 RACE_CD=temp.RACE_CD,
			 MARITAL_STATUS_CD=temp.MARITAL_STATUS_CD,
			 RELIGION_CD=temp.RELIGION_CD,
			 ZIP_CD=temp.ZIP_CD,
			 STATECITYZIP_PATH =temp.STATECITYZIP_PATH,
			 PATIENT_BLOB=temp.PATIENT_BLOB,
			 UPDATE_DATE=temp.UPDATE_DATE,
			 DOWNLOAD_DATE=temp.DOWNLOAD_DATE,
			 SOURCESYSTEM_CD=temp.SOURCESYSTEM_CD,
			 UPLOAD_ID = '|| upload_id || '
			 from ' || tempPatientTableName || ' temp
			 where pd.patient_num = temp.patient_num
			 and temp.update_date > pd.update_date';
EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;

$$;


ALTER FUNCTION i2b2demodata.insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_pid_map_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

DECLARE
 existingPatientNum VARCHAR(32);
 maxPatientNum NUMERIC;
 --TYPE distinctPidCurTyp IS REF CURSOR;
 --distinctPidCurTyp refcursor;
 --distinctPidCur   distinctPidCurTyp;
 distinctPidCur REFCURSOR;
 sql_stmt  VARCHAR(400);
disPatientId VARCHAR(100); 
disPatientIdSource VARCHAR(100);

BEGIN
 sql_stmt := ' SELECT distinct patient_id,patient_id_source from ' || tempPidTableName ||' ';
 
  --delete the data if they miss 
  -- smuniraju: rowid not implemented in postgres/ greenplum
  -- execute ' delete  from ' || tempPidTableName ||  ' t1  
  --			where rowid > (select min(rowid) from ' || tempPidTableName || ' t2 
  -- 			where t1.patient_map_id = t2.patient_map_id
  -- 			and t1.patient_map_id_source = t2.patient_map_id_source) ';
  execute 'delete  from ' || tempPidTableName ||  ' t1  
		   where ( ctid) 
		    not in (select  max(ctid) from  ' || tempPidTableName ||  ' 
			group  BY patient_map_id,patient_map_id_source,patient_id,patient_id_source)';
  
  LOCK TABLE  patient_mapping IN EXCLUSIVE MODE NOWAIT;
  select max(patient_num) into maxPatientNum from patient_mapping ; 
 
 -- set max patient num to zero of the value is null
  if maxPatientNum is null then 
    maxPatientNum := 0;
  end if;

  open distinctPidCur for execute(sql_stmt);

  loop   
     FETCH distinctPidCur INTO disPatientId, disPatientIdSource;
      -- smuniraju: %NOTFOUND is not supported in POSTGRES
	  -- EXIT WHEN distinctPidCur%NOTFOUND;
	  EXIT WHEN NOT FOUND;    
        
	  if  disPatientIdSource = 'HIVE' THEN 
		begin
		 --check if hive NUMERIC exist, if so assign that NUMERIC to reset of map_id's within that pid
		 select patient_num into existingPatientNum from patient_mapping where patient_num = disPatientId and patient_ide_source = 'HIVE';
		   EXCEPTION  
			 when NO_DATA_FOUND THEN
			   existingPatientNum := null;
		end;
   
		if existingPatientNum is not null then 
			-- smuniraju: not exists results in corelated queries not supported by greenplum
			-- execute ' update ' || tempPidTableName ||' set patient_num = patient_id, process_status_flag = ''P''
			-- where patient_id = ' || disPatientId || ' and not exists (select 1 from patient_mapping pm where pm.patient_ide = patient_map_id
			-- and pm.patient_ide_source = patient_map_id_source)';
			execute 'update ' || tempPidTableName ||' temp set patient_num = patient_id::numeric, process_status_flag = ''P''
					 from patient_mapping pm 
					 where pm.patient_ide = temp.patient_map_id
					 and pm.patient_ide_source = temp.patient_map_id_source
					 and pm.patient_ide is null
					 and patient_id = ' || disPatientId || '';
		else 
			-- generate new patient_num i.e. take max(patient_num) + 1 
			if maxPatientNum < disPatientId then 
			   maxPatientNum := disPatientId;
			end if ;
	
		-- smuniraju: not exists results in corelated queries not supported by greenplum
		-- execute ' update ' || tempPidTableName ||' set patient_num = patient_id, process_status_flag = ''P'' where 
		-- patient_id = ' || disPatientId || ' and patient_id_source = ''HIVE'' and not exists (select 1 from patient_mapping pm where pm.patient_ide -- = patient_map_id and pm.patient_ide_source = patient_map_id_source)';
		execute 'update ' || tempPidTableName ||' temp set patient_num = patient_id::numeric, process_status_flag = ''P'' 
				 from patient_mapping pm
				 where pm.patient_ide = temp.patient_map_id
				 and pm.patient_ide_source = temp.patient_map_id_source
				 and pm.patient_ide is null and  pm.patient_ide_source is null
				 and patient_id = ' || disPatientId || ' and patient_id_source = ''HIVE'''; 
	end if;    
    
	  -- test if record fectched
	  -- dbms_output.put_line(' HIVE ');
	else 
		begin
		   select patient_num into existingPatientNum from patient_mapping where patient_ide = disPatientId and 
			patient_ide_source = disPatientIdSource ; 

		   -- test if record fetched. 
		   EXCEPTION
			   WHEN NO_DATA_FOUND THEN
			   existingPatientNum := null;
		   end;
		   if existingPatientNum is not null then 
				-- smuniraju: not exists results in corelated queries not supported by greenplum
				-- execute ' update ' || tempPidTableName ||' set patient_num = ' || existingPatientNum || ', process_status_flag = ''P''
				-- where patient_id = ' || disPatientId || ' and not exists (select 1 from patient_mapping pm where pm.patient_ide = patient_map_id
				-- and pm.patient_ide_source = patient_map_id_source)' ;
				execute 'update ' || tempPidTableName ||' temp set patient_num = ' || existingPatientNum || '::numeric, process_status_flag = ''P''
						 from patient_mapping pm 
						 where pm.patient_ide = temp.patient_map_id
						 and pm.patient_ide_source = temp.patient_map_id_source
						 and pm.patient_ide is null and pm.patient_ide_source is null
						 and patient_id = ' || disPatientId || '';
		   else 
				maxPatientNum := maxPatientNum + 1 ; 
				 execute 'insert into ' || tempPidTableName ||' (patient_map_id,patient_map_id_source,patient_id,patient_id_source,patient_num,process_status_flag
				 ,patient_map_id_status,update_date,download_date,import_date,sourcesystem_cd) 
				 values(' || maxPatientNum || ',''HIVE'',' || maxPatientNum || ',''HIVE'',' || maxPatientNum || ',''P'',''A'',current_timestamp,current_timestamp,current_timestamp,''edu.harvard.i2b2.crc'')'; 
			   
			   -- smuniraju: not exists results in corelated queries not supported by greenplum
			   -- execute 'update ' || tempPidTableName ||' set patient_num =  ' || maxPatientNum || ' , process_status_flag = ''P'' 
			   -- where patient_id = ' || disPatientId || ' and  not exists (select 1 from 
			   --  patient_mapping pm where pm.patient_ide = patient_map_id
			   --  and pm.patient_ide_source = patient_map_id_source)' ;
				execute 'update ' || tempPidTableName ||' temp set patient_num =  ' || maxPatientNum || ' , process_status_flag = ''P'' 
						 from patient_mapping pm 
						 where pm.patient_ide = temp.patient_map_id
						 and pm.patient_ide_source = temp.patient_map_id_source
						 and pm.patient_ide is null 
						 and pm.patient_ide_source is null
						 and patient_id = ' || disPatientId || ' ';						
		   end if ;
      -- dbms_output.put_line(' NOT HIVE ');
	end if; 
  END LOOP;
  close distinctPidCur ;
  -- smuniraju: Postgres doesn't allow commit and rollback within procedures because it is explicity done upon 'END;'	 
  -- commit;

  -- do the mapping update if the update date is old
  -- smuniraju: merge resulting in errors.
   /* execute ' merge into patient_mapping
      using ' || tempPidTableName ||' temp
      on (temp.patient_map_id = patient_mapping.patient_IDE 
  		  and temp.patient_map_id_source = patient_mapping.patient_IDE_SOURCE
	   ) when matched then 
  		update set patient_num = temp.patient_id,
    	patient_ide_status	= temp.patient_map_id_status  ,
    	update_date = temp.update_date,
    	download_date  = temp.download_date ,
		import_date = sysdate ,
    	sourcesystem_cd  = temp.sourcesystem_cd ,
		upload_id = ' || upload_id ||'  
    	where  temp.patient_id_source = ''HIVE'' and temp.process_status_flag is null  and
        nvl(patient_mapping.update_date,to_date(''1900-01-01'',''YYYY-MM-DD''))<= nvl(temp.update_date,to_date(''1900-01-01'',''YYYY-MM-DD'')) ' ;
	*/
  execute ' update patient_mapping pm set 
			patient_num = temp.patient_id::numeric,
			patient_ide_status	= temp.patient_map_id_status  ,
			update_date = temp.update_date,
			download_date  = temp.download_date ,
			import_date = now() ,
			sourcesystem_cd  = temp.sourcesystem_cd ,
			upload_id = ' || upload_id ||'  	
			from ' || tempPidTableName ||' temp
			where pm.patient_ide = temp.patient_map_id and pm.patient_ide_source = temp.patient_map_id_source
			and temp.patient_id_source = ''HIVE'' and temp.process_status_flag is null  and 
			coalesce(pm.update_date,to_date(''1900-01-01'',''YYYY-MM-DD''))<= coalesce(temp.update_date,to_date(''1900-01-01'',''YYYY-MM-DD'')) ' ;
	
  -- insert new mapping records i.e flagged P
  execute ' insert into patient_mapping (patient_ide,patient_ide_source,patient_ide_status,patient_num,update_date,download_date,import_date,sourcesystem_cd,upload_id) 
				select patient_map_id,patient_map_id_source,patient_map_id_status,patient_num,update_date,download_date,now(),sourcesystem_cd,' || upload_id ||' from '|| tempPidTableName || ' 
				where process_status_flag = ''P'' ' ; 
  -- smuniraju: Postgres doesn't allow commit and rollback within procedures because it is explicity done upon 'END;'	 
  -- commit;
  EXCEPTION
   WHEN OTHERS THEN
		RAISE EXCEPTION'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;
		  -- postgres  doesn't support isOpen
		  -- if distinctPidCur%isopen then
		  --    close distinctPidCur;
		  -- end if;
	  begin
		close distinctPidCur;
		EXCEPTION
			WHEN OTHERS THEN
				RAISE NOTICE 'Error occured closing cursor.';
	  end;
      -- smuniraju: Postgres doesn't allow rollback within procedures because it is explicity when a transaction fails.
	  -- rollback;      
end;

$$;


ALTER FUNCTION i2b2demodata.insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_provider_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

BEGIN 
	--Delete duplicate rows with same encounter and patient combination
	-- smuniraju: rowid not supported
	-- execute 'DELETE FROM ' || tempProviderTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempProviderTableName || ' t2
	-- 				     WHERE t1.provider_id = t2.provider_id 
    --                                         AND t1.provider_path = t2.provider_path
    --                                         )';
	execute 'DELETE FROM ' || tempProviderTableName || ' t1 
			 WHERE ( ctid) NOT IN ( 
				SELECT  max(ctid)
				FROM ' || tempProviderTableName || ' t2
				GROUP BY  provider_path)';
	
 execute 'UPDATE patient_dimension set 
			provider_id = temp.provider_id,
			name_char = temp.name_char,
			provider_blob = provider_blob,
			IMPORT_DATE=now(),
			UPDATE_DATE=temp.UPDATE_DATE,
			DOWNLOAD_DATE=temp.DOWNLOAD_DATE,
			SOURCESYSTEM_CD=temp.SOURCESYSTEM_CD,
			UPLOAD_ID = '||  upload_id || '
			from provider_dimension pd 
			inner join ' || tempProviderTableName || ' temp
			on  pd.provider_path = temp.provider_path
			where temp.update_date >= pd.update_date) ';

   
    --Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	-- smuniraju: not exists => co-related query.
	-- execute 'insert into provider_dimension  (provider_id,provider_path,name_char,provider_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
	-- 		    select  provider_id,provider_path, 
    --                     name_char,provider_blob,
    --                     update_date,download_date,
    --                     now(),sourcesystem_cd, ' || upload_id || '	                    
    --                      from ' || tempProviderTableName || '  temp
	-- 				where not exists (select provider_id from provider_dimension pd where pd.provider_path = temp.provider_path )';
	execute 'insert into provider_dimension  (provider_id,provider_path,name_char,provider_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  provider_id,provider_path, 
                        name_char,provider_blob,
                        update_date,download_date,
                        now(),sourcesystem_cd, ' || upload_id || '	                    
                        from ' || tempProviderTableName || '  temp left outer join provider_dimension pd 
						on pd.provider_path = temp.provider_path 
						where pd.provider_path is null';   
EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;

$$;


ALTER FUNCTION i2b2demodata.insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: remove_temp_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION remove_temp_table(temptablename character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN 
	execute 'drop table ' || tempTableName || ' cascade';
	
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;
$$;


ALTER FUNCTION i2b2demodata.remove_temp_table(temptablename character varying) OWNER TO i2b2demodata;

--
-- Name: sync_clear_concept_table(character varying, character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ DECLARE

DECLARE
interConceptTableName  varchar(400);

BEGIN 
	interConceptTableName := backupConceptTableName || '_inter';
	
		--Delete duplicate rows with same encounter and patient combination
		-- smuniraju
	-- execute 'DELETE FROM ' || tempConceptTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempConceptTableName || ' t2
	-- 				     WHERE t1.concept_cd = t2.concept_cd 
    --                                         AND t1.concept_path = t2.concept_path
    --                                         )';
	execute 'DELETE FROM ' || tempConceptTableName || ' t1 
	         WHERE ( ctid) NOT IN  
					   (SELECT   max(rowid) FROM ' || tempConceptTableName || ' t2
					     GROUP BY  concept_path,concept_cd)';
						 
    execute 'create table ' ||  interConceptTableName || ' (
    CONCEPT_CD          VARCHAR(50) NOT NULL,
	CONCEPT_PATH    	VARCHAR(700) NOT NULL,
	NAME_CHAR       	VARCHAR(2000) NULL,
	CONCEPT_BLOB        TEXT NULL,
	UPDATE_DATE         DATE NULL,
	DOWNLOAD_DATE       DATE NULL,
	IMPORT_DATE         DATE NULL,
	SOURCESYSTEM_CD     VARCHAR(50) NULL,
	UPLOAD_ID       	NUMERIC(38,0) NULL,
    CONSTRAINT '|| interConceptTableName ||'_pk  PRIMARY KEY(CONCEPT_PATH)
	 )';
    
    --Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	execute 'insert into '|| interConceptTableName ||'  (concept_cd,concept_path,name_char,concept_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  concept_cd, substr(concept_path,1,700),
                        name_char,concept_blob,
                        update_date,download_date,
                        current_timestamp,sourcesystem_cd,
                         ' || uploadId || '  from ' || tempConceptTableName || '  temp ';
	--backup the concept_dimension table before creating a new one
	execute 'alter table concept_dimension rename to ' || backupConceptTableName  ||'' ;
    
	-- add index on upload_id 
    execute 'CREATE INDEX ' || interConceptTableName || '_uid_idx ON ' || interConceptTableName || '(UPLOAD_ID)';

    -- add index on upload_id 
    execute 'CREATE INDEX ' || interConceptTableName || '_cd_idx ON ' || interConceptTableName || '(concept_cd)';

    
    --backup the concept_dimension table before creating a new one
	execute 'alter table ' || interConceptTableName  || ' rename to concept_dimension' ;
 
EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;
$$;


ALTER FUNCTION i2b2demodata.sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: sync_clear_provider_table(character varying, character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ DECLARE 

DECLARE
interProviderTableName  varchar(400);

BEGIN 
	interProviderTableName := backupProviderTableName || '_inter';
	
	--Delete duplicate rows with same encounter and patient combination
	-- smuniraju: rowid not supported in postgres	
	-- execute 'DELETE FROM ' || tempProviderTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempProviderTableName || ' t2
	-- 				     WHERE t1.provider_id = t2.provider_id 
    --                                        AND t1.provider_path = t2.provider_path
    --                                         )';
	execute 'DELETE FROM ' || tempProviderTableName || ' t1 
			 WHERE ( ctid) NOT IN (
				SELECT  max(ctid) 
				FROM ' || tempProviderTableName || ' t2
				GROUP BY   provider_path,provider_id)';				
											
    execute 'create table ' ||  interProviderTableName || ' (
    PROVIDER_ID         VARCHAR(50) NOT NULL,
	PROVIDER_PATH       VARCHAR(700) NOT NULL,
	NAME_CHAR       	VARCHAR(850) NULL,
	PROVIDER_BLOB       TEXT NULL,
	UPDATE_DATE     	DATE NULL,
	DOWNLOAD_DATE       DATE NULL,
	IMPORT_DATE         DATE NULL,
	SOURCESYSTEM_CD     VARCHAR(50) NULL,
	UPLOAD_ID        	NUMERIC(38,0) NULL ,
    CONSTRAINT  ' || interProviderTableName || '_pk PRIMARY KEY(PROVIDER_PATH,provider_id)
	 )';
    
    --Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	execute 'insert into ' ||  interProviderTableName || ' (provider_id,provider_path,name_char,provider_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  provider_id,provider_path, 
                        name_char,provider_blob,
                        update_date,download_date,
                        now(),sourcesystem_cd, ' || uploadId || '
	                     from ' || tempProviderTableName || '  temp ';
					
	--backup the concept_dimension table before creating a new one
	execute 'alter table provider_dimension rename to ' || backupProviderTableName  ||'' ;
    
	-- add index on provider_id, name_char 
    execute 'CREATE INDEX ' || interProviderTableName || '_id_idx ON ' || interProviderTableName  || '(Provider_Id,name_char)';
    execute 'CREATE INDEX ' || interProviderTableName || '_uid_idx ON ' || interProviderTableName  || '(UPLOAD_ID)';

	--backup the concept_dimension table before creating a new one
	execute 'alter table ' || interProviderTableName  || ' rename to provider_dimension' ;
 
EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;

$$;


ALTER FUNCTION i2b2demodata.sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: update_observation_fact(character varying, numeric, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN



--Delete duplicate records(encounter_ide,patient_ide,concept_cd,start_date,modifier_cd,provider_id)
-- smuniraju: rowid not implemented in postgres
-- execute 'DELETE FROM ' || upload_temptable_name ||'  t1 
--  where rowid > (select min(rowid) from ' || upload_temptable_name ||' t2 
--    where t1.encounter_id = t2.encounter_id  
--          and
--          t1.encounter_id_source = t2.encounter_id_source
--          and
--          t1.patient_id = t2.patient_id 
--          and 
--          t1.patient_id_source = t2.patient_id_source
--          and 
--          t1.concept_cd = t2.concept_cd                
--          and 
--          t1.start_date = t2.start_date
--          and 
--          nvl(t1.modifier_cd,''xyz'') = nvl(t2.modifier_cd,''xyz'')
--		  and 
--		  t1.instance_num = t2.instance_num
--          and 
--          t1.provider_id = t2.provider_id)';
execute 'DELETE FROM ' || upload_temptable_name ||'  
		 WHERE ( ctid) not in (
			SELECT  max(ctid) FROM ' || upload_temptable_name ||' 
			GROUP BY  encounter_id,encounter_id_source,patient_id,patient_id_source, concept_cd,start_date,modifier_cd,provider_id,instance_num ORDER BY encounter_id,encounter_id_source)';
          
--Delete records having null in start_date
execute 'DELETE FROM ' || upload_temptable_name ||'  t1           
 where t1.start_date is null';
           
           
--One time lookup on encounter_ide to get encounter_num 
-- smuniraju: Greenplum doesn't support sub query for assigning values.
-- execute 'UPDATE ' ||  upload_temptable_name
--  || ' SET encounter_num = (SELECT em.encounter_num
-- 		     FROM encounter_mapping em
-- 		     WHERE em.encounter_ide = ' || upload_temptable_name||'.encounter_id
--                   and em.encounter_ide_source = '|| upload_temptable_name||'.encounter_id_source) 
--                   WHERE EXISTS (SELECT em.encounter_num
-- 		     FROM encounter_mapping em
-- 		     WHERE em.encounter_ide = '|| upload_temptable_name||'.encounter_id
--		     and em.encounter_ide_source = '||upload_temptable_name||'.encounter_id_source)';		     

execute 'UPDATE ' ||  upload_temptable_name || ' SET encounter_num = em.encounter_num
	FROM encounter_mapping em
	WHERE em.encounter_ide = ' || upload_temptable_name||'.encounter_id
        and em.encounter_ide_source = '|| upload_temptable_name||'.encounter_id_source) 
        and EXISTS (
		SELECT em.encounter_num
		FROM encounter_mapping em
		WHERE em.encounter_ide = '|| upload_temptable_name||'.encounter_id
                and em.encounter_ide_source = '||upload_temptable_name||'.encounter_id_source)';	     

--One time lookup on patient_ide to get patient_num 
-- smuniraju: Greenplum doesn't support sub query for assigning values.
-- execute 'UPDATE ' ||  upload_temptable_name
--  || ' SET patient_num = (SELECT pm.patient_num
-- 		     FROM patient_mapping pm
-- 		     WHERE pm.patient_ide = '|| upload_temptable_name||'.patient_id
--                      and pm.patient_ide_source = '|| upload_temptable_name||'.patient_id_source
-- 	 	    )WHERE EXISTS (SELECT pm.patient_num 
-- 		     FROM patient_mapping pm
-- 		     WHERE pm.patient_ide = '|| upload_temptable_name||'.patient_id
--                      and pm.patient_ide_source = '||upload_temptable_name||'.patient_id_source)';		     

execute 'UPDATE ' ||  upload_temptable_name || ' SET patient_num = pm.patient_num
	FROM patient_mapping pm
	WHERE pm.patient_ide = '|| upload_temptable_name||'.patient_id
        and pm.patient_ide_source = '|| upload_temptable_name||'.patient_id_source
	and EXISTS (
		SELECT pm.patient_num 
		FROM patient_mapping pm
		WHERE pm.patient_ide = '|| upload_temptable_name||'.patient_id
                and pm.patient_ide_source = '||upload_temptable_name||'.patient_id_source)';		     

IF (appendFlag = 0) THEN
--Archive records which are to be deleted in observation_fact table
execute 'INSERT ALL INTO  archive_observation_fact 
		SELECT obsfact.*, ' || upload_id ||' archive_upload_id 
		FROM observation_fact obsfact
		WHERE obsfact.encounter_num IN 
			(SELECT temp_obsfact.encounter_num
			FROM  ' ||upload_temptable_name ||' temp_obsfact
                        group by temp_obsfact.encounter_num  
            )';


--Delete above archived row from observation_fact
execute 'DELETE  observation_fact 
		 WHERE EXISTS (
				SELECT archive.encounter_num
				FROM archive_observation_fact  archive
				where archive.archive_upload_id = '||upload_id ||'
                AND archive.encounter_num=observation_fact.encounter_num
				AND archive.concept_cd = observation_fact.concept_cd
				AND archive.start_date = observation_fact.start_date
         )';
END IF;

-- if the append is true, then do the update else do insert all
IF (appendFlag = 0) THEN

--Transfer all rows from temp_obsfact to observation_fact
execute 'INSERT ALL INTO observation_fact(encounter_num,concept_cd, patient_num,provider_id, start_date,modifier_cd,instance_num,valtype_cd,tval_char,nval_num,valueflag_cd,
quantity_num,confidence_num,observation_blob,units_cd,end_date,location_cd, update_date,download_date,import_date,sourcesystem_cd,
upload_id) 
SELECT encounter_num,concept_cd, patient_num,provider_id, start_date,modifier_cd,instance_num,valtype_cd,tval_char,nval_num,valueflag_cd,
quantity_num,confidence_num,observation_blob,units_cd,end_date,location_cd, update_date,download_date,current_timestamp import_date,sourcesystem_cd,
temp.upload_id 
FROM ' || upload_temptable_name ||' temp
where temp.patient_num is not null and  temp.encounter_num is not null';
ELSE				
	execute ' UPDATE observation_fact  set 
			valtype_cd = temp.valtype_cd,
            tval_char = temp.tval_char,
			nval_num = temp.nval_num ,
			valueflag_cd = temp.valueflag_cd,
			quantity_num = temp.quantity_num,
			confidence_num = temp.confidence_num ,
			observation_blob = temp.observation_blob,
			units_cd = temp.units_cd,
			end_date = temp.end_date,
			location_cd = temp.location_cd,
			update_date= temp.update_date,
			download_date = temp.download_date,
			import_date = now(),
			sourcesystem_cd = temp.sourcesystem_cd,
			UPLOAD_ID = ' || upload_id || '
			from observation_fact obsfact 
			inner join ' || upload_temptable_name || ' temp
			on  obsfact.encounter_num = temp.encounter_num 
			and obsfact.patient_num = temp.patient_num
			and obsfact.concept_cd = temp.concept_cd
			and obsfact.start_date = temp.start_date
			and obsfact.provider_id = temp.provider_id
			and obsfact.modifier_cd = temp.modifier_cd
			and obsfact.instance_num = temp.instance_num
			where coalesce(observation_fact.update_date,to_date(''1900-01-01'',''YYYY-MM-DD''))<= coalesce(temp.update_date,to_date(''1900-01-01'',''YYYY-MM-DD'')) ';
END IF;

EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- % ', SQLSTATE, SQLERRM;	
END;
$$;


ALTER FUNCTION i2b2demodata.update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

SET search_path = i2b2metadata, pg_catalog;

--
-- Name: tf_trg_i2b2_tag_id(); Type: FUNCTION; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE FUNCTION tf_trg_i2b2_tag_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin         if NEW.tag_id is null then          select nextval('i2b2metadata.seq_i2b2metadata') into NEW.tag_id ;       end if; RETURN NEW;   end;
$$;


ALTER FUNCTION i2b2metadata.tf_trg_i2b2_tag_id() OWNER TO i2b2metadata;

SET search_path = i2b2workdata, pg_catalog;

--
-- Name: nvl(anyelement, anyelement); Type: FUNCTION; Schema: i2b2workdata; Owner: postgres
--

CREATE FUNCTION nvl(anyelement, anyelement) RETURNS anyelement
    LANGUAGE plpgsql
    AS $_$
begin
    return coalesce($1,$2);
end;$_$;


ALTER FUNCTION i2b2workdata.nvl(anyelement, anyelement) OWNER TO postgres;

--
-- Name: nvl(bigint, integer); Type: FUNCTION; Schema: i2b2workdata; Owner: postgres
--

CREATE FUNCTION nvl(bigint, integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
begin
    return coalesce($1,$2);
end;$_$;


ALTER FUNCTION i2b2workdata.nvl(bigint, integer) OWNER TO postgres;

SET search_path = searchapp, pg_catalog;

--
-- Name: bio_clinical_trial_uid(text, text, text); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION bio_clinical_trial_uid(trial_number text, title text, condition text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN coalesce(TRIAL_NUMBER || '|', '') || coalesce(TITLE || '|', '') || coalesce(CONDITION, '');
END;
 
 
 
$$;


ALTER FUNCTION searchapp.bio_clinical_trial_uid(trial_number text, title text, condition text) OWNER TO searchapp;

--
-- Name: bio_compound_uid(text, text, text); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN coalesce(CAS_REGISTRY || '|', '') || coalesce(JNJ_NUMBER || '|', '') || coalesce(CNTO_NUMBER, '');
END;
 
 
 
 
 
$$;


ALTER FUNCTION searchapp.bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) OWNER TO searchapp;

--
-- Name: refresh_search_bio_mkr_correl_fast_mv(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION refresh_search_bio_mkr_correl_fast_mv() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN

  -- populate the fake "materialized view" (i.e. actually a table) by deleting everything from it and then re-populating
  -- eventually we need a smarter algorithm for doing this

    delete from searchapp.search_bio_mkr_correl_fast_mv;

    insert into searchapp.search_bio_mkr_correl_fast_mv
    (domain_object_id, asso_bio_marker_id, correl_type, value_metric,  mv_id)    
    select domain_object_id, asso_bio_marker_id, correl_type, value_metric,  mv_id
       from searchapp.search_bio_mkr_correl_fast_view;  

    return true;
END;
 
 
 
$$;


ALTER FUNCTION searchapp.refresh_search_bio_mkr_correl_fast_mv() OWNER TO searchapp;

--
-- Name: tf_trgi_search_a_u_sec_access_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_a_u_sec_access_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.SEARCH_AUTH_USER_SEC_ACCESS_ID is null then          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_AUTH_USER_SEC_ACCESS_ID ;       end if;    RETURN NEW; end;



$$;


ALTER FUNCTION searchapp.tf_trgi_search_a_u_sec_access_id() OWNER TO searchapp;

--
-- Name: tf_trgi_search_au_obj_access_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_au_obj_access_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if coalesce(NEW.AUTH_SEC_OBJ_ACCESS_ID::text, '') = '' then          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.AUTH_SEC_OBJ_ACCESS_ID ;       end if;    RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trgi_search_au_obj_access_id() OWNER TO searchapp;

--
-- Name: tf_trgi_search_au_prcpl_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_au_prcpl_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
 if(coalesce(NEW.ID::text, '') = '' or NEW.ID = -2000) then       
 select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.ID ;      
 end if;     RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trgi_search_au_prcpl_id() OWNER TO searchapp;

--
-- Name: tf_trgi_search_cust_fil_item_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_cust_fil_item_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin 
    if NEW.SEARCH_CUSTOM_FILTER_ITEM_ID is null then select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_CUSTOM_FILTER_ITEM_ID ; end if; RETURN NEW;
end;



$$;


ALTER FUNCTION searchapp.tf_trgi_search_cust_fil_item_id() OWNER TO searchapp;

--
-- Name: tf_trgi_search_custom_filter_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_custom_filter_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin 
    if NEW.SEARCH_CUSTOM_FILTER_ID is null then select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_CUSTOM_FILTER_ID ; end if; RETURN NEW;
end;



$$;


ALTER FUNCTION searchapp.tf_trgi_search_custom_filter_id() OWNER TO searchapp;

--
-- Name: tf_trgi_search_keyword_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_keyword_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.SEARCH_KEYWORD_ID is null then          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_KEYWORD_ID ;       end if;   RETURN NEW; end;




$$;


ALTER FUNCTION searchapp.tf_trgi_search_keyword_id() OWNER TO searchapp;

--
-- Name: tf_trgi_search_keyword_term_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_keyword_term_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.SEARCH_KEYWORD_TERM_ID is null then          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_KEYWORD_TERM_ID ;       end if;    RETURN NEW;
end;

$$;


ALTER FUNCTION searchapp.tf_trgi_search_keyword_term_id() OWNER TO searchapp;

--
-- Name: tf_trgi_search_sec_acc_level_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_sec_acc_level_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.SEARCH_SEC_ACCESS_LEVEL_ID is null then          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_SEC_ACCESS_LEVEL_ID ;       end if;   RETURN NEW; end;



$$;


ALTER FUNCTION searchapp.tf_trgi_search_sec_acc_level_id() OWNER TO searchapp;

--
-- Name: tf_trgi_search_sec_obj_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_sec_obj_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.SEARCH_SECURE_OBJECT_ID is null then          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_SECURE_OBJECT_ID ;       end if;  RETURN NEW;  end;



$$;


ALTER FUNCTION searchapp.tf_trgi_search_sec_obj_id() OWNER TO searchapp;

--
-- Name: tf_trgi_search_sec_obj_path_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trgi_search_sec_obj_path_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     if NEW.SEARCH_SECURE_OBJ_PATH_ID is null then          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_SECURE_OBJ_PATH_ID ;       end if;  RETURN NEW;  end;



$$;


ALTER FUNCTION searchapp.tf_trgi_search_sec_obj_path_id() OWNER TO searchapp;

SET search_path = tm_cz, pg_catalog;

--
-- Name: czx_array_sort(anyarray); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_array_sort(anyarray) RETURNS anyarray
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $_$   
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
SELECT ARRAY(   
    SELECT $1[s.i] AS "foo"   
    FROM   
        generate_series(array_lower($1,1), array_upper($1,1)) AS s(i)   
    ORDER BY foo   
);   
$_$;


ALTER FUNCTION tm_cz.czx_array_sort(anyarray) OWNER TO postgres;

--
-- Name: czx_end_audit(numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_end_audit(jobid numeric, jobstatus character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

declare
	endDate timestamp;
	rtnCd	numeric;

BEGIN
  
	select clock_timestamp() into endDate;
  
	begin
	update tm_cz.cz_job_master
		set 
			active='N',
			end_date = endDate,
			time_elapsed_secs = coalesce(((DATE_PART('day', endDate - START_DATE) * 24 + 
				   DATE_PART('hour', endDate - START_DATE)) * 60 +
				   DATE_PART('minute', endDate - START_DATE)) * 60 +
				   DATE_PART('second', endDate - START_DATE),0),
			job_status = jobStatus		
		where active='Y' 
		and job_id=jobID;
	end;
	
	return 1;
	
	exception 
	when OTHERS then
		--raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		select tm_cz.cz_write_error(jobId,0,SQLSTATE,SQLERRM,null) into rtnCd;
		return -16;
END;
$$;


ALTER FUNCTION tm_cz.czx_end_audit(jobid numeric, jobstatus character varying) OWNER TO postgres;

--
-- Name: czx_error_handler(numeric, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
	databaseName VARCHAR(100);
	--errorNumber		character varying;	--	PostgreSQL SQLSTATE is alphanumeric
	--errorNumber NUMBER(18,0);
	--errorMessage VARCHAR(1000);
	errorStack VARCHAR(4000);
	errorBackTrace VARCHAR(4000);
	stepNo numeric(18,0);
	
	rtnCd	integer;

BEGIN
	--Get DB Name
	select database_name INTO databaseName
	from tm_cz.cz_job_master 
	where job_id=jobID;

	--Get Latest Step
	select max(step_number) into stepNo from tm_cz.cz_job_audit where job_id = jobID;
  
	--Get all error info, passed in as parameters, only available from EXCEPTION block
	--errorNumber := SQLSTATE;
	--errorMessage := SQLERRM;
	
	--	No corresponding functionality in PostgreSQL
	--errorStack := dbms_utility.format_error_stack;
	--errorBackTrace := dbms_utility.format_error_backtrace;

	--Update the audit step for the error
	select tm_cz.czx_write_audit(jobID, databaseName,procedureName, 'Job Failed: See error log for details',1, stepNo, 'FAIL') into rtnCd;
  
	--write out the error info
	select tm_cz.czx_write_error(jobID, errorNumber, errorMessage, errorStack, errorBackTrace) into rtnCd;
	
	return 1;

END;

$$;


ALTER FUNCTION tm_cz.czx_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) OWNER TO postgres;

--
-- Name: czx_info_handler(numeric, numeric, numeric, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

declare

  databaseName VARCHAR(100);
  rtnCd			numeric;
BEGIN

	select 
    database_name INTO databasename
  from 
    tm_cz.cz_job_master 
	where 
    job_id=jobID;
    
  select tm_cz.czx_write_audit( jobID, databaseName, messageProcedure, 'Step contains more details', 0, stepNumber, 'Information' ) into rtnCd;

  select tm_cz.czx_write_info(jobID, messageID, messageLine, messageProcedure, infoMessage ) into rtnCd;
  return rtnCd;
  
END;
$$;


ALTER FUNCTION tm_cz.czx_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) OWNER TO postgres;

--
-- Name: czx_percentile_cont(real[], real); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_percentile_cont(myarray real[], percentile real) RETURNS real
    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$   
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/ 
DECLARE   
  ary_cnt INTEGER;   
  row_num real;   
  crn real;   
  frn real;   
  calc_result real;   
  new_array real[];   
BEGIN   
  ary_cnt = array_length(myarray,1);   
  row_num = 1 + ( percentile * ( ary_cnt - 1 ));   
  new_array = tm_cz.czx_array_sort(myarray);   
     
  crn = ceiling(row_num);   
  frn = floor(row_num);   
         
      if crn = frn and frn = row_num then   
    calc_result = new_array[row_num];   
  else   
    calc_result = (crn - row_num) * new_array[frn]   
            + (row_num - frn) * new_array[crn];   
  end if;   
     
  RETURN calc_result;   
END;   
$$;


ALTER FUNCTION tm_cz.czx_percentile_cont(myarray real[], percentile real) OWNER TO postgres;

--
-- Name: czx_start_audit(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_start_audit(jobname character varying, databasename character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare
	rtnCd	integer;
	jobId	numeric;
BEGIN
	begin
		insert into tm_cz.cz_job_master
			(start_date, 
			active, 
			database_name,
			job_name,
			job_status) 
		VALUES(
			CLOCK_TIMESTAMP(),
			'Y', 
			databaseName,
			jobName,
			'Running')
	  RETURNING job_id INTO jobID;
	end;
  
  return jobID;
  
  exception 
	when OTHERS then
		select tm_cz.czx_write_error(jobId,0,SQLERRML,SQLSTATE,SQLERRM,null) into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_cz.czx_start_audit(jobname character varying, databasename character varying) OWNER TO postgres;

--
-- Name: czx_table_index_maint(character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_table_index_maint(p_run_type character varying, p_schema character varying, p_table character varying DEFAULT 'ALL'::character varying, currentjobid numeric DEFAULT NULL::numeric) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, deapp, i2b2demodata, pg_temp
    AS $$
/*
 *   Copyright 2012-2013 The Regents of the University of Colorado
 *
 *   Licensed under the Apache License, Version 2.0 (the "License")
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	
	v_ct		int;
	v_index		record;
	v_sql		varchar(4000);
  
begin

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := 'tm_cz';
	procedureName := 'czx_table_index_maint';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done') into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,' run_type: ' || p_run_type || ' schema: ' || p_schema ||  ' table: ' || p_table,0,stepCt,'Done') into rtnCd;


	if p_run_type not in ('DROP','ADD','SAVE') then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Invalid run_type',0,stepCt,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return 16;
	end if;
	
	if p_schema is null or p_schema = '' then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Schema name missing',0,stepCt,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return 16;
	end if;
	
	select count(*) into v_ct
	from tm_cz.table_index
	where schema_name = p_schema
	  and case when p_run_type = 'ALL' then 1
	           else case when table_name = p_table then 1
			             else 0
						 end
			   end = 1;
	
	if v_ct = 0 then
		if p_run_type != 'SAVE' then
			if p_table = 'ALL' then
				stepCt := stepCt + 1;
				select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No saved indexes foound for schema',0,stepCt,'Done') into rtnCd;
			else
				stepCt := stepCt + 1;
				select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No saved indexes found for table',0,stepCt,'Done') into rtnCd;
			end if;
			select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return 16;
		end if;
	end if;
	
	--	SAVE indexes
	
	if p_run_type = 'SAVE' then
	
		--	check that indexes exist for supplied schema name
		
		select count(*) into v_ct
		from pg_class a
		inner join pg_index b
			  on  a.oid = b.indexrelid 
		inner join pg_class c
			  on  b.indrelid = c.oid
		inner join pg_attribute d
			  on  c.oid = d.attrelid 
			  and d.attnum = any(b.indkey)
		inner join pg_namespace n
			  on n.oid = a.relnamespace
		where a.relname not like 'pg_%'
		  and n.nspname = p_schema
		  and case when p_table = 'ALL' then 1
				   else case when p_table = c.relname then 1
							 else 0 end
					end = 1;
	
	if v_ct = 0 then
		if p_table = 'ALL' then
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No indexes foound for schema',0,stepCt,'Done') into rtnCd;
		else
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No indexes found for table',0,stepCt,'Done') into rtnCd;
		end if;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return 16;
	end if;
	
		--	delete existing indexes for schema tables from cz.table_maint
		
		begin
		delete from tm_cz.table_index
		where schema_name = p_schema
		  and case when p_table = 'ALL' then 1
				   else case when p_table = table_name then 1
							 else 0 end
				   end = 1;
		get diagnostics rowCt := ROW_COUNT;
		exception 
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return 16;
		end;
		stepCt := stepCt + 1; 
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Deleted existing indexes for ' ||
				case when p_table = 'ALL' then p_schema else p_table end,rowCt,stepCt,'Done') into rtnCd;
		
		--	insert indexes for schema tables into cz.table_index
		
		begin
		insert into tm_cz.table_index
		(schema_name
		,table_name
		,index_name
		,index_sql
		)
		select distinct n.nspname as schema_name
			  ,c.relname as table_name
			  ,a.relname as index_name
			  ,pg_get_indexdef(b.indexrelid) as index_sql
		from pg_class a
		inner join pg_index b
			  on  a.oid = b.indexrelid 
		inner join pg_class c
			  on  b.indrelid = c.oid
		inner join pg_attribute d
			  on  c.oid = d.attrelid 
			  and d.attnum = any(b.indkey)
		inner join pg_namespace n
			  on n.oid = a.relnamespace
		where a.relname not like 'pg_%'
		  and n.nspname = p_schema
		  and case when p_table = 'ALL' then 1
				   else case when p_table = c.relname then 1
							 else 0 end
				   end = 1
		order by schema_name, table_name, index_name;
		get diagnostics rowCt := ROW_COUNT;
		exception 
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return 16;
		end;
		stepCt := stepCt + 1; 
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted indexes for ' ||
				case when p_table = 'ALL' then p_schema else p_table end,rowCt,stepCt,'Done') into rtnCd;
	else 
		--	drop indexes for DROP or ADD
		
		for v_index in (select * from tm_cz.table_index 
						where schema_name = p_schema 
						  and case when p_table = 'ALL' then 1
								   else case when p_table = table_name then 1
											 else 0
											 end
								   end = 1)
		loop
			v_sql = 'drop index if exists ' || v_index.schema_name || '.' || v_index.index_name || ' cascade';
			begin
			execute v_sql;
			get diagnostics rowCt := ROW_COUNT;
			exception 
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return 16;
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Dropped index ' || v_index.index_name || ' for ' ||
				case when p_table = 'ALL' then p_schema else p_table end,rowCt,stepCt,'Done') into rtnCd;
			
			if p_run_type = 'ADD' then
				--	add indexes for schema
				v_sql = v_index.index_sql;
				begin
				execute v_sql;
				get diagnostics rowCt := ROW_COUNT;
				exception 
				when others then
					stepCt := stepCt + 1;
					select tm_cz.czx_write_audit(jobId,databaseName,procedureName,v_index.index_sql || ': ' || sqlerrm,0,stepCt,'Done') into rtnCd;
					errorNumber := SQLSTATE;
					errorMessage := SQLERRM;
					--Handle errors.
					select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
					--End Proc
					select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
					return 16;
				end;
				stepCt := stepCt + 1;
				select tm_cz.czx_write_audit(jobId,databaseName,procedureName, 'Added index ' || v_index.index_name || ' on ' || p_schema || '.' || v_index.table_name,0,stepCt,'Done') into rtnCd;
			end if;
		end loop;
	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	

end
$$;


ALTER FUNCTION tm_cz.czx_table_index_maint(p_run_type character varying, p_schema character varying, p_table character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: czx_write_audit(numeric, character varying, character varying, character varying, numeric, numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
DECLARE
	lastTime timestamp;
	currTime timestamp;
	elapsedSecs	numeric;
	rtnCd		numeric;
	
BEGIN

	select max(job_date)
    into lastTime
    from tm_cz.cz_job_audit
    where job_id = jobID;
	
	--	clock_timestamp() is the current system time
	
	select clock_timestamp() into currTime;

	elapsedSecs :=	coalesce(((DATE_PART('day', currTime - lastTime) * 24 + 
				   DATE_PART('hour', currTime - lastTime)) * 60 +
				   DATE_PART('minute', currTime - lastTime)) * 60 +
				   DATE_PART('second', currTime - lastTime),0);

	begin
	insert into tm_cz.cz_job_audit
	(job_id
	,database_name
 	,procedure_name
 	,step_desc
	,records_manipulated
	,step_number
	,step_status
    ,job_date
    ,time_elapsed_secs
	)
	values(
 		jobId,
		databaseName,
		procedureName,
		stepDesc,
		recordsManipulated,
		stepNumber,
		stepStatus,
		currTime,
		elapsedSecs);
	exception 
	when OTHERS then
		--raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		select tm_cz.czx_write_error(jobId,0,SQLERRML,SQLSTATE,SQLERRM,null) into rtnCd;
		return -16;
	end;
	
	return 1;
END;
$$;


ALTER FUNCTION tm_cz.czx_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) OWNER TO postgres;

--
-- Name: czx_write_error(numeric, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

BEGIN

	begin
	insert into tm_cz.cz_job_error(
		job_id,
		error_number,
		error_message,
		error_stack,
		error_backtrace,
		seq_id)
	select
		jobID,
		errorNumber,
		errorMessage,
		errorStack,
		errorBackTrace,
		max(seq_id) 
  from tm_cz.cz_job_audit 
  where job_id=jobID;
  
  end;
  
  return 1;
 
  exception 
	when OTHERS then
		raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		return -16; 

END;
$$;


ALTER FUNCTION tm_cz.czx_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) OWNER TO postgres;

--
-- Name: czx_write_info(numeric, numeric, numeric, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION czx_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

declare

	rtnCd	numeric;
	
BEGIN

	begin
	insert into tm_cz.cz_job_message
    (
      job_id,
      message_id,
      message_line,
      message_procedure,
      info_message,
      seq_id
    )
	select
      jobID,
      messageID,
      messageLine,
      messageProcedure,
      infoMessage,
      max(seq_id)
  from
    tm_cz.cz_job_audit
  where
    job_id = jobID;
  	exception 
	when OTHERS then
		--raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		select tm_cz.cz_write_error(jobId,0,SQLERRML,SQLSTATE,SQLERRM,null) into rtnCd;
		return -16;
	end;
	
	return 1;

END;
$$;


ALTER FUNCTION tm_cz.czx_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) OWNER TO postgres;

--
-- Name: i2b2_add_node(character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_add_node(trialid character varying, path character varying, path_name character varying, currentjobid numeric) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

  root_node		varchar(2000);
  root_level	integer;
  rtnCd			integer;
  currTime		timestamp;
  
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
  
BEGIN
    
	stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'tm_cz';
	procedureName := 'i2b2_add_node';
	select clock_timestamp() into currTime;
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobId;
	END IF;
  
	select tm_cz.parse_nth_value(path, 2, '\') into root_node;
	
	select c_hlevel into root_level
	from i2b2metadata.table_access
	where c_name = root_node;
  
	if path = ''  or path = '%' or path_name = ''
	then 
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Path or Path name missing, no action taken',0,stepCt,'Done') into rtnCd;
		return 1;
	end if;
	
	--Delete existing data.
	begin
	DELETE FROM i2b2demodata.OBSERVATION_FACT 
	WHERE concept_cd IN (SELECT C_BASECODE FROM i2b2metadata.I2B2 WHERE C_FULLNAME = PATH);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--CONCEPT DIMENSION
	begin
	DELETE FROM i2b2demodata.CONCEPT_DIMENSION
	WHERE CONCEPT_PATH = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;
    
	--I2B2
	begin
	DELETE FROM i2b2metadata.i2b2
	WHERE C_FULLNAME = PATH;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Deleted path from I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	--	Insert new node
	
	--CONCEPT DIMENSION
	begin
	INSERT INTO i2b2demodata.CONCEPT_DIMENSION
	(CONCEPT_CD, CONCEPT_PATH, NAME_CHAR,  UPDATE_DATE,  DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD)
	VALUES
	(cast(nextval('i2b2demodata.concept_id') as varchar),
	path,
	path_name,
	currTime,
	currTime,
	currTime,
	TrialID
	);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted concept for path into I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCD;

	--I2B2
	begin
	INSERT INTO i2b2metadata.I2B2
	(c_hlevel, C_FULLNAME, C_NAME, C_VISUALATTRIBUTES, c_synonym_cd, C_FACTTABLECOLUMN, C_TABLENAME, C_COLUMNNAME,
	C_DIMCODE, C_TOOLTIP, UPDATE_DATE, DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, c_basecode, C_OPERATOR, c_columndatatype, c_comment,
	m_applied_path)
	SELECT 
	(length(concept_path) - coalesce(length(replace(concept_path, '\','')),0)) / length('\') - 2 + root_level,
	CONCEPT_PATH,
	NAME_CHAR,
	'FA',
	'N',
	'CONCEPT_CD',
	'CONCEPT_DIMENSION',
	'CONCEPT_PATH',
	CONCEPT_PATH,
	CONCEPT_PATH,
	currTime,
	currTime,
	currTime,
	SOURCESYSTEM_CD,
	CONCEPT_CD,
	'LIKE',
	'T',
	case when TrialID is null then null else 'trial:' || TrialID end,
	'@'
	FROM i2b2demodata.CONCEPT_DIMENSION
	WHERE 
	CONCEPT_PATH = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted path into I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
		
      ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCD;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_add_node(trialid character varying, path character varying, path_name character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_add_root_node(character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_add_root_node(root_node character varying, currentjobid numeric) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
DECLARE	
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);

	rootNode		varchar(200);
	rootPath		varchar(200);
	errorNumber		character varying;
	errorMessage	character varying;
	
	rtnCd			integer;
	
Begin
	rootNode := root_node;
	rootPath := '\' || rootNode || '\';

    stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'tm_cz';
	procedureName := 'i2b2_add_root_node';
	

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobId;
	END IF;
	
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done') into rtnCd;
	
	begin
	insert into i2b2metadata.table_access
	(c_table_cd
	,c_table_name
	,c_protected_access
	,c_hlevel
	,c_fullname
	,c_name
	,c_synonym_cd
	,c_visualattributes
	,c_totalnum
	,c_basecode
	,c_metadataxml
	,c_facttablecolumn
	,c_dimtablename
	,c_columnname
	,c_columndatatype
	,c_operator
	,c_dimcode
	,c_comment
	,c_tooltip
	,c_entry_date
	,c_change_date
	,c_status_cd
	,valuetype_cd
	)
	select rootNode as c_table_cd
		  ,'i2b2' as c_table_name
		  ,'N' as protected_access
		  ,0 as c_hlevel
		  ,rootPath as c_fullname
		  ,rootNode as c_name
		  ,'N' as c_synonym_cd
		  ,'CA' as c_visualattributes
		  ,null as c_totalnum
		  ,null as c_basecode
		  ,null as c_metadataxml
		  ,'concept_cd' as c_facttablecolumn
		  ,'concept_dimension' as c_dimtablename
		  ,'concept_path' as c_columnname
		  ,'T' as c_columndatatype
		  ,'LIKE' as c_operator
		  ,rootPath as c_dimcode
		  ,null as c_comment
		  ,rootPath as c_tooltip
		  ,current_timestamp as c_entry_date
		  ,null as c_change_date
		  ,null as c_status_cd
		  ,null as valuetype_cd
	where not exists
		(select 1 from i2b2metadata.table_access x
		 where x.c_table_cd = rootNode);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert to table_access',rowCt,stepCt,'Done') into rtnCd;	

	--	insert root_node into i2b2
	
	begin
	insert into i2b2metadata.i2b2
	(c_hlevel
	,c_fullname
	,c_name
	,c_synonym_cd
	,c_visualattributes
	,c_totalnum
	,c_basecode
	,c_metadataxml
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_columndatatype
	,c_operator
	,c_dimcode
	,c_comment
	,c_tooltip
	,m_applied_path
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,valuetype_cd
	,m_exclusion_cd
	,c_path
	,c_symbol
	--,i2b2_id
	)
	select 0 as c_hlevel
		  ,rootPath as c_fullname
		  ,rootNode as c_name
		  ,'N' as c_synonym_cd
		  ,'CA' as c_visualattributes
		  ,null as c_totalnum
		  ,null as c_basecode
		  ,null as c_metadataxml
		  ,'concept_cd' as c_facttablecolumn
		  ,'concept_dimension' as c_tablename
		  ,'concept_path' as c_columnname
		  ,'T' as c_columndatatype
		  ,'LIKE' as c_operator
		  ,rootPath as c_dimcode
		  ,null as c_comment
		  ,rootPath as c_tooltip
		  ,'@' as m_applied_path
		  ,current_timestamp as update_date
		  ,null as download_date
		  ,current_timestamp as import_date
		  ,null as sourcesystem_cd
		  ,null as valuetype_cd
		  ,null as m_exclusion_cd
		  ,null as c_path
		  ,null as c_symbol
		  --	add trigger on i2b2 insert
		  --,nextval('i2b2metadata.i2b2_id_seq')
		  --,I2B2_ID_SEQ.nextval as i2b2_id
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where x.c_name = rootNode);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;	  
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert root_node ' || rootNode || ' to i2b2',rowCt,stepCt,'Done') into rtnCd;
			
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done') into rtnCD;
	
	--Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	
END;

$$;


ALTER FUNCTION tm_cz.i2b2_add_root_node(root_node character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_create_concept_counts(character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_create_concept_counts(path character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
  
BEGIN
     
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'tm_cz';
	procedureName := 'i2b2_create_concept_counts';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;
    	
	stepCt := 0;
  
	begin
	delete from i2b2demodata.concept_counts
	where concept_path like path || '%' escape '`';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete counts for trial from I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;

	--	Join each node (folder or leaf) in the path to it's leaf in the work table to count patient numbers

	begin
	insert into i2b2demodata.concept_counts
	(concept_path
	,parent_concept_path
	,patient_count
	)
	select fa.c_fullname
		  ,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)))
		  ,count(distinct tpm.patient_num)
	from i2b2metadata.i2b2 fa
	    ,i2b2metadata.i2b2 la
		,i2b2demodata.observation_fact tpm
		,i2b2demodata.patient_dimension p
	where fa.c_fullname like path || '%' escape '`'
	  and substr(fa.c_visualattributes,2,1) != 'H'
	  and la.c_fullname like fa.c_fullname || '%' escape '`'
	  and la.c_visualattributes like 'L%'
	  and tpm.patient_num = p.patient_num
	  and la.c_basecode = tpm.concept_cd   
	group by fa.c_fullname
			,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)));
	get diagnostics rowCt := ROW_COUNT;		
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert counts for trial into I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;
	
	--SET ANY NODE WITH MISSING OR ZERO COUNTS TO HIDDEN

	begin
	update i2b2metadata.i2b2
	set c_visualattributes = substr(c_visualattributes,1,1) || 'H' || substr(c_visualattributes,3,1)
	where c_fullname like path || '%' escape '`'
	  and (not exists
			 (select 1 from i2b2demodata.concept_counts nc
				  where c_fullname = nc.concept_path)
				 or
			 exists
				 (select 1 from i2b2demodata.concept_counts zc
				  where c_fullname = zc.concept_path
					and zc.patient_count = 0)
			  )
		and c_name != 'SECURITY';
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Nodes hidden with missing/zero counts for trial into I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;
		
	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_create_concept_counts(path character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_create_security_for_trial(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_create_security_for_trial(trial_id character varying, secured_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, searchapp, biomart, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;

	TrialID varchar(100);
	securedStudy varchar(5);
	pExists			integer;
	v_bio_experiment_id	numeric(18,0);
	v_sso_id			numeric(18,0);
	
	currTime		timestamp;

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
	select clock_timestamp() into currTime;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'tm_cz';
	procedureName := 'i2b2_create_security_for_trial';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobId;
	END IF;

	stepCt := 0;
  
	begin
	delete from i2b2demodata.observation_fact
	where sourcesystem_cd = TrialID
	  and concept_cd = 'SECURITY';
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,case when securedStudy = 'N' then 'EXP:PUBLIC' else 'EXP:' || trialID end
		  ,'@'
		  ,'@'
		  ,currTime
		  ,currTime
		  ,currTime
		  --,sourcesystem_cd
		  ,TrialId
		  ,1
	from i2b2demodata.patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert patients to patient_trial table
	
	begin
	delete from i2b2demodata.patient_trial
	where trial  = TrialID;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   case when securedStudy = 'N' then 'EXP:PUBLIC' else 'EXP:' || trialID end
	from i2b2demodata.patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',rowCt,stepCt,'Done') into rtnCd;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
				begin
				insert into biomart.bio_experiment
				(title, accession, etl_id)
				select 'Metadata not available'
					  ,TrialId
					  ,'METADATA:' || TrialId;
				get diagnostics rowCt := ROW_COUNT;	
				exception
				when others then
					errorNumber := SQLSTATE;
					errorMessage := SQLERRM;
					--Handle errors.
					select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
					--End Proc
					select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
					return -16;	
				end;
				stepCt := stepCt + 1;
				select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',rowCt,stepCt,'Done') into rtnCd;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			begin
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'EXPERIMENT' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			get diagnostics rowCt := ROW_COUNT;	
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',rowCt,stepCt,'Done') into rtnCd;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
		
			select search_secure_object_id into v_sso_id
			from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
		
			--	delete security for object
		
			begin
			delete from searchapp.search_auth_sec_object_access
			where secure_object_id = v_sso_id;
			get diagnostics rowCt := ROW_COUNT;	
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;	
			end;
			stepCt := stepCt + 1;
			select czx_write_audit(jobId,databaseName,procedureName,'Removed study secure object id from search_auth_sec_object_access',1,stepCt,'Done') into rtnCd;
		
			--	delete security links between users and study
		
			begin
			delete from searchapp.search_auth_user_sec_access
			where search_secure_object_id = v_sso_id;
			get diagnostics rowCt := ROW_COUNT;	
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;	
			end;
			stepCt := stepCt + 1;
			select czx_write_audit(jobId,databaseName,procedureName,'Removed study secure object id from search_auth_user_sec_access',1,stepCt,'Done') into rtnCd;
			
			--	delete from search_secure_object
			begin
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			get diagnostics rowCt := ROW_COUNT;	
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',rowCt,stepCt,'Done') into rtnCd;
		end if;		
	end if;
     
 
    ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_create_security_for_trial(trial_id character varying, secured_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_delete_1_node(character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_delete_1_node(path character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
	
BEGIN

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Start i2b2_delete_1_node: ' || path,0,stepCt,'Done') into rtnCd;
	
	if coalesce(path,'') = ''  or path = '%' 
	then 
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Path missing, no action taken',0,stepCt,'Done') into rtnCd;
		return 1;
	end if;
	
    --I2B2
	begin
    delete from i2b2demodata.observation_fact 
    where concept_cd in (select c_basecode from i2b2metadata.i2b2 where c_fullname = path);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

      --CONCEPT DIMENSION
	begin
    delete from i2b2demodata.concept_dimension
    WHERE CONCEPT_PATH = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data from concept_dimension',rowCt,stepCt,'Done') into rtnCd;
    
    --I2B2
	begin
    delete from i2b2metadata.i2b2
    where c_fullname = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data from i2b2',rowCt,stepCt,'Done') into rtnCd;
	
	--i2b2_secure
	begin
    delete from i2b2metadata.i2b2_secure
    where c_fullname = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data from i2b2_secure',rowCt,stepCt,'Done') into rtnCd;

	--concept_counts
	begin
    delete from i2b2demodata.concept_counts
    where concept_path = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data from concept_counts',rowCt,stepCt,'Done') into rtnCd;
		
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End i2b2_delete_1_node',rowCt,stepCt,'Done') into rtnCd;
	
	return 1;
  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_delete_1_node(path character varying) OWNER TO postgres;

--
-- Name: i2b2_delete_all_nodes(character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_delete_all_nodes(path character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;

Begin

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	
	databaseName := 'tm_cz';
	procedureName := 'i2b2_delete_all_nodes';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;
 
	if coalesce(path,'') = ''  or path = '%'
		then 
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Path missing or invalid',0,stepCt,'Done') into rtnCd; 
	else 
		-- observation_fact
		begin
		DELETE FROM i2b2demodata.OBSERVATION_FACT 
		WHERE 
		concept_cd IN (SELECT C_BASECODE FROM i2b2metadata.I2B2 WHERE C_FULLNAME LIKE PATH || '%' escape '`');
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

		--CONCEPT DIMENSION
		begin
		DELETE FROM i2b2demodata.CONCEPT_DIMENSION
		WHERE CONCEPT_PATH LIKE path || '%' escape '`';
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;
    
		--I2B2
		begin
		DELETE FROM i2b2metadata.i2b2
		WHERE C_FULLNAME LIKE PATH || '%' escape '`';
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
  
		--i2b2_secure
		begin
		DELETE FROM i2b2metadata.i2b2_secure
		WHERE C_FULLNAME LIKE PATH || '%' escape '`';
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',rowCt,stepCt,'Done') into rtnCd;

		--concept_counts
		begin
		DELETE FROM i2b2demodata.concept_counts
		WHERE concept_path LIKE PATH || '%' escape '`';
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;
   
	end if;
	
	return 1;
END;

$$;


ALTER FUNCTION tm_cz.i2b2_delete_all_nodes(path character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_fill_in_tree(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_fill_in_tree(trial_id character varying, input_path character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
	
    TrialID varchar(100);
	auditText varchar(4000);
	root_node varchar(1000);
	node_name varchar(1000);
	curr_node	varchar(1000);
	etlDate		timestamp without time zone;
	root_level	numeric(18,0);
	v_count numeric;
  
  --Get the nodes
  cNodes CURSOR for
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,tm_cz.instr(c_fullname,'\',-2,1)) as c_fullname
    from i2b2metadata.i2b2 
    where c_fullname like input_path || '%' escape '`'
	union
	--	add input_path if filling in upper-level nodes only
	select input_path as c_fullname;

  
BEGIN
	TrialID := upper(trial_id);
  
    stepCt := 0;
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := 'tm_cz';
  procedureName := 'i2b2_fill_in_tree';
  select clock_timestamp() into etlDate;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
  END IF;
  
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done') into rtnCd;
  
  --	setup root node
  
  select tm_cz.parse_nth_value(input_path, 2, '\') into curr_node;

  select c_hlevel into root_level
  from i2b2metadata.table_access
  where c_name = curr_node;
  
  truncate table tm_wz.wt_folder_nodes;
  
  --start node with the first slash
 
  --Iterate through each node
	FOR r_cNodes in cNodes Loop
		root_node := '\';
		--Determine how many nodes there are
		--Iterate through, Start with 2 as one will be null from the parser
    
		for loop_counter in 1 .. (length(r_cNodes.c_fullname) - coalesce(length(replace(r_cNodes.c_fullname, '\','')),0)) / length('\')
		LOOP
			--Determine Node
			
			curr_node := substr(r_cNodes.c_fullname,1,tm_cz.instr(r_cNodes.c_fullname,'\',-1,loop_counter));	
			if curr_node is not null and curr_node != '\' then
				begin
				insert into tm_wz.wt_folder_nodes
				(folder_path)
				values(curr_node);
				end;
			end if;
		end loop;
	end loop;
	
	select count(*) into rowCt
	from tm_wz.wt_folder_nodes;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Nbr of nodes to be3 added',rowCt,stepCt,'Done') into rtnCd;

	--	bulk insert concept_dimension records

	begin
	insert into i2b2demodata.concept_dimension
	(concept_cd
	,concept_path
	,name_char
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd)
	Select nextval('i2b2demodata.concept_id')::text
		  ,y.folder_path
		  ,tm_cz.parse_nth_value(y.folder_path,length(y.folder_path)-length(replace(y.folder_path,'\','')),'\')
		  ,etlDate
		  ,etlDate
		  ,etlDate
		  ,case when y.folder_path < input_path then null else TrialId end
		 -- ,case when tm_cz.parse_nth_value(y.folder_path,length(y.folder_path)-length(replace(y.folder_path,'\','')),'\') < input_path then null else TrialID end
	from (select distinct folder_path from tm_wz.wt_folder_nodes x
		  where not exists
			   (select 1 from i2b2demodata.concept_dimension cd where x.folder_path = cd.concept_path)) y;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted concept for path into I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	bulk insert the i2b2 records
	
	insert into i2b2metadata.i2b2
	(c_hlevel
	,c_fullname
	,c_name
	,c_visualattributes
	,c_synonym_cd
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_dimcode
	,c_tooltip
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,c_basecode
	,c_operator
	,c_columndatatype
	,c_comment
	--,i2b2_id
	,m_applied_path)
    select (length(cd.concept_path) - coalesce(length(replace(cd.concept_path, '\','')),0)) / length('\') - 2 + root_level
		  ,cd.concept_path
		  ,cd.name_char
		  ,'FA'
		  ,'N'
		  ,'CONCEPT_CD'
		  ,'CONCEPT_DIMENSION'
		  ,'CONCEPT_PATH'
		  ,cd.concept_path
		  ,cd.concept_path
		  ,etlDate
		  ,etlDate
		  ,etlDate
		  ,cd.sourcesystem_cd
		  ,cd.concept_cd
		  ,'LIKE'
		  ,'T'
		  ,case when cd.sourcesystem_cd is null then null else 'trial:' || TrialID end 
		--  ,case when TrialID is null then null else 'trial:' || TrialID end 
		--  ,nextval('i2b2metadata.i2b2_id_seq')
		  ,'@'
    from i2b2demodata.concept_dimension cd
    where cd.concept_path in (select distinct folder_path from tm_wz.wt_folder_nodes)
	  and not exists
		  (select 1 from i2b2metadata.i2b2 x
		   where cd.concept_path = x.c_fullname);
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted path into I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End '|| procedureName,0,stepCt,'Done') into rtnCd;
	
      ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1 THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCD;
	END IF;
  
	return 1;

	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_fill_in_tree(trial_id character varying, input_path character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_hide_node(character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_hide_node(path character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
	
begin

    stepCt := 0;
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'tm_cz';
	procedureName := 'i2b2_hide_node';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
	
	if path = ''  or path = '%' or path_name = ''
	then 
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Path or Path name missing, no action taken',0,stepCt,'Done') into rtnCd;
		return 1;
	end if;

	begin
	update i2b2metadata.i2b2 b
	set c_visualattributes=substr(b.c_visualattributes,1,1) || 'H' || substr(b.c_visualattributes,3,1)
	where c_fullname like path || '%' escape '`';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Nodes hidden in i2b2metadata.i2b2',rowCt,stepCt,'Done') into rtnCd;

	
	begin
	delete from i2b2demodata.concept_counts
	where concept_path like path || '%' escape '`';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Deleted hidden nodes from i2b2demodata.concept_counts',rowCt,stepCt,'Done') into rtnCd;

	--	reload i2b2_secure for hidden nodes
	
	select tm_cz.load_security_data(jobId) into rtnCd;
	
	return 1;
  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_hide_node(path character varying) OWNER TO postgres;

--
-- Name: i2b2_load_annotation_deapp(numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_load_annotation_deapp(currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, deapp, biomart, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	
	gplId			character varying;

BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_ANNOTATION_DEAPP';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_annotation_deapp',0,stepCt,'Done') into rtnCd;

	--	get GPL id from lt_src_deapp_annot
	
	select distinct gpl_id into gplId from tm_lz.lt_src_deapp_annot;

	--	delete any existing data from deapp.de_mrna_annotation
	
	begin
	delete from deapp.de_mrna_annotation
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;

	--	update organism for existing probesets in probeset_deapp
	
	begin
	with upd as (select distinct t.gpl_id, t.probe_id, t.organism from tm_lz.lt_src_deapp_annot t)
	update tm_cz.probeset_deapp
	set organism=upd.organism
	from upd
	where platform = upd.gpl_id
	  and probeset = upd.probe_id
	and exists
		 (select 1 from tm_lz.lt_src_deapp_annot x
		  where platform = x.gpl_id
		    and probeset = x.probe_id);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Update organism in probeset_deapp',rowCt,stepCt,'Done') into rtnCd;
			
	--	insert any new probesets into probeset_deapp
	
	begin
	insert into tm_cz.probeset_deapp
	(probeset
	,organism
	,platform)
	select distinct probe_id
		  ,coalesce(organism,'Homo sapiens')
	      ,gpl_id
	from tm_lz.lt_src_deapp_annot t
	where not exists
		 (select 1 from tm_cz.probeset_deapp x
		  where t.gpl_id = x.platform
		    and t.probe_id = x.probeset
			and coalesce(t.organism,'Homo sapiens') = coalesce(x.organism,'Homo sapiens'));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert new probesets into probeset_deapp',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert data into deapp.de_mrna_annotation
	
	begin
	insert into deapp.de_mrna_annotation
	(gpl_id
	,probe_id
	,gene_symbol
	,gene_id
	,probeset_id
	,organism)
	select distinct d.gpl_id
	,d.probe_id
	,d.gene_symbol
	,case when d.gene_id is null then null 
	      else case when tm_cz.is_numeric(d.gene_id) = 0 then d.gene_id::numeric 
		       else null end
	 end as gene_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
	from tm_lz.lt_src_deapp_annot d
	,tm_cz.probeset_deapp p
	where d.probe_id = p.probeset
	  and d.gpl_id = p.platform
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;
		
	--	update gene_id if null
	
	begin
	with upd as (select b.bio_marker_name as gene_symbol, b.organism, min(b.primary_external_id::numeric) as gene_id 
				 from biomart.bio_marker b
				 where upper(b.bio_marker_type) = 'GENE'
				 group by b.bio_marker_name, b.organism)
	update deapp.de_mrna_annotation a
	set gene_id=upd.gene_id
	from upd
	where a.gpl_id = gplId
	  and a.gene_id is null
	  and a.gene_symbol is not null
	  and a.gene_symbol = upd.gene_symbol
	  and upper(a.organism) = upper(upd.organism)
	  and exists
		 (select 1 from biomart.bio_marker x
		  where a.gene_symbol = x.bio_marker_name
			and upper(x.organism) = upper(a.organism)
			and upper(x.bio_marker_type) = 'GENE');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;		
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;
	
	--	update gene_symbol if null
	
	begin
	with upd as (select b.primary_external_id::numeric as gene_id, b.organism, min(b.bio_marker_name) as gene_symbol
				 from biomart.bio_marker b
				 where upper(b.bio_marker_type) = 'GENE'
				 group by b.primary_external_id, b.organism)
	update deapp.de_mrna_annotation a
	set gene_symbol=upd.gene_symbol
	from upd
	where a.gpl_id = gplId
	  and a.gene_symbol is null
	  and a.gene_id is not null
	  and a.gene_id = upd.gene_id
	  and a.organism = upd.organism
	  and exists
		 (select 1 from biomart.bio_marker x
		  where a.gene_id::varchar = x.primary_external_id
			and upper(x.organism) = upper(a.organism)
			and upper(x.bio_marker_type) = 'GENE');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;		
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert probesets into biomart.bio_assay_feature_group
	
	begin
	insert into biomart.bio_assay_feature_group
	(feature_group_name
	,feature_group_type)
	select distinct t.probeset, 'PROBESET'
	from tm_cz.probeset_deapp t
	where t.platform = gplId
	  and not exists
		 (select 1 from biomart.bio_assay_feature_group x
		  where t.probeset = x.feature_group_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert probesets into biomart.bio_assay_feature_group',rowCt,stepCt,'Done') into rtnCd;
		  
	--	insert probesets into biomart.bio_assay_data_annotation
	
	begin
	insert into biomart.bio_assay_data_annotation
	(bio_assay_feature_group_id
	,bio_marker_id)
	select distinct fg.bio_assay_feature_group_id
		  ,coalesce(bgs.bio_marker_id,bgi.bio_marker_id)
	from deapp.de_mrna_annotation t
	inner join biomart.bio_assay_feature_group fg
		  on  t.probe_id = fg.feature_group_name
	left outer join biomart.bio_marker bgs
		  on  t.gene_symbol = bgs.bio_marker_name
		  and upper(coalesce(t.organism,'Homo sapiens')) = upper(bgs.organism)
	left outer join biomart.bio_marker bgi
		  on  t.gene_id = bgi.primary_external_id
		  and upper(coalesce(t.organism,'Homo sapiens')) = upper(bgi.organism)
	where t.gpl_id = gplId
	  and (t.gene_symbol is not null or t.gene_id is not null)
	  and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) > 0
	  and not exists
		 (select 1 from biomart.bio_assay_data_annotation x
		  where fg.bio_assay_feature_group_id = x.bio_assay_feature_group_id
		    and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) = x.bio_marker_id);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert probesets/genes into biomart.bio_assay_data_annotation',rowCt,stepCt,'Done') into rtnCd;

	
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End i2b2_load_annotation_deapp',0,stepCt,'Done') into rtnCd;
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_annotation_deapp(currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_load_clinical_data(character varying, character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_load_clinical_data(trial_id character varying, top_node character varying, secure_study character varying DEFAULT 'N'::character varying, highlight_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	
	topNode			varchar(2000);
	topLevel		numeric(10,0);
	root_node		varchar(2000);
	root_level		integer;
	study_name		varchar(2000);
	TrialID			varchar(100);
	secureStudy		varchar(200);
	etlDate			timestamp;
	tPath			varchar(2000);
	pCount			integer;
	pExists			integer;
	rtnCode			integer;
	tText			varchar(2000);
	v_bio_experiment_id	numeric(18,0);
	levelName		varchar(200);
	dCount			integer;
	vCount			integer;
	tmp_vocab		varchar(500);
	tmp_components	varchar(1000);
	tmp_leaf		varchar(1000);
	tmp_label_vocab	varchar(500);
	tmp_label		varchar(500);
	tmp_vocab_codes	varchar(1000);	
  
	addNodes CURSOR is
	select DISTINCT leaf_node, node_name
	from  tm_wz.wt_trial_nodes a;
   
	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	delNodes CURSOR is
	select distinct c_fullname 
	from  i2b2metadata.i2b2
	where c_fullname like topNode || '%' escape '`'
      and substr(c_visualattributes,2,1) = 'H';
	  
	--	cursor to determine if any leaf nodes exist in i2b2 that are not used in this reload (node changes from text to numeric or numeric to text)
	  
	delUnusedLeaf cursor is
	select l.c_fullname
	from i2b2metadata.i2b2 l
	where l.c_visualattributes like 'L%'
	  and l.c_fullname like topNode || '%' escape '`'
	  and l.c_fullname not in
		 (select t.leaf_node 
		  from tm_wz.wt_trial_nodes t
		  union
		  select m.c_fullname
		  from deapp.de_subject_sample_mapping sm
			  ,i2b2metadata.i2b2 m
		  where sm.trial_name = TrialId
		    and sm.concept_code = m.c_basecode
			and m.c_visualattributes like 'L%');

BEGIN
  
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	select clock_timestamp() into etlDate;

	databaseName := 'tm_cz';
	procedureName := 'i2b2_load_clinical_data';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	tText := 'Start i2b2_load_clinical_data for ' || TrialId;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\', 'g');
	
	--	figure out how many nodes (folders) are at study name and above
	--	\Public Studies\Clinical Studies\Pancreatic_Cancer_Smith_GSE22780\: topLevel = 4, so there are 3 nodes
	--	\Public Studies\GSE12345\: topLevel = 3, so there are 2 nodes
	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;
	
	if topLevel < 3 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Path specified in top_node must contain at least 2 nodes',0,stepCt,'Done') into rtnCd;	
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;	
		
	--	truncate tm_wz.wrk_clinical_data and load data from tm_lz.lt_src_clinical_data
	
	execute ('truncate table tm_wz.wrk_clinical_data');
	
	--	insert data from lt_src_clinical_data to tm_wz.wrk_clinical_data
	
	begin
	insert into tm_wz.wrk_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
	,data_value
	,category_cd
	,category_path
	,usubjid
	,units_cd
	,visit_date
	,end_date
	,obs_string
	,date_ind
	,data_type
	,valuetype_cd
	)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,replace(data_label, '|', ',')
		  ,replace(trim('|' from data_value),'|','-')
		  ,category_cd
		  ,replace(replace(category_cd,'_',' '),'+','\')
		  ,REGEXP_REPLACE(TrialID || ':' || coalesce(site_id,'') || ':' || subject_id,'(::){1,}', ':')
		  ,units_cd
		  ,visit_date
		  ,end_date
		  ,obs_string
		  ,date_ind
		  ,coalesce(date_ind,'T') as data_type
		  ,valuetype_cd
	from tm_lz.lt_src_clinical_data;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Load lt_src_clinical_data to work table',rowCt,stepCt,'Done') into rtnCd;

	-- Get study name from topNode
  
	select tm_cz.parse_nth_value(topNode, topLevel, '\') into study_name;	
	
	--	Replace all underscores with spaces in topNode except those in study name
	topNode := replace(replace(topNode,'\'||study_name||'\',''),'_',' ') || '\' || study_name || '\';

	-- Get root_node from topNode
  
	select tm_cz.parse_nth_value(topNode, 2, '\') into root_node;
	
	select count(*) into pExists
	from i2b2metadata.table_access
	where c_name = root_node;
	
	select count(*) into pCount
	from i2b2metadata.i2b2
	where c_name = root_node;
	
	if pExists = 0 or pCount = 0 then
		select tm_cz.i2b2_add_root_node(root_node, jobId) into rtnCd;
		if rtnCd > 0 then
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Unable to add root_node: '||root_node,0,stepCt,'Done') into rtnCd;	
			select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end if;
	end if;
	
	select c_hlevel into root_level
	from i2b2metadata.table_access
	where c_name = root_node;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Adding upper-level nodes',0,stepCt,'Done') into rtnCd;
		select tm_cz.i2b2_fill_in_tree(null, tPath, jobId) into rtnCd;
	end if;

	select count(*) into pExists
	from i2b2metadata.i2b2
	where c_fullname = topNode;
	
	--	add top node for study
	
	if pExists = 0 then
		select tm_cz.i2b2_add_node(TrialId, topNode, study_name, jobId) into rtnCd;
	end if;

	--Remove invalid Parens in the data
	--They have appeared as empty pairs or only single ones.
  
	begin
	update tm_wz.wrk_clinical_data
	set data_value = replace(data_value,'(', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%(%' and data_value NOT like '%)%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 1',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	update tm_wz.wrk_clinical_data
	set data_value = replace(data_value,')', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%)%' and data_value NOT like '%(%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 2',rowCt,stepCt,'Done') into rtnCd;

	--	set data_label to null when it duplicates the last part of the category_path
	--	Remove data_label from last part of category_path when they are the same

	begin
	update tm_wz.wrk_clinical_data tpm
	--set data_label = null
	set category_path=substr(tpm.category_path,1,tm_cz.instr(tpm.category_path,'\',-2,1)-1)
	   ,category_cd=substr(tpm.category_cd,1,tm_cz.instr(tpm.category_cd,'+',-2,1)-1)
	where (tpm.category_cd, tpm.data_label) in
		  (select distinct t.category_cd
				 ,t.data_label
		   from tm_wz.wrk_clinical_data t
		   where upper(substr(t.category_path,tm_cz.instr(t.category_path,'\',-1,1)+1,length(t.category_path)-tm_cz.instr(t.category_path,'\',-1,1))) 
			     = upper(t.data_label)
		     and t.data_label is not null)
	  and tpm.data_label is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Set data_label to null when found in category_path',rowCt,stepCt,'Done') into rtnCd;

	--	change any % to Pct and & and + to ' and ' and _ to space in data_label only
	
	begin
	update tm_wz.wrk_clinical_data
	set data_label=replace(replace(replace(replace(data_label,'%',' Pct'),'&',' and '),'+',' and '),'_',' ')
	   ,data_value=replace(replace(replace(data_value,'%',' Pct'),'&',' and '),'+',' and ')
	   ,category_cd=replace(replace(category_cd,'%',' Pct'),'&',' and ')
	   ,category_path=replace(replace(category_path,'%',' Pct'),'&',' and ');
	   exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

  --Trim trailing and leadling spaces as well as remove any double spaces, remove space from before comma, remove trailing comma

	begin
	update tm_wz.wrk_clinical_data
	set data_label  = trim(trailing ',' from trim(replace(replace(data_label,'  ', ' '),' ,',','))),
		data_value  = trim(trailing ',' from trim(replace(replace(data_value,'  ', ' '),' ,',','))),
		visit_name  = trim(trailing ',' from trim(replace(replace(visit_name,'  ', ' '),' ,',',')));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Remove leading, trailing, double spaces',rowCt,stepCt,'Done') into rtnCd;
	
	--	check if visit_date is date

	select count(*) into rowCt
	from tm_wz.wrk_clinical_data
	where visit_date is not null
	  and tm_cz.is_date(visit_date,'YYYY-MM-DD HH24:mi') = 1;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Check for invalid visit_date',rowCt,stepCt,'Done') into rtnCd;
		  
	if rowCt > 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Invalid visit_date in tm_lz.lt_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;	
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;	

	--	check if end_date is date

	select count(*) into rowCt
	from tm_wz.wrk_clinical_data
	where end_date is not null
	  and tm_cz.is_date(end_date,'YYYY-MM-DD HH24:mi') = 1;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Check for invalid visit_date',rowCt,stepCt,'Done') into rtnCd;
		  
	if rowCt > 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Invalid end_date in tm_lz.lt_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;	
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;	

/*	
	--	check if enroll_date is date
	
	select count(*) into pExists
	from tm_lz.lt_src_subj_enroll_date
	where enroll_date is not null
	  and is_date(enroll_date,'YYYY/MM/DD HH24:mi') = 1;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Check for invalid enroll_date',rowCt,stepCt,'Done');
		  
	if pExists > 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Invalid enroll_date in tm_lz.lt_src_subj_enroll_date',pExists,stepCt,'Done') into rtnCd;	
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;
*/
	
	--	determine numeric data types, force D (dates) to be non-numeric so mixed data types gets set correctly
	--	this deals with valid date of 20130101.1230 (D) and valid number of 2013 (T) not getting tagged as numeric

	truncate table tm_wz.wt_num_data_types;

	begin
	insert into tm_wz.wt_num_data_types
	(category_cd
	,data_label
	,visit_name
	)
    select category_cd,
           data_label,
           visit_name
    from tm_wz.wrk_clinical_data
    group by category_cd
	        ,data_label
            ,visit_name
      having sum(case when data_type = 'D' then 1 else tm_cz.is_numeric(data_value) end) = 0;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert numeric data into WZ wt_num_data_types',rowCt,stepCt,'Done') into rtnCd;

	--	set mixed dates to data_type = T
	begin
	update tm_wz.wrk_clinical_data t
	set data_type='T'
	where (coalesce(t.category_cd,'@'), coalesce(t.data_label,'@'), coalesce(t.visit_name,'@')) in
		  (select coalesce(category_cd,'@'), coalesce(data_label,'@'), coalesce(visit_name,'@')
		   from tm_wz.wrk_clinical_data
		   group by category_cd, data_label, visit_name
		   having count(distinct data_type) > 1);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select czx_write_audit(jobId,databaseName,procedureName,'Reset mixed date/text data_types to T',rowCt,stepCt,'Done') into rtnCd;

	--	only update T data_types, leave D as is
	
	begin
	update tm_wz.wrk_clinical_data t
	set data_type='N'
	where exists
	     (select 1 from tm_wz.wt_num_data_types x
	      where coalesce(t.category_cd,'@') = coalesce(x.category_cd,'@')
			and coalesce(t.data_label,'**NULL**') = coalesce(x.data_label,'**NULL**')
			and coalesce(t.visit_name,'**NULL**') = coalesce(x.visit_name,'**NULL**')
		  )
	  and t.data_type = 'T';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select czx_write_audit(jobId,databaseName,procedureName,'Updated data_type flag for numeric data_types',rowCt,stepCt,'Done') into rtnCd;

	--	Check if any duplicate records of key columns (site_id, subject_id, visit_name, data_label, category_cd) for numeric data
	--	exist.  Raise error if yes
	
	truncate table tm_wz.wt_clinical_data_dups;
	
	begin
	insert into tm_wz.wt_clinical_data_dups
	(site_id
	,subject_id
	,visit_name
	,data_label
	,category_cd)
	select w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
	from tm_wz.wrk_clinical_data w
	where exists
		 (select 1 from tm_wz.wt_num_data_types t
		 where coalesce(w.category_cd,'@') = coalesce(t.category_cd,'@')
		   and coalesce(w.data_label,'@') = coalesce(t.data_label,'@')
		   and coalesce(w.visit_name,'@') = coalesce(t.visit_name,'@')
		  )
	  and w.visit_date is null
	group by w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
	having count(*) > 1;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Check for duplicate key columns',rowCt,stepCt,'Done') into rtnCd;
			  
	if rowCt > 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Duplicate values found in key columns',rowCt,stepCt,'Done') into rtnCd;	
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;
	
	-- Build all needed leaf nodes in one pass for both numeric and text nodes
 
	execute ('truncate table tm_wz.wt_trial_nodes');
	
	begin
	insert into tm_wz.wt_trial_nodes
	(leaf_node
	,category_cd
	,visit_name
	,data_label
	,data_value
	,data_type
	,obs_string
	,valuetype_cd
	)
    select regexp_replace(
				case
    			--	Text data_type 
				when a.data_type = 'T'
				then case when a.category_path like '%DATALABEL%' or a.category_path like '%VISITNAME%' or a.category_path like '%OBSERVATION%'
						  then topNode || replace(replace(replace(a.category_path,'DATALABEL',coalesce(a.data_label,'')),'VISITNAME',coalesce(a.visit_name,'')),'OBSERVATION','') || '\' || a.data_value || '\'
						  else topNode || a.category_path || '\'  || coalesce(a.data_label,'') || '\' || a.data_value || '\' || coalesce(a.visit_name,'') || '\'
					 end
				--	else is numeric or date data_type and default_node
				else case when a.category_path like '%DATALABEL%' or a.category_path like '%VISITNAME%' or a.category_path like '%OBSERVATION%'
						  then topNode || replace(replace(replace(a.category_path,'DATALABEL',coalesce(a.data_label,'')),'VISITNAME',coalesce(a.visit_name,'')),'OBSERVATION',coalesce(a.obs_string,'')) || '\'
						  else topNode || a.category_path || '\'  || coalesce(a.data_label,'') || '\' || coalesce(a.visit_name,'') || '\'               
						end
				end ,'(\\){2,}', '\') as leaf_node,
    a.category_cd,
    a.visit_name,
	a.data_label,
	case when a.data_type = 'T' then a.data_value else null end as data_value
    ,a.data_type
	,a.obs_string
	,max(a.valuetype_cd)
	from  tm_wz.wrk_clinical_data a
	group by regexp_replace(
				case
    			--	Text data_type 
				when a.data_type = 'T'
				then case when a.category_path like '%DATALABEL%' or a.category_path like '%VISITNAME%' or a.category_path like '%OBSERVATION%'
						  then topNode || replace(replace(replace(a.category_path,'DATALABEL',coalesce(a.data_label,'')),'VISITNAME',coalesce(a.visit_name,'')),'OBSERVATION','') || '\' || a.data_value || '\'
						  else topNode || a.category_path || '\'  || coalesce(a.data_label,'') || '\' || a.data_value || '\' || coalesce(a.visit_name,'') || '\'
					 end
				--	else is numeric or date data_type and default_node
				else case when a.category_path like '%DATALABEL%' or a.category_path like '%VISITNAME%' or a.category_path like '%OBSERVATION%'
						  then topNode || replace(replace(replace(a.category_path,'DATALABEL',coalesce(a.data_label,'')),'VISITNAME',coalesce(a.visit_name,'')),'OBSERVATION',coalesce(a.obs_string,'')) || '\'
						  else topNode || a.category_path || '\'  || coalesce(a.data_label,'') || '\' || coalesce(a.visit_name,'') || '\'               
						end
				end ,'(\\){2,}', '\')
			,a.category_cd
			,a.visit_name
			,a.data_label
			,case when a.data_type = 'T' then a.data_value else null end 
			,a.data_type
			,a.obs_string;
	get diagnostics rowCt := ROW_COUNT; 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Create leaf nodes for trial',rowCt,stepCt,'Done') into rtnCd;

	--	set node_name
	
	begin
	update tm_wz.wt_trial_nodes
	set node_name=tm_cz.parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT; 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Updated node name for leaf nodes',rowCt,stepCt,'Done') into rtnCd;
	
	--	check if any node is a parent of another, all nodes must be children
	
	select count(*) into rowCt
	from tm_wz.wt_trial_nodes p
		,tm_wz.wt_trial_nodes c
	where c.leaf_node like p.leaf_node || '%'
	  and c.leaf_node != p.leaf_node;
	stepCt := stepCt + 1;
	select czx_write_audit(jobId,databaseName,procedureName,'Check if node is parent of another node',rowCt,stepCt,'Done') into rtnCd;

	if rowCt > 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Found leaf node that is parent of another node',rowCt,stepCt,'Done') into rtnCd;	
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;
		
	--	insert subjects into patient_dimension if needed
	
	execute ('truncate table tm_wz.wt_subject_info');

	begin
	insert into tm_wz.wt_subject_info
	(usubjid,
     age_in_years_num,
     sex_cd,
     race_cd
    )
	select a.usubjid,
	      coalesce(max(case when upper(a.data_label) = 'AGE'
					   then case when tm_cz.is_numeric(a.data_value) = 1 then 0 else a.data_value::integer end
		               when upper(a.data_label) like '%(AGE)' 
					   then case when tm_cz.is_numeric(a.data_value) = 1 then 0 else a.data_value::integer end
					   else null end),0) as age,
		  coalesce(max(case when upper(a.data_label) = 'SEX' then a.data_value
		           when upper(a.data_label) like '%(SEX)' then a.data_value
				   when upper(a.data_label) = 'GENDER' then a.data_value
				   else null end),'Unknown') as sex,
		  max(case when upper(a.data_label) = 'RACE' then a.data_value
		           when upper(a.data_label) like '%(RACE)' then a.data_value
				   else null end) as race
	from tm_wz.wrk_clinical_data a
	group by a.usubjid;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert subject information into temp table',rowCt,stepCt,'Done') into rtnCd;

	--	Delete dropped subjects from patient_dimension if they do not exist in de_subject_sample_mapping
	
	begin
	delete from i2b2demodata.patient_dimension
	where sourcesystem_cd in
		 (select distinct pd.sourcesystem_cd from i2b2demodata.patient_dimension pd
		  where pd.sourcesystem_cd like TrialId || ':%'
		  except 
		  select distinct cd.usubjid from tm_wz.wrk_clinical_data cd)
	  and patient_num not in
		  (select distinct sm.patient_id from deapp.de_subject_sample_mapping sm);
	get diagnostics rowCt := ROW_COUNT;		 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete dropped subjects from patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	update patients with changed information
	begin
	with nsi as (select t.usubjid, t.sex_cd, t.age_in_years_num, t.race_cd from tm_wz.wt_subject_info t) 
	update i2b2demodata.patient_dimension
	set sex_cd=nsi.sex_cd
	   ,age_in_years_num=nsi.age_in_years_num
	   ,race_cd=nsi.race_cd
	   from nsi
	where sourcesystem_cd = nsi.usubjid;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Update subjects with changed demographics in patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	insert new subjects into patient_dimension
	
	begin
	insert into i2b2demodata.patient_dimension
    (patient_num,
     sex_cd,
     age_in_years_num,
     race_cd,
     update_date,
     download_date,
     import_date,
     sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num'),
		   t.sex_cd,
		   t.age_in_years_num,
		   t.race_cd,
		   etlDate,
		   etlDate,
		   etlDate,
		   t.usubjid
    from tm_wz.wt_subject_info t
	where t.usubjid in 
		 (select distinct cd.usubjid from tm_wz.wt_subject_info cd
		  except
		  select distinct pd.sourcesystem_cd from i2b2demodata.patient_dimension pd
		  where pd.sourcesystem_cd like TrialId || ':%');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert new subjects into patient_dimension',rowCt,stepCt,'Done') into rtnCd;
		
	--	new bulk delete of unused nodes
	
	truncate table tm_wz.wt_del_nodes;
	stepCt := stepCt + 1;	
	select czx_write_audit(jobId,databaseName,procedureName,'Truncate table tm_wz.wt_del_nodes',0,stepCt,'Done') into rtnCd;
	
	begin
	insert into tm_wz.wt_del_nodes
	select l.c_fullname
		  ,l.c_basecode
	from i2b2 l
	where l.c_visualattributes like 'L%'
	  and l.c_fullname like topNode || '%'
	  and l.c_fullname not in
		 (select t.leaf_node 
		  from wt_trial_nodes t
		  union
		  select m.c_fullname
		  from de_subject_sample_mapping sm
			  ,i2b2 m
		  where sm.trial_name = TrialId
		    and sm.concept_code = m.c_basecode
			and m.c_visualattributes like 'L%');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;	
	select czx_write_audit(jobId,databaseName,procedureName,'Insert nodes into tm_wz.wt_del_nodes',rowCt,stepCt,'Done') into rtnCd;
	
	select count(*) into pExists
	from tm_wz.wt_del_nodes;
	
	if pExists > 0 then 
	
		--	delete i2b2 unused nodes
		begin
		delete from i2b2metadata.i2b2 f
		where f.c_fullname in (select distinct x.c_fullname from tm_wz.wt_del_nodes x);
		get diagnostics rowCt := ROW_COUNT;	
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;	
		select czx_write_audit(jobId,databaseName,procedureName,'Bulk delete nodes from i2b2',rowCt,stepCt,'Done') into rtnCd;
		
		--	delete concept_dimension unused nodes
		begin
		delete from i2b2demodata.concept_dimension f
		where f.concept_cd in (select distinct x.c_basecode as concept_cd from tm_wz.wt_del_nodes x);
				get diagnostics rowCt := ROW_COUNT;	
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;	
		select czx_write_audit(jobId,databaseName,procedureName,'Bulk delete nodes from concept_dimension',rowCt,stepCt,'Done') into rtnCd;
		commit;
		
		--	delete observation_fact unused nodes
		begin
		delete from i2b2demodata.observation_fact f
		where f.concept_cd in (select distinct x.c_basecode as concept_cd from tm_wz.wt_del_nodes x);
				get diagnostics rowCt := ROW_COUNT;	
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;	
		select czx_write_audit(jobId,databaseName,procedureName,'Bulk delete nodes from observation_fact',rowCt,stepCt,'Done') into rtnCd;
/*		
		--	delete de_concept_visit unused nodes
		
		delete from deapp.de_concept_visit f
		where f.concept_cd in (select distinct x.c_basecode as concept_cd from tm_wz.wt_del_nodes x);
		stepCt := stepCt + 1;	
		czx_write_audit(jobId,databaseName,procedureName,'Bulk delete nodes from de_concept_visit',rowCt,stepCt,'Done');
		commit;
*/		
	end if;	
	
	--	bulk insert leaf nodes
	begin
	with ncd as (select t.leaf_node, t.node_name from tm_wz.wt_trial_nodes t)
	update i2b2demodata.concept_dimension
	set name_char=ncd.node_name
	from ncd
	where concept_path = ncd.leaf_node;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Update name_char in concept_dimension for changed names',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into i2b2demodata.concept_dimension
    (concept_cd
	,concept_path
	,name_char
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	)
    select nextval('i2b2demodata.concept_id')::text
	     ,x.leaf_node
		 ,x.node_name
		 ,etlDate
		 ,etlDate
		 ,etlDate
		 ,TrialId
	from (select distinct c.leaf_node
				,c.node_name::text as node_name
		  from tm_wz.wt_trial_nodes c
		  where not exists
			(select 1 from i2b2demodata.concept_dimension x
			where c.leaf_node = x.concept_path)
		 ) x;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted new leaf nodes into I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;
	
	--	update i2b2 with name, data_type and xml for leaf nodes
	begin
	with ncd as (select t.leaf_node, t.node_name, t.data_type from tm_wz.wt_trial_nodes t)
	update i2b2metadata.i2b2
	set c_name=ncd.node_name
	   ,c_columndatatype='T'    -- force T until i2b2 respects c_columndatatype ncd.data_type
	   ,c_metadataxml=case when ncd.data_type = 'T'
					  then null
					  else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
					  end
	from ncd
	where c_fullname = ncd.leaf_node;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Updated name and data type in i2b2 if changed',rowCt,stepCt,'Done') into rtnCd;
			   
	begin
	insert into i2b2metadata.i2b2
    (c_hlevel
	,c_fullname
	,c_name
	,c_visualattributes
	,c_synonym_cd
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_dimcode
	,c_tooltip
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,c_basecode
	,c_operator
	,c_columndatatype
	,c_comment
	,m_applied_path
	,c_metadataxml
	)
    select (length(c.concept_path) - coalesce(length(replace(c.concept_path, '\','')),0)) / length('\') - 2 + root_level
		  ,c.concept_path
		  ,c.name_char
		  ,'LA'
		  ,'N'
		  ,'CONCEPT_CD'
		  ,'CONCEPT_DIMENSION'
		  ,'CONCEPT_PATH'
		  ,c.concept_path
		  ,c.concept_path
		  ,etlDate
		  ,etlDate
		  ,etlDate
		  ,c.sourcesystem_cd
		  ,c.concept_cd
		  ,'LIKE'
		  ,'T'     -- force to T until i2b2 respects c_columndatatype t.data_type 
		  ,'trial:' || TrialID 
		  ,'@'
		  ,case when t.data_type = 'T' then null
		   else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
		   end
    from i2b2demodata.concept_dimension c
		,tm_wz.wt_trial_nodes t
    where c.concept_path = t.leaf_node
	  and not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where c.concept_path = x.c_fullname);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted leaf nodes into I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	--	delete from observation_fact all concept_cds for trial that are clinical data, exclude concept_cds from biomarker data
	
	begin
	delete from i2b2demodata.observation_fact f
	where f.sourcesystem_cd = TrialId
	  and f.concept_cd not in
		 (select distinct concept_code as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and concept_code is not null
		  union
		  select distinct platform_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and platform_cd is not null
		  union
		  select distinct sample_type_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and sample_type_cd is not null
		  union
		  select distinct tissue_type_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and tissue_type_cd is not null
		  union
		  select distinct timepoint_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and timepoint_cd is not null
		  union
		  select distinct concept_cd as concept_cd from deapp.de_subject_snp_dataset
		  where trial_name = TrialId
		    and concept_cd is not null);
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete clinical data for study from observation_fact',rowCt,stepCt,'Done') into rtnCd;	  
	
    --Insert into observation_fact
	
	begin
	insert into i2b2demodata.observation_fact
	(patient_num
    ,concept_cd
    ,modifier_cd
    ,valtype_cd
    ,tval_char
    ,nval_num
    ,sourcesystem_cd
    ,import_date
    ,valueflag_cd
    ,provider_id
    ,location_cd
	,instance_num
	,start_date
	,end_date
	)
	select distinct c.patient_num,
		   i.c_basecode,
		   '@',
		   --coalesce(vv.modifier_cd,'@'),
		   a.data_type,
		   case when a.data_type = 'T' then a.data_value
				else 'E'  --Stands for Equals for numeric types
				end,
		   case when a.data_type = 'N' then a.data_value::numeric
				else null --Null for text types
				end,
		   a.study_id, 
		   etlDate, 
		   '@',
		   '@',
		   '@'
		   --a.units_cd
		  ,row_number() over (partition by i.c_basecode, c.patient_num order by a.visit_date) as instance_num
		  ,to_date(a.visit_date,'YYYY/MM/DD HH24:MI')
		  ,to_date(a.end_date,'YYYY/MM/DD HH24:MI')
	from tm_wz.wrk_clinical_data a
		 inner join i2b2demodata.patient_dimension c
             on  a.usubjid = c.sourcesystem_cd
		 inner join tm_wz.wt_trial_nodes t
             on  coalesce(a.category_cd,'@') = coalesce(t.category_cd,'@')
             and coalesce(a.data_label,'**NULL**') = coalesce(t.data_label,'**NULL**')
             and coalesce(a.visit_name,'**NULL**') = coalesce(t.visit_name,'**NULL**')
             and case when a.data_type = 'T' then a.data_value else '**NULL**' end = coalesce(t.data_value,'**NULL**')
		 inner join i2b2metadata.i2b2 i
             on t.leaf_node = i.c_fullname
	where a.data_value is not null
	  and not exists		-- don't insert if lower level node exists
		 (select 1 from tm_wz.wt_trial_nodes x
		  where x.leaf_node like t.leaf_node || '%_' escape '`');
	get diagnostics rowCt := ROW_COUNT; 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
		
	-- fill in folder nodes 
  
	select tm_cz.i2b2_fill_in_tree(TrialId, topNode, jobID) into rtnCd;

	--	update c_visualattributes for all nodes in study, done to pick up node that changed c_columndatatype
	
	begin
	with upd as (select p.c_fullname, count(*) as nbr_children 
				 from i2b2metadata.i2b2 p
					 ,i2b2metadata.i2b2 c
				 where p.c_fullname like topNode || '%' escape '`'
				   and c.c_fullname like p.c_fullname || '%' escape '`'
				 group by p.c_fullname)
	update i2b2metadata.i2b2 b
	set c_visualattributes=case when upd.nbr_children = 1 
								then 'L' || substr(b.c_visualattributes,2,2)
								else 'F' || substr(b.c_visualattributes,2,1) ||
									case when upd.c_fullname = topNode and highlight_study = 'Y'
										 then 'J' else substr(b.c_visualattributes,3,1) end
								end
		--,c_columndatatype=case when upd.nbr_children > 1 then 'T' else b.c_columndatatype end
	from upd
	where b.c_fullname = upd.c_fullname
	  and b.c_fullname in
		 (select x.c_fullname from i2b2 x
		  where x.c_fullname like topNode || '%' escape '`');
  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Set c_visualattributes in i2b2',rowCt,stepCt,'Done') into rtnCd;
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
		
	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	get diagnostics rowCt := ROW_COUNT;	  
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper-level nodes',rowCt,stepCt,'Done') into rtnCd;

	select tm_cz.i2b2_create_concept_counts(topNode, jobID) into rtnCd;
	
	--	new bulk delete of unused nodes
	
	truncate table tm_wz.wt_del_nodes;
	stepCt := stepCt + 1;	
	select czx_write_audit(jobId,databaseName,procedureName,'Truncate table tm_wz.wt_del_nodes for hidden nodes',0,stepCt,'Done') into rtnCd;
	
	begin
	insert into tm_wz.wt_del_nodes
	select l.c_fullname
		  ,l.c_basecode
	from i2b2metadata.i2b2 l
	where l.c_visualattributes like '%H%'
	  and l.c_fullname like topNode || '%';
	get diagnostics rowCt := ROW_COUNT;	  
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;	
	select czx_write_audit(jobId,databaseName,procedureName,'Insert hidden nodes into tm_wz.wt_del_nodes',rowCt,stepCt,'Done') into rtnCd;
	
	select count(*) into pExists
	from tm_wz.wt_del_nodes;
	
	if pExists > 0 then 
	
		--	delete i2b2 unused nodes
		begin
		delete from i2b2metadata.i2b2 f
		where f.c_fullname in (select distinct x.c_fullname from tm_wz.wt_del_nodes x);
		get diagnostics rowCt := ROW_COUNT;	  
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;	
		select czx_write_audit(jobId,databaseName,procedureName,'Bulk delete hidden nodes from i2b2',rowCt,stepCt,'Done') into rtnCd;
		commit;
		
		--	delete concept_dimension unused nodes
		begin
		delete from concept_dimension f
		where f.concept_cd in (select distinct x.c_basecode as concept_cd from tm_wz.wt_del_nodes x);
		get diagnostics rowCt := ROW_COUNT;	  
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;	
		select czx_write_audit(jobId,databaseName,procedureName,'Bulk delete hidden nodes from concept_dimension',rowCt,stepCt,'Done') into rtnCd;

	end if;  	

	select tm_cz.i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;
	select tm_cz.i2b2_load_security_data(jobID) into rtnCd;
	
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End i2b2_load_clinical_data',0,stepCt,'Done') into rtnCd;
	
	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
/*	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
*/
END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_load_security_data(numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_load_security_data(currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;

BEGIN

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'tm_cz';
	procedureName := 'i2b2_load_security';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobId;
	END IF;

	Execute  ('truncate table I2B2METADATA.i2b2_secure');

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Truncate I2B2METADATA i2b2_secure',0,stepCt,'Done') into rtnCd;

	insert into i2b2metadata.i2b2_secure
	(c_hlevel,
     c_fullname,
     c_name,
     c_synonym_cd,
     c_visualattributes,
     c_totalnum,
     c_basecode,
     c_metadataxml,
     c_facttablecolumn,
     c_tablename,
     c_columnname,
     c_columndatatype,
     c_operator,
     c_dimcode,
     c_comment,
     c_tooltip,
     update_date,
     download_date,
     import_date,
     sourcesystem_cd,
     valuetype_cd,
	 secure_obj_token)
  select
    b.c_hlevel,
    b.c_fullname,
    b.c_name,
    b.c_synonym_cd,
    b.c_visualattributes,
    b.c_totalnum,
    b.c_basecode,
    b.c_metadataxml,
    b.c_facttablecolumn,
    b.c_tablename,
    b.c_columnname,
    b.c_columndatatype,
    b.c_operator,
    b.c_dimcode,
    b.c_comment,
    b.c_tooltip,
    b.update_date,
    b.download_date,
    b.import_date,
    b.sourcesystem_cd,
    b.valuetype_cd,
	coalesce(f.tval_char,'EXP:PUBLIC')
    from i2b2metadata.i2b2 b
	left outer join (select distinct case when sourcesystem_cd like '%:%' 
										   then substr(sourcesystem_cd,1,instr(sourcesystem_cd,':')-1)
										   else sourcesystem_cd end as sourcesystem_cd
							,tval_char from i2b2demodata.observation_fact where concept_cd = 'SECURITY') f
		 on b.sourcesystem_cd = f.sourcesystem_cd;
	get diagnostics rowCt := ROW_COUNT;
    stepCt := stepCt + 1;
    select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert security data into I2B2METADATA i2b2_secure',rowCt,stepCt,'Done') into rtnCd;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_security_data(currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_load_study_metadata(numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_study_metadata(currentjobid numeric DEFAULT (-1)) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, deapp, biomart, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare
  
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	
	dcount 				int;
	lcount 				int;
	upload_date			timestamp;
	tmp_compound		varchar(200);
	tmp_disease			varchar(200);
	tmp_organism		varchar(200);
	tmp_pubmed			varchar(2000);
	pubmed_id			varchar(200);
	pubmed_title		varchar(2000);
	
	study_compound_rec	record;
	study_disease_rec	record;
	study_taxonomy_rec  record;
	study_pubmed_rec 	record;

BEGIN

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := 'tm_cz';
	procedureName := 'i2b2_load_study_metadata';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done') into rtnCd;

	select clock_timestamp() into upload_date;
 
	--	Update existing bio_experiment data
	
	begin
	with upd as (select m.study_id
				,m.title
				,m.description
				,m.design
				,case when tm_cz.is_date(m.start_date,'YYYYMMDD') = 1 then null
					  else to_date(m.start_date,'YYYYMMDD') end as start_date
				,case when tm_cz.is_date(m.completion_date,'YYYYMMDD') = 1 then null
					  else to_date(m.completion_date,'YYYYMMDD') end as completion_date
				,coalesce(m.primary_investigator,m.study_owner) as primary_investigator
				,m.overall_design
				,m.institution
				,m.country
				from tm_lz.lt_src_study_metadata m
				where m.study_id is not null)
	update biomart.bio_experiment b
	set title=upd.title
	    ,description=upd.description
		,design=upd.design
		,start_date=upd.start_date
		,completion_date=upd.completion_date
		,primary_investigator=upd.primary_investigator
		,overall_design=upd.overall_design
		,institution=upd.institution
		,country=upd.country 
	from upd
	where b.accession = upd.study_id
	  and b.etl_id = 'METADATA:' || upd.study_id;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Updated trial data in BIOMART bio_experiment',rowCt,stepCt,'Done') into rtnCd;

/*	
	--	Update existing bio_clinical_trial data only for true Clinical Trials or JnJ Experimental Medicine Studies

	update biomart.bio_clinical_trial b
	set (study_owner
	    ,study_phase
		,blinding_procedure
		,studytype
		,duration_of_study_weeks
		,number_of_patients
		,number_of_sites
		,route_of_administration
		,dosing_regimen
		,group_assignment
		,type_of_control
		,completion_date
		,primary_end_points
		,secondary_end_points
		,inclusion_criteria
		,exclusion_criteria
		,subjects
		,gender_restriction_mfb
		,min_age
		,max_age
		,secondary_ids
		,development_partner
		,main_findings
		,geo_platform
		--,platform_name
		,search_area
        ) =
		(select m.study_owner
			   ,m.study_phase
			   ,m.blinding_procedure
			   ,m.studytype
			   ,decode(is_number(m.duration_of_study_weeks),1,null,to_number(m.duration_of_study_weeks))
			   ,decode(is_number(m.number_of_patients),1,null,to_number(m.number_of_patients))
			   ,decode(is_number(m.number_of_sites),1,null,to_number(m.number_of_sites))
			   ,m.route_of_administration
			   ,m.dosing_regimen
			   ,m.group_assignment
			   ,m.type_of_control
			   ,decode(is_date(m.completion_date,'YYYYMMDD'),1,null,to_date(m.completion_date,'YYYYMMDD'))
			   ,m.primary_end_points
			   ,m.secondary_end_points
			   ,m.inclusion_criteria
			   ,m.exclusion_criteria
			   ,m.subjects
			   ,m.gender_restriction_mfb
			   ,decode(is_number(m.min_age),1,null,to_number(m.min_age))
			   ,decode(is_number(m.max_age),1,null,to_number(m.max_age))
			   ,m.secondary_ids
			   ,m.development_partner
			   ,m.main_findings
			   ,m.geo_platform
			   --,m.platform_name
			   ,m.search_area
		 from lt_src_study_metadata m
		 where m.study_id is not null
		   and b.trial_number = m.study_id
		)
	where exists
	     (select 1 from lt_src_study_metadata x
		  where b.trial_number = x.study_id
		    and x.study_id is not null
		 )
	;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated study data in BIOMART bio_clinical_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
*/
	
	--	Add new trial data to bio_experiment
	
	begin
	insert into biomart.bio_experiment
	(bio_experiment_type
	,title
	,description
	,design
	,start_date
	,completion_date
	,primary_investigator
	,contact_field
	,etl_id
	,status
	,overall_design
	,accession
	,country
	,institution)
	select 'Experiment'
	      ,m.title
		  ,m.description
		  ,m.design
		  ,case when tm_cz.is_date(m.start_date,'YYYYMMDD') = 1 then null
				else to_date(m.start_date,'YYYYMMDD') end as start_date
		  ,case when tm_cz.is_date(m.completion_date,'YYYYMMDD') = 1 then null
				else to_date(m.completion_date,'YYYYMMDD') end as completion_date
		  ,coalesce(m.primary_investigator,m.study_owner) as primary_investigator

		  ,m.contact_field
		  ,'METADATA:' || m.study_id
		  ,m.study_id
		  ,m.overall_design
		  ,m.study_id
		  ,m.country
		  ,m.institution
	from tm_lz.lt_src_study_metadata m
	where m.study_id is not null
	  and not exists
	      (select 1 from biomart.bio_experiment x
		   where m.study_id = x.accession
		     and m.study_id is not null);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study to BIOMART bio_experiment',rowCt,stepCt,'Done') into rtnCd;

/*		
	--	Add new trial data to bio_clinical_trial
	
	insert into biomart.bio_clinical_trial
	(trial_number
	,study_owner
	,study_phase
	,blinding_procedure
	,studytype
	,duration_of_study_weeks
	,number_of_patients
	,number_of_sites
	,route_of_administration
	,dosing_regimen
	,group_assignment
	,type_of_control
	,completion_date
	,primary_end_points
	,secondary_end_points
	,inclusion_criteria
	,exclusion_criteria
	,subjects
	,gender_restriction_mfb
	,min_age
	,max_age
	,secondary_ids
	,bio_experiment_id
	,development_partner
	,main_findings
	,geo_platform
	--,platform_name
	,search_area
	)
	select m.study_id
          ,m.study_owner
          ,m.study_phase
          ,m.blinding_procedure
          ,m.studytype
		  ,decode(is_number(m.duration_of_study_weeks),1,null,to_number(m.duration_of_study_weeks))
		  ,decode(is_number(m.number_of_patients),1,null,to_number(m.number_of_patients))
		  ,decode(is_number(m.number_of_sites),1,null,to_number(m.number_of_sites))
          ,m.route_of_administration
          ,m.dosing_regimen
          ,m.group_assignment
          ,m.type_of_control
          ,decode(is_date(m.completion_date,'YYYYMMDD'),1,null,to_date(m.completion_date,'YYYYMMDD'))
          ,m.primary_end_points
          ,m.secondary_end_points
          ,m.inclusion_criteria
          ,m.exclusion_criteria
          ,m.subjects
          ,m.gender_restriction_mfb
		  ,decode(is_number(m.min_age),1,null,to_number(m.min_age))
		  ,decode(is_number(m.max_age),1,null,to_number(m.max_age))
          ,m.secondary_ids
          ,b.bio_experiment_id
		  ,m.development_partner
		  ,m.main_findings
		  ,m.geo_platform
		  --,m.platform_name
		  ,m.search_area
	from lt_src_study_metadata m
	    ,biomart.bio_experiment b
	where m.study_id is not null
	  and m.study_id = b.accession
	  and not exists
	      (select 1 from biomart.bio_clinical_trial x
		   where m.study_id = x.trial_number);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data in BIOMART bio_clinical_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
*/
	
	--	Insert new trial into bio_data_uid
	
	begin
	insert into biomart.bio_data_uid
	(bio_data_id
	,unique_id
	,bio_data_type
	)
	select distinct b.bio_experiment_id
	      ,'EXP:' || m.study_id
		  ,'EXP'
	from biomart.bio_experiment b
		,tm_lz.lt_src_study_metadata m
	where m.study_id is not null
	  and m.study_id = b.accession
	  and not exists
	      (select 1 from biomart.bio_data_uid x
		   where x.unique_id = 'EXP:' || m.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Added study to bio_data_uid',rowCt,stepCt,'Done') into rtnCd;

	--	delete existing compound data for study, compound list may change
	
	begin
	delete from biomart.bio_data_compound dc
	where dc.bio_data_id in 
		 (select x.bio_experiment_id
		  from biomart.bio_experiment x
			  ,tm_lz.lt_src_study_metadata y
		  where x.accession = y.study_id
		    and x.etl_id = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study data from bio_compound',rowCt,stepCt,'Done') into rtnCd;

	--	add study compound data
	
	for study_compound_rec in
		select distinct study_id
			  ,compound
		from tm_lz.lt_src_study_metadata
		where compound is not null
	loop
		select length(study_compound_rec.compound)-length(replace(study_compound_rec.compound,';',''))+1 into dcount;
		while dcount > 0
		Loop	
			select tm_cz.parse_nth_value(study_compound_rec.compound,dcount,';') into tmp_compound;
			   
			--	add new compound
			begin
			insert into biomart.bio_compound
			(generic_name)
			select tmp_compound
			where not exists
				 (select 1 from biomart.bio_compound x
				  where upper(x.generic_name) = upper(tmp_compound))
			  and tmp_compound is not null;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study compound to bio_compound',rowCt,stepCt,'Done') into rtnCd;
					
			--	Insert new trial data into bio_data_compound
			begin
			insert into biomart.bio_data_compound
			(bio_data_id
			,bio_compound_id
			,etl_source
			)
			select b.bio_experiment_id
				  ,c.bio_compound_id
				  ,'METADATA:' || study_compound_rec.study_id
			from biomart.bio_experiment b
				,biomart.bio_compound c
			where upper(tmp_compound) = upper(c.generic_name) 
			  and tmp_compound is not null
			  and b.accession = study_compound_rec.study_id
			  and not exists
					 (select 1 from biomart.bio_data_compound x
						  where b.bio_experiment_id = x.bio_data_id
							and c.bio_compound_id = x.bio_compound_id);
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study compound to bio_data_compound',rowCt,stepCt,'Done') into rtnCd;			
			dcount := dcount - 1;
		end loop;
	end loop;

	--	delete existing disease data for studies
	
	begin
	delete from biomart.bio_data_disease dc
	where dc.bio_data_id in 
		 (select x.bio_experiment_id
		  from biomart.bio_experiment x
			  ,tm_lz.lt_src_study_metadata y
		  where x.accession = y.study_id
		    and x.etl_id = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study data from bio_data_disease',rowCt,stepCt,'Done') into rtnCd;

	--	add study disease data
	
	for study_disease_rec in
		select distinct study_id, disease
		from tm_lz.lt_src_study_metadata
		where disease is not null
	loop
		select length(study_disease_rec.disease)-length(replace(study_disease_rec.disease,';',''))+1 into dcount;
		while dcount > 0
		Loop	
			select tm_cz.parse_nth_value(study_disease_rec.disease,dcount,';') into tmp_disease;
			   
			--	add new disease
			begin
			insert into biomart.bio_disease
			(disease
			,prefered_name)
			select tmp_disease
				  ,tmp_disease
			where not exists
				 (select 1 from biomart.bio_disease x
				  where upper(x.disease) = upper(tmp_disease))
			  and tmp_disease is not null;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study disease to bio_disease',rowCt,stepCt,'Done') into rtnCd;
			
			--	Insert new trial data into bio_data_disease
			begin
			insert into biomart.bio_data_disease
			(bio_data_id
			,bio_disease_id
			,etl_source
			)
			select b.bio_experiment_id
				  ,c.bio_disease_id
				  ,'METADATA:' || study_disease_rec.study_id
			from biomart.bio_experiment b
				,biomart.bio_disease c
			where upper(tmp_disease) = upper(c.disease) 
			  and tmp_disease is not null
			  and b.accession = study_disease_rec.study_id
			  and not exists
					 (select 1 from biomart.bio_data_disease x
					  where b.bio_experiment_id = x.bio_data_id
						and c.bio_disease_id = x.bio_disease_id);
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study disease to bio_data_disease',rowCt,stepCt,'Done') into rtnCd;
			dcount := dcount - 1;
		end loop;
	end loop;

	--	delete existing taxonomy data for studies
	
	begin
	delete from biomart.bio_data_taxonomy dc
	where dc.bio_data_id in 
		 (select x.bio_experiment_id
		  from biomart.bio_experiment x
			  ,tm_lz.lt_src_study_metadata y
		  where x.accession = y.study_id
		    and x.etl_id = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study data from bio_data_taxonomy',rowCt,stepCt,'Done') into rtnCd;

	--	add study organism to taxonomy
	
	for study_taxonomy_rec in
		select distinct study_id, organism
		from tm_lz.lt_src_study_metadata
		where organism is not null
	loop
		select length(study_taxonomy_rec.organism)-length(replace(study_taxonomy_rec.organism,';',''))+1 into dcount;
		while dcount > 0
		Loop	
			select tm_cz.parse_nth_value(study_taxonomy_rec.organism,dcount,';') into tmp_organism;
			   
			--	add new organism
			begin
			insert into biomart.bio_taxonomy
			(taxon_name
			,taxon_label)
			select tmp_organism
				  ,tmp_organism
			where not exists
				 (select 1 from biomart.bio_taxonomy x
				  where upper(x.taxon_name) = upper(tmp_organism))
			  and tmp_organism is not null;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study organism to bio_taxonomy',rowCt,stepCt,'Done') into rtnCd;
							
			--	Insert new trial data into bio_data_taxonomy
			begin
			insert into biomart.bio_data_taxonomy
			(bio_data_id
			,bio_taxonomy_id
			,etl_source
			)
			select b.bio_experiment_id
				  ,c.bio_taxonomy_id
				  ,'METADATA:' || study_disease_rec.study_id
			from biomart.bio_experiment b
				,biomart.bio_taxonomy c
			where upper(tmp_organism) = upper(c.taxon_name) 
			  and tmp_organism is not null
			  and b.accession = study_disease_rec.study_id
			  and not exists
					 (select 1 from biomart.bio_data_taxonomy x
					  where b.bio_experiment_id = x.bio_data_id
						and c.bio_taxonomy_id = x.bio_taxonomy_id);
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study organism to bio_data_taxonomy',rowCt,stepCt,'Done') into rtnCd;

			dcount := dcount - 1;
		end loop;
	end loop;
	
	--	add ncbi/GEO linking
	
	--	check if ncbi exists in bio_content_repository, if not, add
	
	select count(*) into dcount
	from biomart.bio_content_repository
	where repository_type = 'NCBI'
	  and location_type = 'URL';
	
	if dcount = 0 then
		begin
		insert into biomart.bio_content_repository
		(location
		,active_y_n
		,repository_type
		,location_type) 
		values ('http://www.ncbi.nlm.nih.gov/','Y','NCBI','URL');
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		get diagnostics rowCt := ROW_COUNT;	
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert link to NCBI into bio_content_repository',rowCt,stepCt,'Done') into rtnCd;
	end if;

	--	insert GSE studies into bio_content
	
	begin
	insert into biomart.bio_content
	(repository_id
	,location
	,file_type
	,etl_id_c
	)
	select bcr.bio_content_repo_id
		  ,'geo/query/acc.cgi?acc=' || m.study_id
		  ,'Experiment Web Link'
		  ,'METADATA:' || m.study_id
	from tm_lz.lt_src_study_metadata m
		,biomart.bio_content_repository bcr
	where m.study_id like 'GSE%'
	  and bcr.repository_type = 'NCBI'
	  and bcr.location_type = 'URL'
	  and not exists
		 (select 1 from biomart.bio_content x
		  where x.etl_id_c like '%' || m.study_id || '%'
		    and x.file_type = 'Experiment Web Link'
			and x.location = 'geo/query/acc.cgi?acc=' || m.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add GEO study to bio_cotent',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert GSE studies into bio_content_reference
	
	begin
	insert into biomart.bio_content_reference
	(bio_content_id
	,bio_data_id
	,content_reference_type
	,etl_id_c
	)
	select bc.bio_file_content_id
		  ,be.bio_experiment_id
		  ,'Experiment Web Link'
		  ,'METADATA:' || m.study_id
	from tm_lz.lt_src_study_metadata m
		,biomart.bio_experiment be
		,biomart.bio_content bc
	where m.study_id like 'GSE%'
	  and m.study_id = be.accession
	  and bc.file_type = 'Experiment Web Link'
	  and bc.etl_id_c = 'METADATA:' || m.study_id
	  and bc.location = 'geo/query/acc.cgi?acc=' || m.study_id
	  and not exists
		 (select 1 from biomart.bio_content_reference x
		  where bc.bio_file_content_id = x.bio_content_id
		    and be.bio_experiment_id = x.bio_data_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Added GEO study to bio_content_reference',rowCt,stepCt,'Done') into rtnCd;

	--	add PUBMED linking
	
	--	delete existing pubmed data for studies
	
	begin
	delete from biomart.bio_content_reference dc
	where dc.bio_content_id in 
		 (select x.bio_file_content_id
		  from biomart.bio_content x
			  ,tm_lz.lt_src_study_metadata y
		  where x.file_type = 'Publication Web Link'
		    and x.etl_id_c = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study pubmed from bio_content_reference',rowCt,stepCt,'Done') into rtnCd;
		
	begin
	delete from biomart.bio_content dc
	where dc.bio_file_content_id in 
		 (select x.bio_file_content_id
		  from biomart.bio_content x
			  ,tm_lz.lt_src_study_metadata y
		  where x.file_type = 'Publication Web Link'
		    and x.etl_id_c = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study pubmed from bio_content',rowCt,stepCt,'Done') into rtnCd;

	--	add study pubmed ids'
	
	select count(*) into dcount
	from bio_content_repository
	where repository_type = 'PubMed';	
	
	if dcount = 0 then
		begin
		insert into biomart.bio_content_repository
		(location
		,active_y_n
		,repository_type
		,location_type) 
		values ('http://www.ncbi.nlm.nih.gov/pubmed/','Y','PubMed','URL');
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		get diagnostics rowCt := ROW_COUNT;	
		end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add pubmed url to bio_content_repository',rowCt,stepCt,'Done') into rtnCd;
	end if;
	
	for study_pubmed_rec in
		select distinct study_id, pubmed_ids
		from tm_lz.lt_src_study_metadata
		where pubmed_ids is not null
	loop
		select length(study_pubmed_rec.pubmed_ids)-length(replace(study_pubmed_rec.pubmed_ids,';',''))+1 into dcount;
		while dcount > 0
		Loop	
			-- multiple pubmed id can be separated by ;, pubmed id and title are separated by :
			
			select tm_cz.parse_nth_value(study_pubmed_rec.pubmed_ids,dcount,';') into tmp_pubmed;			
			select tm_cz.instr(tmp_pubmed,':') into lcount;
			
			if lcount = 0 then
				pubmed_id := tmp_pubmed;
				pubmed_title := null;
			else
				pubmed_id := substr(tmp_pubmed,1,instr(tmp_pubmed,':')-1);	
				pubmed_title := substr(tmp_pubmed,instr(tmp_pubmed,':')+1);
			end if;
			
			begin
			insert into biomart.bio_content
			(repository_id
			,location
			,title
			,file_type
			,etl_id_c
			)
			select bcr.bio_content_repo_id
				  ,pubmed_id
				  ,pubmed_title
				  ,'Publication Web Link'
				  ,'METADATA:' || study_pubmed_rec.study_id
			from biomart.bio_content_repository bcr
			where bcr.repository_type = 'PubMed'
			  and not exists
					 (select 1 from biomart.bio_content x
					  where x.etl_id_c like '%' || study_pubmed_rec.study_id || '%'
					    and x.file_type = 'Publication Web Link'
						and x.location = pubmed_id);
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study pubmed to bio_content',rowCt,stepCt,'Done') into rtnCd;
		
			begin
			insert into biomart.bio_content_reference
			(bio_content_id
			,bio_data_id
			,content_reference_type
			,etl_id_c
			)
			select bc.bio_file_content_id
				  ,be.bio_experiment_id
				  ,'Publication Web Link'
				  ,'METADATA:' || study_pubmed_rec.study_id
			from biomart.bio_experiment be
				,biomart.bio_content bc
			where be.accession = study_pubmed_rec.study_id
			  and bc.file_type = 'Publication Web Link'
			  and bc.etl_id_c = 'METADATA:' || study_pubmed_rec.study_id
			  and bc.location = pubmed_id
			  and not exists
				 (select 1 from biomart.bio_content_reference x
				  where bc.bio_file_content_id = x.bio_content_id
					and be.bio_experiment_id = x.bio_data_id);	
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study pubmed to bio_content_reference',rowCt,stepCt,'Done') into rtnCd;
			dcount := dcount - 1;
		end loop;
	end loop;
	
		--	Create i2b2_tags

	begin
	delete from i2b2metadata.i2b2_tags
	where upper(tag_type) = 'Trial';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete study from i2b2_tags',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into i2b2metadata.i2b2_tags
	(path, tag, tag_type, tags_idx)
	select min(b.c_fullname) as path
		  ,be.accession as tag
		  ,'Trial' as tag_type
		  ,0 as tags_idx
	from biomart.bio_experiment be
		,i2b2metadata.i2b2 b
	where be.accession = b.sourcesystem_cd
	group by be.accession;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study to i2b2_tags',rowCt,stepCt,'Done') into rtnCd;

/*					 
	--	Insert trial data tags - COMPOUND
	
	delete from i2b2_tags t
	where upper(t.tag_type) = 'COMPOUND';

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete existing Compound tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	insert into i2b2_tags
	(path, tag, tag_type, tags_idx)
	select distinct min(o.c_fullname) as path
		  ,decode(x.rec_num,1,c.generic_name,c.brand_name) as tag
		  ,'Compound' as tag_type
		  ,1 as tags_idx
	from bio_experiment be
		,bio_data_compound bc
		,bio_compound c
		,i2b2 o
		,(select rownum as rec_num from table_access where rownum < 3) x
	where be.bio_experiment_id = bc.bio_data_id
       and bc.bio_compound_id = c.bio_compound_id
       and be.accession = o.sourcesystem_cd
       and decode(x.rec_num,1,c.generic_name,c.brand_name) is not null
	group by decode(x.rec_num,1,c.generic_name,c.brand_name);

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert Compound tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
					 
	--	Insert trial data tags - DISEASE
	
	delete from i2b2_tags t
	where upper(t.tag_type) = 'DISEASE';

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete existing DISEASE tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
		
	insert into i2b2_tags
	(path, tag, tag_type, tags_idx)
	select distinct min(o.c_fullname) as path
		   ,c.prefered_name
		   ,'Disease' as tag_type
		   ,1 as tags_idx
	from bio_experiment be
		,bio_data_disease bc
		,bio_disease c
		,i2b2 o
      --,(select rownum as rec_num from table_access where rownum < 3) x
	where be.bio_experiment_id = bc.bio_data_id
      and bc.bio_disease_id = c.bio_disease_id
      and be.accession = o.sourcesystem_cd
    --and decode(x.rec_num,1,c.generic_name,c.brand_name) is not null
	group by c.prefered_name;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert Disease tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
*/
	
    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	
END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_study_metadata(currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_process_mrna_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_process_mrna_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT 0) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, deapp, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	TrialID			varchar(100);
	RootNode		varchar(2000);
	root_level		integer;
	topNode			varchar(2000);
	topLevel		integer;
	tPath			varchar(2000);
	study_name		varchar(100);
	sourceCd		varchar(50);
	secureStudy		varchar(1);

	dataType		varchar(10);
	sqlText			varchar(1000);
	tText			varchar(1000);
	gplTitle		varchar(1000);
	pExists			numeric;
	partTbl   		numeric;
	partExists 		numeric;
	sampleCt		numeric;
	idxExists 		numeric;
	logBase			numeric;
	pCount			integer;
	sCount			integer;
	tablespaceName	varchar(200);
	partitioniD		numeric(18,0);
	partitionName	varchar(100);
	partitionIndx	varchar(100);

	--	cursor to add leaf nodes, cursor is used here because there are few nodes to be added

	addNodes CURSOR is
	select distinct t.leaf_node
          ,t.node_name
	from  tm_wz.wt_mrna_nodes t
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where t.leaf_node = x.c_fullname);

	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	delNodes CURSOR is
	select distinct c_fullname
	from  i2b2metadata.i2b2
	where c_fullname like topNode || '%' escape '`'
      and substr(c_visualattributes,2,1) = 'H';

BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := 'tm_cz';
	procedureName := 'i2b2_process_mrna_data';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_mrna_data',0,stepCt,'Done') into rtnCd;

	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;

	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\','g');
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;

	if data_type is null then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;

	logBase := log_base;
	sourceCd := upper(coalesce(source_cd,'STD'));

	--	Get count of records in tm_lz.lt_src_mrna_subj_samp_map

	select count(*) into sCount
	from tm_lz.lt_src_mrna_subj_samp_map;

	--	check if all subject_sample map records have a subject_id, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where subject_id is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'subject_id missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a sample_cd, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where sample_cd is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'sample_cd missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a platform, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where platform is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Platform missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

  	--	check if platform exists in probeset_deapp .  If not, abort run.

	select count(*) into pCount
	from tm_cz.probeset_deapp
	where platform in (select distinct m.platform from tm_lz.lt_src_mrna_subj_samp_map m);

	if pCount = 0 then
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No Gene Expression platforms in deapp.de_mrna_annotation',0,pCount,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if entry in deapp.de_gpl_info for every Gene Expression platform, if not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map sm
	where not exists
		 (select 1 from deapp.de_gpl_info gi
		  where sm.platform = gi.platform
		    and gi.marker_type = 'Gene Expression'
			and gi.title is not null);

	if pCount > 0 then
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'deapp.de_gpl_info entry missing for one or more platforms',0,pCount,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a tissue_type, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map
	where tissue_type is null;

	if pCount > 0 then
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Tissue_Type is null for subjects',0,pCount,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if there are multiple platforms for a single sample   if yes, then different source_cd must be used to load the samples.

	select count(*) into pCount
	from (select sample_cd
		  from tm_lz.lt_src_mrna_subj_samp_map
		  group by sample_cd
		  having count(distinct platform) > 1) x;

	if pCount > 0 then
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Multiple platforms for single sample',0,pCount,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	-- Get root_node from topNode

	select tm_cz.parse_nth_value(topNode, 2, '\') into RootNode;

	select count(*) into pExists
	from i2b2metadata.i2b2
	where c_name = rootNode;

	if pExists = 0 then
		select tm_cz.i2b2_add_root_node(rootNode, jobId) into rtnCd;
	end if;

	select c_hlevel into root_level
	from i2b2metadata.i2b2
	where c_name = RootNode;

	-- Get study name from topNode

	select tm_cz.parse_nth_value(topNode, topLevel, '\') into study_name;

	--	Add any upper level nodes as needed

	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		select tm_cz.i2b2_fill_in_tree(null, tPath, jobId) into rtnCd;
	end if;

	--	uppercase study_id in tm_lz.lt_src_mrna_subj_samp_map in case curator forgot

	begin
	update tm_lz.lt_src_mrna_subj_samp_map
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in tm_lz.lt_src_mrna_subj_samp_map',rowCt,stepCt,'Done') into rtnCd;

	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into i2b2demodata.patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from tm_lz.lt_src_mrna_subj_samp_map s
		     ,deapp.de_gpl_info g
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'GENE EXPRESSION'
		   and not exists
			  (select 1 from i2b2demodata.patient_dimension x
			   where x.sourcesystem_cd =
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	add security for trial if new subjects added to patient_dimension

	if pCount > 0 then
		select tm_cz.i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;
	end if;

	--	Delete existing observation_fact data, will be repopulated

	begin
	delete from i2b2demodata.observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from deapp.de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'MRNA_AFFYMETRIX');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--	delete existing data from de_subject_microarray_data

	select count(*) into pExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	  and coalesce(sm.source_cd,'STD') = sourceCd
	  and sm.platform = 'MRNA_AFFYMETRIX';

	if pExists > 0 then
		begin
		delete from deapp.de_subject_microarray_data
		where trial_name = TrialId;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data from de_subject_microarray_data',rowCt,stepCt,'Done') into rtnCd;
	end if;

	--	truncate tmp node table

	execute ('truncate table tm_wz.wt_mrna_nodes');

	--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
	--	from wt_subject_mrna_data

	execute ('truncate table tm_wz.wt_mrna_node_values');

	begin
	insert into tm_wz.wt_mrna_node_values
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from tm_lz.lt_src_mrna_subj_samp_map a
	    ,deapp.de_gpl_info g
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'GENE EXPRESSION';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP tm_wz.wt_mrna_node_values',rowCt,stepCt,'Done') into rtnCd;

	--	inserts that create the ontology for the leaf nodes

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  tm_wz.wt_mrna_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

    stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for platform node so platform concept can be populated

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'PLATFORM'
	from  tm_wz.wt_mrna_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Create platform nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'ATTR1'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%ATTR1%'
	  and attribute_1 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for tissue_type node so sample_type_cd can be populated

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else '' end as platform
		  ,tissue_type as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'TISSUETYPE'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%TISSUETYPE%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	set node_name

	begin
	update tm_wz.wt_mrna_nodes
	set node_name=tm_cz.parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	add leaf nodes for mRNA data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		select tm_cz.i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;

		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,tText,1,stepCt,'Done') into rtnCd;

		select tm_cz.i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID) into rtnCd;

	END LOOP;

	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes

	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;

	--	update concept_cd for nodes, this is done to make the next insert easier

	begin
	update tm_wz.wt_mrna_nodes t
	set concept_cd=(select c.concept_cd from i2b2demodata.concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from i2b2demodata.concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Update tm_wz.wt_mrna_nodes with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;

	--	delete any site/subject/samples that are not in lt_src_mrna_data for the trial on a reload

	begin
	delete from deapp.de_subject_sample_mapping sm
	where sm.trial_name = trial_id
	  and sm.source_cd = sourceCd
	  and sm.platform = 'MRNA_AFFYMETRIX'
	 and not exists
		 (select 1 from tm_lz.lt_src_mrna_subj_samp_map x
		  where coalesce(sm.site_id,'@') = coalesce(x.site_id,'@')
		    and sm.subject_id = x.subject_id
			and sm.sample_cd = x.sample_cd
			and sm.source_cd = coalesce(x.source_cd,'STD'));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete dropped site/subject/sample from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

	--Update or insert DE_SUBJECT_SAMPLE_MAPPING from wt_subject_mrna_data

	--PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
	--SITE_ID         = site_id
	--SUBJECT_ID      = subject_id
	--SUBJECT_TYPE    = NULL
	--CONCEPT_CODE    = from LEAF records in tm_wz.wt_mrna_nodes
	--SAMPLE_TYPE    	= TISSUE_TYPE
	--SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in tm_wz.wt_mrna_nodes
	--TRIAL_NAME      = TRIAL_NAME
	--TIMEPOINT		= attribute_2
	--TIMEPOINT_CD	= concept_cd from ATTR2 records in tm_wz.wt_mrna_nodes
	--TISSUE_TYPE     = attribute_1
	--TISSUE_TYPE_CD  = concept_cd from ATTR1 records in tm_wz.wt_mrna_nodes
	--PLATFORM        = MRNA_AFFYMETRIX - this is required by ui code
	--PLATFORM_CD     = concept_cd from PLATFORM records in tm_wz.wt_mrna_nodes
	--DATA_UID		= concatenation of concept_cd-patient_num
	--GPL_ID			= platform from wt_subject_mrna_data
	--CATEGORY_CD		= category_cd that generated ontology
	--SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
	--SAMPLE_CD		= sample_cd
	--SOURCE_CD		= sourceCd
	--PARTITION_ID	= partitionId

	--ASSAY_ID        = generated by trigger

	begin
	with upd as (select a.site_id, a.subject_id, a.sample_cd,
					ln.concept_cd as concept_code, ttp.concept_cd as sample_type_cd, a2.concept_cd as timepoint_cd, a1.concept_cd as tissue_type_cd, a.category_cd,
				    pd.patient_num as patient_id, ln.concept_cd || '-' || pd.patient_num::text as data_uid,
					ln.tissue_type as sample_type, ln.attribute_1 as tissue_type, ln.attribute_2 as timepoint, a.platform as gpl_id
				 from tm_lz.lt_src_mrna_subj_samp_map a
				 inner join i2b2demodata.patient_dimension pd
					on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = pd.sourcesystem_cd
				 inner join tm_wz.wt_mrna_nodes ln
					on 	a.platform = ln.platform
					and a.tissue_type = ln.tissue_type
					and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
					and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
					and ln.node_type = 'LEAF'
				 inner join tm_wz.wt_mrna_nodes pn
					on  a.platform = pn.platform
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
					and pn.node_type = 'PLATFORM'
				 left outer join tm_wz.wt_mrna_nodes ttp
					on  a.tissue_type = ttp.tissue_type
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
					and ttp.node_type = 'TISSUETYPE'
				 left outer join tm_wz.wt_mrna_nodes a1
					on  a.attribute_1 = a1.attribute_1
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
					and a1.node_type = 'ATTR1'
				 left outer join tm_wz.wt_mrna_nodes a2
					on  a.attribute_2 = a1.attribute_2
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
					and a2.node_type = 'ATTR2')
		update deapp.de_subject_sample_mapping pd
		set concept_code=upd.concept_code
			,sample_type_cd=upd.sample_type_cd
			,timepoint_cd=upd.timepoint_cd
			,tissue_type_cd=upd.tissue_type_cd
			,category_cd=upd.category_cd
			,patient_id=upd.patient_id
			,data_uid=upd.data_uid
			,sample_type=upd.sample_type
			,tissue_type=upd.tissue_type
			,timepoint=upd.timepoint
			,omic_patient_id=upd.patient_id
			,partition_id=partitionId
		from upd
		where pd.trial_name = TrialID
		  and pd.source_cd = sourceCD
		  and coalesce(pd.site_id,'') = coalesce(upd.site_id,'')
		  and pd.subject_id = upd.subject_id
		  and pd.sample_cd = upd.sample_cd;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Update existing data in de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pcount := rowCt;	--	set counter to check that all subject_sample mapping records were added/updated
	
	--	insert any site/subject/samples that are not in de_subject_sample_mapping

	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
	,partition_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
		  ,partitionId
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'MRNA_AFFYMETRIX' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+Gene_Expression+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from tm_lz.lt_src_mrna_subj_samp_map a
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join i2b2demodata.patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = b.sourcesystem_cd
		inner join tm_wz.wt_mrna_nodes ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
			and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
			and ln.node_type = 'LEAF'
		inner join tm_wz.wt_mrna_nodes pn
			on a.platform = pn.platform
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
			and pn.node_type = 'PLATFORM'
		left outer join tm_wz.wt_mrna_nodes ttp
			on a.tissue_type = ttp.tissue_type
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
			and ttp.node_type = 'TISSUETYPE'
		left outer join tm_wz.wt_mrna_nodes a1
			on a.attribute_1 = a1.attribute_1
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
			and a1.node_type = 'ATTR1'
		left outer join tm_wz.wt_mrna_nodes a2
			on a.attribute_2 = a1.attribute_2
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
			and a2.node_type = 'ATTR2'
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null
		  and not exists
			  (select 1 from deapp.de_subject_sample_mapping x
			   where a.trial_name = x.trial_name
			     and coalesce(a.source_cd,'STD') = x.source_cd
				 and x.platform = 'MRNA_AFFYMETRIX'
				 and coalesce(a.site_id,'') = coalesce(x.site_id,'')
				 and a.subject_id = x.subject_id
				 and a.sample_cd = x.sample_cd
				 )) t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pCount := pCount + rowCt;
	
	--	check if all records from lt_src_mrna_subj_samp_map were added/updated
	
	if scount <> pCount then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Not all records in lt_src_mrna_subj_samp_map inserted/updated in de_subject_sample_mapping',0,stepCt,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;	
	
	--	Insert records for subjects into observation_fact

	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,current_timestamp
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  deapp.de_subject_sample_mapping m
    where m.trial_name = TrialID
	  and m.source_cd = sourceCD
      and m.platform = 'MRNA_AFFYMETRIX';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--Update I2b2 for correct c_columndatatype, c_visualattributes, c_metadataxml

	begin
	with upd as (select x.concept_cd, min(case when x.node_type = 'LEAF' then 0 else 1 end) as node_type from tm_wz.wt_mrna_nodes x group by x.concept_cd)
	update i2b2metadata.i2b2 t
	set c_columndatatype = 'T'
	   ,c_metadataxml = null
	   ,c_visualattributes=case when upd.node_type = 0 then 'LAH' else 'FA' end  
	from upd
	where t.c_basecode = upd.concept_cd;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Initialize data_type, visualattributes and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;

  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for mRNA data

    select tm_cz.i2b2_create_concept_counts(topNode ,jobID ) into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done') into rtnCd;

	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select tm_cz.i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;

		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;

	END LOOP;

	--Reload Security: Inserts one record for every I2B2 record into the security table

    select tm_cz.i2b2_load_security_data(jobId) into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done') into rtnCd;

	--	tag data with probeset_id from reference.probeset_deapp

	execute ('truncate table tm_wz.wt_subject_mrna_probeset');

	--	note: assay_id represents a unique subject/site/sample

	begin
	insert into tm_wz.wt_subject_mrna_probeset
	(probeset_id
	,intensity_value
	,assay_id
	,patient_id
	)
	select gs.probeset_id
		  ,avg(md.intensity_value::numeric(18,4))
		  ,sd.assay_id
		  ,sd.patient_id
	from deapp.de_subject_sample_mapping sd
		,tm_lz.lt_src_mrna_data md
		,tm_cz.probeset_deapp gs
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'MRNA_AFFYMETRIX'
	  and sd.trial_name = TrialId
	  and sd.source_cd = sourceCd
	  and sd.gpl_id = gs.platform
	  and md.probeset = gs.probeset
	  and case when dataType = 'R'
			   then case when md.intensity_value::numeric(18,4) > 0 then 1 else 0 end
			   else 1 end = 1         --	take only >0 for dataType R
	group by gs.probeset_id
		  ,sd.assay_id
		  ,sd.patient_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_mrna_probeset',rowCt,stepCt,'Done') into rtnCd;

	if rowCt = 0 then
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Unable to match probesets to platform in probeset_deapp',0,rowCt,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	drop indexes on deapp.de_subject_microarray_data
	
	select tm_cz.czx_table_index_maint('DROP','deapp','de_subject_microarray_data',jobId) into rtnCd;
	
	if rowCt = 0 then
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Error dropping indexes on de_subject_microarray_data',0,rowCt,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;
	
	--	insert into de_subject_microarray_data when dataType is T (transformed)

	if dataType = 'T' then
		begin
		insert into deapp.de_subject_microarray_data
		(trial_name
		,probeset_id
		,assay_id
		,patient_id
		,zscore
		)
		select TrialId
			  ,probeset_id
			  ,assay_id
			  ,patient_id
			  ,case when intensity_value < -2.5 then -2.5
					when intensity_value > 2.5 then 2.5
					else intensity_value end
		from tm_wz.wt_subject_mrna_probeset;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted data into de_subject_microarray_data',rowCt,stepCt,'Done') into rtnCd;
	else
		--	calculate zscore and insert to partition

		execute ('drop index if exists tm_wz.wt_subject_mrna_logs_i1');
		execute ('drop index if exists tm_wz.wt_subject_mrna_calcs_i1');
		execute ('truncate table tm_wz.wt_subject_microarray_logs');
		execute ('truncate table tm_wz.wt_subject_microarray_calcs');
		execute ('truncate table tm_wz.wt_subject_microarray_med');
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Drop indexes and truncate zscore work tables',1,stepCt,'Done') into rtnCd;

		begin
		insert into tm_wz.wt_subject_microarray_logs
		(probeset_id
		,assay_id
		,patient_id
		,raw_intensity
		,log_intensity
		)
		select probeset_id
			  ,assay_id
			  ,patient_id
			  ,case when dataType = 'R' then intensity_value else 
				    case when logBase = -1 then 0 else round(power(logBase,intensity_value),4) end
			   end
			  ,case when dataType = 'L' then intensity_value else log(logBase,intensity_value) end
		from tm_wz.wt_subject_mrna_probeset;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_microarray_logs',rowCt,stepCt,'Done') into rtnCd;

		execute ('create index wt_subject_mrna_logs_i1 on tm_wz.wt_subject_microarray_logs (probeset_id) ');
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_logs',0,stepCt,'Done') into rtnCd;

		--	calculate mean_intensity, median_intensity, and stddev_intensity per probeset

		begin
		insert into tm_wz.wt_subject_microarray_calcs
		(probeset_id
		,mean_intensity
		,median_intensity
		,stddev_intensity
		)
		select d.probeset_id
			  ,avg(log_intensity)
			  ,tm_cz.czx_percentile_cont(array_agg(log_intensity), .5)
			  ,stddev(log_intensity)
		from tm_wz.wt_subject_microarray_logs d
		group by d.probeset_id;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_microarray_calcs',rowCt,stepCt,'Done') into rtnCd;

		execute ('create index wt_subject_mrna_calcs_i1 on tm_wz.wt_subject_microarray_calcs (probeset_id) ');
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_calcs',0,stepCt,'Done') into rtnCd;

		-- calculate zscore and insert into partition
		
		begin
		insert into deapp.de_subject_microarray_data
		(trial_name
		,probeset_id
		,assay_id
		,patient_id
		,raw_intensity
		,log_intensity
		,zscore
		)
		select TrialId
			  ,d.probeset_id
			  ,d.assay_id
			  ,d.patient_id
			  ,round(case when dataType = 'R' then d.raw_intensity
				when dataType = 'L' 
				then case when logBase = -1 then null else power(logBase, d.log_intensity) end
				else null
				end,4)
			  ,d.log_intensity
			  ,round(case when (d.log_intensity - c.median_intensity ) / c.stddev_intensity < -2.5 then -2.5
				    when (d.log_intensity - c.median_intensity ) / c.stddev_intensity > 2.5 then 2.5 
					else (d.log_intensity - c.median_intensity ) / c.stddev_intensity end,4)		  
		from tm_wz.wt_subject_microarray_logs d
			,tm_wz.wt_subject_microarray_calcs c
		where d.probeset_id = c.probeset_id;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score and insert into de_subject_microarray_data',rowCt,stepCt,'Done') into rtnCd;
	end if;
	
	--	add back indexes on de_subject_microarray_data
	
	select tm_cz.czx_table_index_maint('ADD','deapp','de_subject_microarray_data',jobId) into rtnCd;
	if rowCt = 0 then
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Error adding indexes on de_subject_microarray_data',0,rowCt,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;
    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_process_mrna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: instr(character varying, character varying, integer, integer); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION instr(string character varying, string_to_search character varying, beg_index integer DEFAULT 1, occur_index integer DEFAULT 1) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos > 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$$;


ALTER FUNCTION tm_cz.instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) OWNER TO postgres;

--
-- Name: is_date(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION is_date(p_text_date character varying, p_date_format character varying DEFAULT 'YYYY-MM-DD HH24:mi'::character varying) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$ 
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare 
	v_tmp_date	timestamp without time zone;
 
begin 
    v_tmp_date := to_date(p_text_date, p_date_format);
    return 0; 
    EXCEPTION WHEN OTHERS then 
                return 1; 
end; 
$$;


ALTER FUNCTION tm_cz.is_date(p_text_date character varying, p_date_format character varying) OWNER TO postgres;

--
-- Name: is_numeric(character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION is_numeric(character varying) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$ 
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare 
        i numeric; 
begin 
        i := $1::numeric; 
        return 0; 
        EXCEPTION WHEN invalid_text_representation then 
                return 1; 
end; 
$_$;


ALTER FUNCTION tm_cz.is_numeric(character varying) OWNER TO postgres;

--
-- Name: parse_nth_value(character varying, numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION parse_nth_value(pvalue character varying, location numeric, delimiter character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
   v_posA integer;
   v_posB integer;
   iLoc	  integer;

begin
   iLoc := location;
   if location = 1 then
      v_posA := 1; -- Start at the beginning
   else
	  select tm_cz.instr(pValue,delimiter, 1, iLoc-1) into v_posA;
 --     v_posA := tm_cz.instr(pValue,delimiter, 1, location - 1); 
      if v_posA = 0 then
         return null; --No values left.
      end if;
      v_posA := v_posA + length(delimiter);
   end if;

   select tm_cz.instr (pValue, delimiter, 1, iLoc) into v_posB;
   --v_posB := tm_cz.instr (pValue, delimiter, 1, location);
   if v_posB = 0 then -- Use the end of the file
      return substr (pValue, v_posA);
   end if;
   
   return substr (pValue, v_posA, v_posB - v_posA);

end;
$$;


ALTER FUNCTION tm_cz.parse_nth_value(pvalue character varying, location numeric, delimiter character varying) OWNER TO postgres;

--
-- Name: tf_trg_cz_job_id(); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION tf_trg_cz_job_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
      if coalesce(NEW.JOB_ID::text, '') = '' then          
        select nextval('tm_cz.SEQ_CZ_JOB_MASTER') into NEW.JOB_ID ;       
      end if;       
       RETURN NEW;
  end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_job_id() OWNER TO postgres;

--
-- Name: tf_trg_cz_seq_id(); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION tf_trg_cz_seq_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
      if coalesce(NEW.SEQ_ID::text, '') = '' then          
        select nextval('tm_cz.SEQ_CZ_JOB_AUDIT') into NEW.SEQ_ID ;       
      end if;       
       RETURN NEW;
  end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_seq_id() OWNER TO postgres;

--
-- Name: tf_trg_probeset_deapp(); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION tf_trg_probeset_deapp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
			if NEW.PROBESET_ID is null then
				select nextval('tm_cz.SEQ_PROBESET_ID') into NEW.PROBESET_ID ;       
			end if;   
	RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_probeset_deapp() OWNER TO postgres;

SET search_path = biomart, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: bio_assay; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay (
    bio_assay_id bigint NOT NULL,
    etl_id character varying(100) NOT NULL,
    study character varying(200),
    protocol character varying(200),
    description text,
    sample_type character varying(200),
    experiment_id bigint NOT NULL,
    test_date timestamp without time zone,
    sample_receive_date timestamp without time zone,
    requestor character varying(200),
    bio_assay_type character varying(200) NOT NULL,
    bio_assay_platform_id bigint
);


ALTER TABLE biomart.bio_assay OWNER TO biomart;

--
-- Name: bio_assay_analysis; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_analysis (
    analysis_name character varying(500),
    short_description character varying(510),
    analysis_create_date timestamp without time zone,
    analyst_id character varying(510),
    bio_assay_analysis_id bigint NOT NULL,
    analysis_version character varying(200),
    fold_change_cutoff double precision,
    pvalue_cutoff double precision,
    rvalue_cutoff double precision,
    bio_asy_analysis_pltfm_id bigint,
    bio_source_import_id bigint,
    analysis_type character varying(200),
    analyst_name character varying(250),
    analysis_method_cd character varying(50),
    bio_assay_data_type character varying(50),
    etl_id character varying(100),
    long_description character varying(4000),
    qa_criteria character varying(4000),
    data_count bigint,
    tea_data_count bigint
);


ALTER TABLE biomart.bio_assay_analysis OWNER TO biomart;

--
-- Name: bio_assay_analysis_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_analysis_data (
    bio_asy_analysis_data_id bigint NOT NULL,
    fold_change_ratio bigint,
    raw_pvalue double precision,
    adjusted_pvalue double precision,
    r_value double precision,
    rho_value double precision,
    bio_assay_analysis_id bigint NOT NULL,
    adjusted_p_value_code character varying(100),
    feature_group_name character varying(100) NOT NULL,
    bio_experiment_id bigint,
    bio_assay_platform_id bigint,
    etl_id character varying(100),
    preferred_pvalue double precision,
    cut_value double precision,
    results_value character varying(100),
    numeric_value double precision,
    numeric_value_code character varying(50),
    tea_normalized_pvalue double precision,
    bio_assay_feature_group_id bigint
);


ALTER TABLE biomart.bio_assay_analysis_data OWNER TO biomart;

--
-- Name: bio_assay_analysis_data_tea; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_analysis_data_tea (
    bio_asy_analysis_data_id bigint NOT NULL,
    fold_change_ratio bigint,
    raw_pvalue double precision,
    adjusted_pvalue double precision,
    r_value double precision,
    rho_value double precision,
    bio_assay_analysis_id bigint NOT NULL,
    adjusted_p_value_code character varying(100),
    feature_group_name character varying(100) NOT NULL,
    bio_experiment_id bigint,
    bio_assay_platform_id bigint,
    etl_id character varying(100),
    preferred_pvalue double precision,
    cut_value double precision,
    results_value character varying(100),
    numeric_value double precision,
    numeric_value_code character varying(50),
    tea_normalized_pvalue double precision,
    bio_experiment_type character varying(50),
    bio_assay_feature_group_id bigint,
    tea_rank bigint
);


ALTER TABLE biomart.bio_assay_analysis_data_tea OWNER TO biomart;

--
-- Name: bio_assay_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_data (
    bio_sample_id bigint,
    bio_assay_data_id bigint NOT NULL,
    log2_value double precision,
    log10_value double precision,
    numeric_value bigint,
    text_value character varying(200),
    float_value double precision,
    feature_group_name character varying(100) NOT NULL,
    bio_experiment_id bigint,
    bio_assay_dataset_id bigint,
    bio_assay_id bigint,
    etl_id bigint
);


ALTER TABLE biomart.bio_assay_data OWNER TO biomart;

--
-- Name: bio_assay_data_annotation; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_data_annotation (
    bio_assay_feature_group_id bigint,
    bio_marker_id bigint NOT NULL,
    data_table character(5)
);


ALTER TABLE biomart.bio_assay_data_annotation OWNER TO biomart;

--
-- Name: bio_assay_data_stats; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_data_stats (
    bio_assay_data_stats_id bigint NOT NULL,
    bio_sample_count bigint,
    quartile_1 double precision,
    quartile_2 double precision,
    quartile_3 double precision,
    max_value double precision,
    min_value double precision,
    bio_sample_id bigint,
    feature_group_name character varying(120),
    value_normalize_method character varying(50),
    bio_experiment_id bigint,
    mean_value double precision,
    std_dev_value double precision,
    bio_assay_dataset_id bigint,
    bio_assay_feature_group_id bigint NOT NULL
);


ALTER TABLE biomart.bio_assay_data_stats OWNER TO biomart;

--
-- Name: bio_assay_data_stats_seq; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE bio_assay_data_stats_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE biomart.bio_assay_data_stats_seq OWNER TO biomart;

--
-- Name: bio_assay_dataset; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_dataset (
    bio_assay_dataset_id bigint NOT NULL,
    dataset_name character varying(400),
    dataset_description character varying(1000),
    dataset_criteria character varying(1000),
    create_date timestamp without time zone,
    bio_experiment_id bigint NOT NULL,
    bio_assay_id bigint,
    etl_id character varying(100),
    accession character varying(50)
);


ALTER TABLE biomart.bio_assay_dataset OWNER TO biomart;

--
-- Name: bio_assay_feature_group; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_feature_group (
    bio_assay_feature_group_id bigint NOT NULL,
    feature_group_name character varying(100) NOT NULL,
    feature_group_type character varying(50) NOT NULL
);


ALTER TABLE biomart.bio_assay_feature_group OWNER TO biomart;

--
-- Name: bio_assay_platform; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_platform (
    bio_assay_platform_id bigint NOT NULL,
    platform_name character varying(200),
    platform_version character varying(200),
    platform_description character varying(2000),
    platform_array character varying(50),
    platform_accession character varying(20),
    platform_organism character varying(200),
    platform_vendor character varying(200)
);


ALTER TABLE biomart.bio_assay_platform OWNER TO biomart;

--
-- Name: bio_assay_sample; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_assay_sample (
    bio_assay_id bigint NOT NULL,
    bio_sample_id bigint NOT NULL,
    bio_clinic_trial_timepoint_id bigint NOT NULL
);


ALTER TABLE biomart.bio_assay_sample OWNER TO biomart;

--
-- Name: bio_asy_analysis_dataset; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_asy_analysis_dataset (
    bio_assay_dataset_id bigint NOT NULL,
    bio_assay_analysis_id bigint NOT NULL
);


ALTER TABLE biomart.bio_asy_analysis_dataset OWNER TO biomart;

--
-- Name: bio_asy_analysis_pltfm; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_asy_analysis_pltfm (
    bio_asy_analysis_pltfm_id bigint NOT NULL,
    platform_name character varying(200),
    platform_version character varying(200),
    platform_description character varying(1000)
);


ALTER TABLE biomart.bio_asy_analysis_pltfm OWNER TO biomart;

--
-- Name: bio_asy_data_stats_all; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_asy_data_stats_all (
    bio_assay_data_stats_id bigint NOT NULL,
    bio_sample_count bigint,
    quartile_1 double precision,
    quartile_2 double precision,
    quartile_3 double precision,
    max_value double precision,
    min_value double precision,
    bio_sample_id bigint,
    feature_group_name character varying(120),
    value_normalize_method character varying(50),
    bio_experiment_id bigint,
    mean_value double precision,
    std_dev_value double precision,
    bio_assay_dataset_id bigint
);


ALTER TABLE biomart.bio_asy_data_stats_all OWNER TO biomart;

--
-- Name: bio_cell_line; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_cell_line (
    disease character varying(510),
    primary_site character varying(510),
    metastatic_site character varying(510),
    species character varying(510),
    attc_number character varying(510),
    cell_line_name character varying(510),
    bio_cell_line_id bigint NOT NULL,
    bio_disease_id bigint,
    origin character varying(200),
    description character varying(500),
    disease_stage character varying(100),
    disease_subtype character varying(200),
    etl_reference_link character varying(300)
);


ALTER TABLE biomart.bio_cell_line OWNER TO biomart;

--
-- Name: bio_cgdcp_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_cgdcp_data (
    evidence_code character varying(200),
    negation_indicator character(1),
    cell_line_id bigint,
    nci_disease_concept_code character varying(200),
    nci_role_code character varying(200),
    nci_drug_concept_code character varying(200),
    bio_data_id bigint NOT NULL
);


ALTER TABLE biomart.bio_cgdcp_data OWNER TO biomart;

--
-- Name: bio_clinc_trial_attr; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_clinc_trial_attr (
    bio_clinc_trial_attr_id bigint NOT NULL,
    property_code character varying(200) NOT NULL,
    property_value character varying(200),
    bio_experiment_id bigint NOT NULL
);


ALTER TABLE biomart.bio_clinc_trial_attr OWNER TO biomart;

--
-- Name: bio_clinc_trial_pt_group; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_clinc_trial_pt_group (
    bio_experiment_id bigint NOT NULL,
    bio_clinical_trial_p_group_id bigint NOT NULL,
    name character varying(510),
    description character varying(1000),
    number_of_patients integer,
    patient_group_type_code character varying(200)
);


ALTER TABLE biomart.bio_clinc_trial_pt_group OWNER TO biomart;

--
-- Name: bio_clinc_trial_time_pt; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_clinc_trial_time_pt (
    bio_clinc_trial_tm_pt_id bigint NOT NULL,
    time_point character varying(200),
    time_point_code character varying(200),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    bio_experiment_id bigint NOT NULL
);


ALTER TABLE biomart.bio_clinc_trial_time_pt OWNER TO biomart;

--
-- Name: bio_clinical_trial; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_clinical_trial (
    trial_number character varying(510),
    study_owner character varying(510),
    study_phase character varying(100),
    blinding_procedure character varying(1000),
    studytype character varying(510),
    duration_of_study_weeks integer,
    number_of_patients integer,
    number_of_sites integer,
    route_of_administration character varying(510),
    dosing_regimen character varying(3500),
    group_assignment character varying(510),
    type_of_control character varying(510),
    completion_date timestamp without time zone,
    primary_end_points character varying(2000),
    secondary_end_points character varying(3500),
    inclusion_criteria text,
    exclusion_criteria text,
    subjects character varying(2000),
    gender_restriction_mfb character varying(510),
    min_age integer,
    max_age integer,
    secondary_ids character varying(510),
    bio_experiment_id bigint NOT NULL,
    development_partner character varying(100),
    geo_platform character varying(30),
    main_findings character varying(2000),
    platform_name character varying(200),
    search_area character varying(100)
);


ALTER TABLE biomart.bio_clinical_trial OWNER TO biomart;

--
-- Name: bio_clinical_trial_design; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_clinical_trial_design (
    ref_id character varying(4000),
    ref_record_id character varying(4000),
    ref_back_reference character varying(4000),
    ref_article_pmid character varying(4000),
    ref_protocol_id character varying(4000),
    ref_title character varying(4000),
    study_type character varying(4000),
    common_name character varying(4000),
    icd10 character varying(4000),
    mesh character varying(4000),
    disease_type character varying(4000),
    physiology_name character varying(4000),
    trial_status character varying(4000),
    trial_phase character varying(4000),
    nature_of_trial character varying(4000),
    randomization character varying(4000),
    blinded_trial character varying(4000),
    trial_type character varying(4000),
    run_n_period character varying(4000),
    treatment_period character varying(4000),
    washout_period character varying(4000),
    open_label_extension character varying(4000),
    sponsor character varying(4000),
    trial_nbr_of_patients_studied character varying(4000),
    source_type character varying(4000),
    trial_age character varying(4000),
    disease_severity character varying(4000),
    difficult_to_treat character varying(4000),
    asthma_diagnosis character varying(4000),
    inhaled_steroid_dose character varying(4000),
    laba character varying(4000),
    ocs character varying(4000),
    xolair character varying(4000),
    ltra_inhibitors character varying(4000),
    asthma_phenotype character varying(4000),
    fev1 character varying(4000),
    fev1_reversibility character varying(4000),
    tlc character varying(4000),
    fev1_fvc character varying(4000),
    fvc character varying(4000),
    dlco character varying(4000),
    sgrq character varying(4000),
    hrct character varying(4000),
    biopsy character varying(4000),
    dyspnea_on_exertion character varying(4000),
    concomitant_med character varying(4000),
    trial_smokers_pct character varying(4000),
    trial_former_smokers_pct character varying(4000),
    trial_never_smokers_pct character varying(4000),
    trial_pack_years character varying(4000),
    exclusion_criteria character varying(4000),
    minimal_symptoms character varying(4000),
    rescue_medication_use character varying(4000),
    control_details character varying(4000),
    blinding_procedure character varying(4000),
    number_of_arms character varying(4000),
    description character varying(4000),
    arm character varying(4000),
    arm_nbr_of_patients_studied character varying(4000),
    arm_classification_type character varying(4000),
    arm_classification_value character varying(4000),
    arm_asthma_duration character varying(4000),
    arm_geographic_region character varying(4000),
    arm_age character varying(4000),
    arm_gender character varying(4000),
    arm_smokers_pct character varying(4000),
    arm_former_smokers_pct character varying(4000),
    arm_never_smokers_pct character varying(4000),
    arm_pack_years character varying(4000),
    minority_participation character varying(4000),
    baseline_symptom_score character varying(4000),
    baseline_rescue_medication_use character varying(4000),
    clinical_variable character varying(4000),
    clinical_variable_pct character varying(4000),
    clinical_variable_value character varying(4000),
    prior_med_drug_name character varying(4000),
    prior_med_pct character varying(4000),
    prior_med_value character varying(4000),
    biomarker_name character varying(4000),
    biomarker_pct character varying(4000),
    biomarkervalue character varying(4000),
    cellinfo_type character varying(4000),
    cellinfo_count character varying(4000),
    cellinfo_source character varying(4000),
    pulmonary_pathology_name character varying(4000),
    pulmpath_patient_pct character varying(4000),
    pulmpath_value_unit character varying(4000),
    pulmpath_method character varying(4000),
    runin_ocs character varying(4000),
    runin_ics character varying(4000),
    runin_laba character varying(4000),
    runin_ltra character varying(4000),
    runin_corticosteroids character varying(4000),
    runin_anti_fibrotics character varying(4000),
    runin_immunosuppressive character varying(4000),
    runin_cytotoxic character varying(4000),
    runin_description character varying(4000),
    trtmt_ocs character varying(4000),
    trtmt_ics character varying(4000),
    trtmt_laba character varying(4000),
    trtmt_ltra character varying(4000),
    trtmt_corticosteroids character varying(4000),
    trtmt_anti_fibrotics character varying(4000),
    trtmt_immunosuppressive character varying(4000),
    trtmt_cytotoxic character varying(4000),
    trtmt_description character varying(4000),
    drug_inhibitor_common_name character varying(4000),
    drug_inhibitor_standard_name character varying(4000),
    drug_inhibitor_cas_id character varying(4000),
    drug_inhibitor_dose character varying(4000),
    drug_inhibitor_route_of_admin character varying(4000),
    drug_inhibitor_trtmt_regime character varying(4000),
    comparator_name character varying(4000),
    comparator_dose character varying(4000),
    comparator_time_period character varying(4000),
    comparator_route_of_admin character varying(4000),
    treatment_regime character varying(4000),
    placebo character varying(4000),
    experiment_description character varying(4000),
    primary_endpoint_type character varying(4000),
    primary_endpoint_definition character varying(4000),
    primary_endpoint_time_period character varying(4000),
    primary_endpoint_change character varying(4000),
    primary_endpoint_p_value character varying(4000),
    primary_endpoint_stat_test character varying(4000),
    secondary_type character varying(4000),
    secondary_type_definition character varying(4000),
    secondary_type_time_period character varying(4000),
    secondary_type_change character varying(4000),
    secondary_type_p_value character varying(4000),
    secondary_type_stat_test character varying(4000),
    clinical_variable_name character varying(4000),
    pct_change_from_baseline character varying(4000),
    abs_change_from_baseline character varying(4000),
    rate_of_change_from_baseline character varying(4000),
    average_over_treatment_period character varying(4000),
    within_group_changes character varying(4000),
    stat_measure_p_value character varying(4000),
    definition_of_the_event character varying(4000),
    number_of_events character varying(4000),
    event_rate character varying(4000),
    time_to_event character varying(4000),
    event_pct_reduction character varying(4000),
    event_p_value character varying(4000),
    event_description character varying(4000),
    discontinuation_rate character varying(4000),
    response_rate character varying(4000),
    downstream_signaling_effects character varying(4000),
    beneficial_effects character varying(4000),
    adverse_effects character varying(4000),
    pk_pd_parameter character varying(4000),
    pk_pd_value character varying(4000),
    effect_description character varying(4000),
    biomolecule_name character varying(4000),
    biomolecule_id character varying(4000),
    biomolecule_type character varying(4000),
    biomarker character varying(4000),
    biomarker_type character varying(4000),
    baseline_expr_pct character varying(4000),
    baseline_expr_number character varying(4000),
    baseline_expr_value_fold_mean character varying(4000),
    baseline_expr_sd character varying(4000),
    baseline_expr_sem character varying(4000),
    baseline_expr_unit character varying(4000),
    expr_after_trtmt_pct character varying(4000),
    expr_after_trtmt_number character varying(4000),
    expr_aftertrtmt_valuefold_mean character varying(4000),
    expr_after_trtmt_sd character varying(4000),
    expr_after_trtmt_sem character varying(4000),
    expr_after_trtmt_unit character varying(4000),
    expr_chg_source_type character varying(4000),
    expr_chg_technique character varying(4000),
    expr_chg_description character varying(4000),
    clinical_correlation character varying(4000),
    statistical_test character varying(4000),
    statistical_coefficient_value character varying(4000),
    statistical_test_p_value character varying(4000),
    statistical_test_description character varying(4000)
);


ALTER TABLE biomart.bio_clinical_trial_design OWNER TO biomart;

--
-- Name: bio_compound; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_compound (
    bio_compound_id bigint NOT NULL,
    cnto_number character varying(200),
    jnj_number character varying(200),
    cas_registry character varying(400),
    code_name character varying(300),
    generic_name character varying(200),
    brand_name character varying(200),
    chemical_name character varying(1000),
    mechanism character varying(400),
    product_category character varying(200),
    description character varying(1000),
    etl_id_retired bigint,
    etl_id character varying(50),
    source_cd character varying(100)
);


ALTER TABLE biomart.bio_compound OWNER TO biomart;

--
-- Name: bio_concept_code; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_concept_code (
    bio_concept_code character varying(200),
    code_name character varying(200),
    code_description character varying(1000),
    code_type_name character varying(200),
    bio_concept_code_id bigint NOT NULL
);


ALTER TABLE biomart.bio_concept_code OWNER TO biomart;

--
-- Name: bio_content; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_content (
    bio_file_content_id bigint NOT NULL,
    file_name character varying(1000),
    repository_id bigint,
    location character varying(400),
    title character varying(1000),
    abstract character varying(2000),
    file_type character varying(200) NOT NULL,
    etl_id bigint,
    etl_id_c character varying(30),
    study_name character varying(30),
    cel_location character varying(300),
    cel_file_suffix character varying(30)
);


ALTER TABLE biomart.bio_content OWNER TO biomart;

--
-- Name: bio_content_reference; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_content_reference (
    bio_content_reference_id bigint NOT NULL,
    bio_content_id bigint NOT NULL,
    bio_data_id bigint NOT NULL,
    content_reference_type character varying(200) NOT NULL,
    etl_id bigint,
    etl_id_c character varying(30)
);


ALTER TABLE biomart.bio_content_reference OWNER TO biomart;

--
-- Name: bio_content_repository; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_content_repository (
    bio_content_repo_id bigint NOT NULL,
    location character varying(510),
    active_y_n character(1),
    repository_type character varying(200) NOT NULL,
    location_type character varying(200)
);


ALTER TABLE biomart.bio_content_repository OWNER TO biomart;

--
-- Name: bio_curated_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_curated_data (
    statement text,
    statement_status character varying(200),
    bio_data_id bigint NOT NULL,
    bio_curation_dataset_id bigint NOT NULL,
    reference_id bigint,
    data_type character varying(200)
);


ALTER TABLE biomart.bio_curated_data OWNER TO biomart;

--
-- Name: bio_curation_dataset; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_curation_dataset (
    bio_curation_dataset_id bigint NOT NULL,
    bio_asy_analysis_pltfm_id bigint,
    bio_source_import_id bigint,
    bio_curation_type character varying(200) NOT NULL,
    create_date timestamp without time zone,
    creator bigint,
    bio_curation_name character varying(500),
    data_type character varying(100)
);


ALTER TABLE biomart.bio_curation_dataset OWNER TO biomart;

--
-- Name: bio_data_attribute; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_attribute (
    bio_data_attribute_id bigint NOT NULL,
    property_code character varying(200) NOT NULL,
    property_value character varying(200),
    bio_data_id bigint NOT NULL,
    property_unit character varying(100)
);


ALTER TABLE biomart.bio_data_attribute OWNER TO biomart;

--
-- Name: bio_data_compound; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_compound (
    bio_data_id bigint NOT NULL,
    bio_compound_id bigint NOT NULL,
    etl_source character varying(100)
);


ALTER TABLE biomart.bio_data_compound OWNER TO biomart;

--
-- Name: bio_data_correl_descr; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_correl_descr (
    bio_data_correl_descr_id bigint NOT NULL,
    correlation character varying(510),
    description character varying(1000),
    type_name character varying(200),
    status character varying(200),
    source character varying(100),
    source_code character varying(200)
);


ALTER TABLE biomart.bio_data_correl_descr OWNER TO biomart;

--
-- Name: bio_data_correlation; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_correlation (
    bio_data_id bigint NOT NULL,
    asso_bio_data_id bigint NOT NULL,
    bio_data_correl_descr_id bigint NOT NULL,
    bio_data_correl_id bigint NOT NULL
);


ALTER TABLE biomart.bio_data_correlation OWNER TO biomart;

--
-- Name: bio_data_disease; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_disease (
    bio_data_id bigint NOT NULL,
    bio_disease_id bigint NOT NULL,
    etl_source character varying(100)
);


ALTER TABLE biomart.bio_data_disease OWNER TO biomart;

--
-- Name: bio_data_ext_code; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_ext_code (
    bio_data_id bigint NOT NULL,
    code character varying(500) NOT NULL,
    code_source character varying(200),
    code_type character varying(200),
    bio_data_type character varying(100),
    bio_data_ext_code_id bigint NOT NULL,
    etl_id character varying(50)
);


ALTER TABLE biomart.bio_data_ext_code OWNER TO biomart;

--
-- Name: bio_data_literature; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_literature (
    bio_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint,
    bio_curation_dataset_id bigint NOT NULL,
    statement text,
    statement_status character varying(200),
    data_type character varying(200)
);


ALTER TABLE biomart.bio_data_literature OWNER TO biomart;

--
-- Name: bio_data_omic_marker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_omic_marker (
    bio_data_id bigint,
    bio_marker_id bigint NOT NULL,
    data_table character varying(5)
);


ALTER TABLE biomart.bio_data_omic_marker OWNER TO biomart;

--
-- Name: bio_data_taxonomy; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_taxonomy (
    bio_taxonomy_id bigint NOT NULL,
    bio_data_id bigint NOT NULL,
    etl_source character varying(100)
);


ALTER TABLE biomart.bio_data_taxonomy OWNER TO biomart;

--
-- Name: bio_data_uid; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_data_uid (
    bio_data_id bigint NOT NULL,
    unique_id character varying(300) NOT NULL,
    bio_data_type character varying(100) NOT NULL
);


ALTER TABLE biomart.bio_data_uid OWNER TO biomart;

--
-- Name: bio_disease; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_disease (
    bio_disease_id bigint NOT NULL,
    disease character varying(510) NOT NULL,
    ccs_category character varying(510),
    icd10_code character varying(510),
    mesh_code character varying(510),
    icd9_code character varying(510),
    prefered_name character varying(510),
    etl_id_retired bigint,
    primary_source_cd character varying(30),
    etl_id character varying(50)
);


ALTER TABLE biomart.bio_disease OWNER TO biomart;

--
-- Name: bio_experiment; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_experiment (
    bio_experiment_id bigint NOT NULL,
    bio_experiment_type character varying(200),
    title character varying(1000),
    description character varying(2000),
    design character varying(2000),
    start_date timestamp without time zone,
    completion_date timestamp without time zone,
    primary_investigator character varying(400),
    contact_field character varying(400),
    etl_id character varying(100),
    status character varying(100),
    overall_design character varying(2000),
    accession character varying(100),
    entrydt timestamp without time zone,
    updated timestamp without time zone,
    institution character varying(100),
    country character varying(50),
    biomarker_type character varying(255),
    target character varying(255),
    access_type character varying(100)
);


ALTER TABLE biomart.bio_experiment OWNER TO biomart;

--
-- Name: bio_lit_alt_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_lit_alt_data (
    bio_lit_alt_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint NOT NULL,
    in_vivo_model_id bigint,
    in_vitro_model_id bigint,
    etl_id character varying(50),
    alteration_type character varying(50),
    control character varying(1000),
    effect character varying(500),
    description character varying(1000),
    techniques character varying(1000),
    patients_percent character varying(500),
    patients_number character varying(500),
    pop_number character varying(250),
    pop_inclusion_criteria character varying(1000),
    pop_exclusion_criteria character varying(1000),
    pop_description character varying(1000),
    pop_type character varying(250),
    pop_value character varying(250),
    pop_phase character varying(250),
    pop_status character varying(250),
    pop_experimental_model character varying(250),
    pop_tissue character varying(250),
    pop_body_substance character varying(250),
    pop_localization character varying(1000),
    pop_cell_type character varying(250),
    clin_submucosa_marker_type character varying(250),
    clin_submucosa_unit character varying(250),
    clin_submucosa_value character varying(250),
    clin_asm_marker_type character varying(250),
    clin_asm_unit character varying(250),
    clin_asm_value character varying(250),
    clin_cellular_source character varying(250),
    clin_cellular_type character varying(250),
    clin_cellular_count character varying(250),
    clin_prior_med_percent character varying(250),
    clin_prior_med_dose character varying(250),
    clin_prior_med_name character varying(250),
    clin_baseline_variable character varying(250),
    clin_baseline_percent character varying(250),
    clin_baseline_value character varying(250),
    clin_smoker character varying(250),
    clin_atopy character varying(250),
    control_exp_percent character varying(50),
    control_exp_number character varying(50),
    control_exp_value character varying(50),
    control_exp_sd character varying(50),
    control_exp_unit character varying(100),
    over_exp_percent character varying(50),
    over_exp_number character varying(50),
    over_exp_value character varying(50),
    over_exp_sd character varying(50),
    over_exp_unit character varying(100),
    loss_exp_percent character varying(50),
    loss_exp_number character varying(50),
    loss_exp_value character varying(50),
    loss_exp_sd character varying(50),
    loss_exp_unit character varying(100),
    total_exp_percent character varying(50),
    total_exp_number character varying(50),
    total_exp_value character varying(50),
    total_exp_sd character varying(50),
    total_exp_unit character varying(100),
    glc_control_percent character varying(250),
    glc_molecular_change character varying(250),
    glc_type character varying(50),
    glc_percent character varying(100),
    glc_number character varying(100),
    ptm_region character varying(250),
    ptm_type character varying(250),
    ptm_change character varying(250),
    loh_loci character varying(250),
    mutation_type character varying(250),
    mutation_change character varying(250),
    mutation_sites character varying(250),
    epigenetic_region character varying(250),
    epigenetic_type character varying(250)
);


ALTER TABLE biomart.bio_lit_alt_data OWNER TO biomart;

--
-- Name: bio_lit_amd_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_lit_amd_data (
    bio_lit_amd_data_id bigint NOT NULL,
    bio_lit_alt_data_id bigint NOT NULL,
    etl_id character varying(50),
    molecule character varying(50),
    molecule_type character varying(50),
    total_exp_percent character varying(50),
    total_exp_number character varying(100),
    total_exp_value character varying(100),
    total_exp_sd character varying(50),
    total_exp_unit character varying(50),
    over_exp_percent character varying(50),
    over_exp_number character varying(100),
    over_exp_value character varying(100),
    over_exp_sd character varying(50),
    over_exp_unit character varying(50),
    co_exp_percent character varying(50),
    co_exp_number character varying(100),
    co_exp_value character varying(100),
    co_exp_sd character varying(50),
    co_exp_unit character varying(50),
    mutation_type character varying(50),
    mutation_sites character varying(50),
    mutation_change character varying(50),
    mutation_percent character varying(50),
    mutation_number character varying(100),
    target_exp_percent character varying(50),
    target_exp_number character varying(100),
    target_exp_value character varying(100),
    target_exp_sd character varying(50),
    target_exp_unit character varying(50),
    target_over_exp_percent character varying(50),
    target_over_exp_number character varying(100),
    target_over_exp_value character varying(100),
    target_over_exp_sd character varying(50),
    target_over_exp_unit character varying(50),
    techniques character varying(250),
    description character varying(1000)
);


ALTER TABLE biomart.bio_lit_amd_data OWNER TO biomart;

--
-- Name: bio_lit_inh_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_lit_inh_data (
    bio_lit_inh_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint,
    etl_id character varying(50),
    trial_type character varying(250),
    trial_phase character varying(250),
    trial_status character varying(250),
    trial_experimental_model character varying(250),
    trial_tissue character varying(250),
    trial_body_substance character varying(250),
    trial_description character varying(1000),
    trial_designs character varying(250),
    trial_cell_line character varying(250),
    trial_cell_type character varying(250),
    trial_patients_number character varying(100),
    trial_inclusion_criteria character varying(2000),
    inhibitor character varying(250),
    inhibitor_standard_name character varying(250),
    casid character varying(250),
    description character varying(1000),
    concentration character varying(250),
    time_exposure character varying(500),
    administration character varying(250),
    treatment character varying(2000),
    techniques character varying(1000),
    effect_molecular character varying(250),
    effect_percent character varying(250),
    effect_number character varying(50),
    effect_value character varying(250),
    effect_sd character varying(250),
    effect_unit character varying(250),
    effect_response_rate character varying(250),
    effect_downstream character varying(2000),
    effect_beneficial character varying(2000),
    effect_adverse character varying(2000),
    effect_description character varying(2000),
    effect_pharmacos character varying(2000),
    effect_potentials character varying(2000)
);


ALTER TABLE biomart.bio_lit_inh_data OWNER TO biomart;

--
-- Name: bio_lit_int_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_lit_int_data (
    bio_lit_int_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint NOT NULL,
    in_vivo_model_id bigint,
    in_vitro_model_id bigint,
    etl_id character varying(50),
    source_component character varying(100),
    source_gene_id character varying(50),
    target_component character varying(100),
    target_gene_id character varying(50),
    interaction_mode character varying(250),
    regulation character varying(1000),
    mechanism character varying(250),
    effect character varying(500),
    localization character varying(500),
    region character varying(250),
    techniques character varying(1000)
);


ALTER TABLE biomart.bio_lit_int_data OWNER TO biomart;

--
-- Name: bio_lit_int_model_mv; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_lit_int_model_mv (
    bio_lit_int_data_id bigint,
    experimental_model character varying(250)
);


ALTER TABLE biomart.bio_lit_int_model_mv OWNER TO biomart;

--
-- Name: bio_lit_model_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_lit_model_data (
    bio_lit_model_data_id bigint NOT NULL,
    etl_id character varying(50),
    model_type character varying(50),
    description character varying(1000),
    stimulation character varying(1000),
    control_challenge character varying(500),
    challenge character varying(1000),
    sentization character varying(1000),
    zygosity character varying(250),
    experimental_model character varying(250),
    animal_wild_type character varying(250),
    tissue character varying(250),
    cell_type character varying(250),
    cell_line character varying(250),
    body_substance character varying(250),
    component character varying(250),
    gene_id character varying(250)
);


ALTER TABLE biomart.bio_lit_model_data OWNER TO biomart;

--
-- Name: bio_lit_int_model_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW bio_lit_int_model_view AS
 SELECT DISTINCT s.bio_lit_int_data_id, 
    s.experimental_model
   FROM (         SELECT a.bio_lit_int_data_id, 
                    b.experimental_model
                   FROM (bio_lit_int_data a
              JOIN bio_lit_model_data b ON ((a.in_vivo_model_id = b.bio_lit_model_data_id)))
             WHERE (b.experimental_model IS NOT NULL)
        UNION 
                 SELECT a.bio_lit_int_data_id, 
                    b.experimental_model
                   FROM (bio_lit_int_data a
              JOIN bio_lit_model_data b ON ((a.in_vitro_model_id = b.bio_lit_model_data_id)))
             WHERE (b.experimental_model IS NOT NULL)) s;


ALTER TABLE biomart.bio_lit_int_model_view OWNER TO biomart;

--
-- Name: bio_lit_pe_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_lit_pe_data (
    bio_lit_pe_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint NOT NULL,
    in_vivo_model_id bigint,
    in_vitro_model_id bigint,
    etl_id character varying(50),
    description character varying(2000)
);


ALTER TABLE biomart.bio_lit_pe_data OWNER TO biomart;

--
-- Name: bio_lit_ref_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_lit_ref_data (
    bio_lit_ref_data_id bigint NOT NULL,
    etl_id character varying(50),
    component character varying(100),
    component_class character varying(250),
    gene_id character varying(50),
    molecule_type character varying(50),
    variant character varying(250),
    reference_type character varying(50),
    reference_id character varying(250),
    reference_title character varying(2000),
    back_references character varying(1000),
    study_type character varying(250),
    disease character varying(250),
    disease_icd10 character varying(250),
    disease_mesh character varying(250),
    disease_site character varying(250),
    disease_stage character varying(250),
    disease_grade character varying(250),
    disease_types character varying(250),
    disease_description character varying(1000),
    physiology character varying(250),
    stat_clinical character varying(500),
    stat_clinical_correlation character varying(250),
    stat_tests character varying(500),
    stat_coefficient character varying(500),
    stat_p_value character varying(100),
    stat_description character varying(1000)
);


ALTER TABLE biomart.bio_lit_ref_data OWNER TO biomart;

--
-- Name: bio_lit_sum_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_lit_sum_data (
    bio_lit_sum_data_id bigint NOT NULL,
    etl_id character varying(50),
    disease_site character varying(250),
    target character varying(50),
    variant character varying(50),
    data_type character varying(50),
    alteration_type character varying(100),
    total_frequency character varying(50),
    total_affected_cases character varying(50),
    summary character varying(1000)
);


ALTER TABLE biomart.bio_lit_sum_data OWNER TO biomart;

--
-- Name: bio_marker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_marker (
    bio_marker_id bigint NOT NULL,
    bio_marker_name character varying(200),
    bio_marker_description character varying(1000),
    organism character varying(200),
    primary_source_code character varying(200),
    primary_external_id character varying(200),
    bio_marker_type character varying(200) NOT NULL
);


ALTER TABLE biomart.bio_marker OWNER TO biomart;

--
-- Name: bio_marker_correl_mv; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_marker_correl_mv (
    bio_marker_id bigint,
    asso_bio_marker_id bigint,
    correl_type character varying(15),
    mv_id bigint
);


ALTER TABLE biomart.bio_marker_correl_mv OWNER TO biomart;

--
-- Name: bio_marker_correl_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW bio_marker_correl_view AS
        (         SELECT DISTINCT b.bio_marker_id, 
                    b.bio_marker_id AS asso_bio_marker_id, 
                    'GENE'::text AS correl_type, 
                    1 AS mv_id
                   FROM bio_marker b
                  WHERE ((b.bio_marker_type)::text = 'GENE'::text)
        UNION 
                 SELECT DISTINCT c.bio_data_id AS bio_marker_id, 
                    c.asso_bio_data_id AS asso_bio_marker_id, 
                    'PATHWAY_GENE'::text AS correl_type, 
                    2 AS mv_id
                   FROM bio_marker b, 
                    bio_data_correlation c, 
                    bio_data_correl_descr d
                  WHERE ((((b.bio_marker_id = c.bio_data_id) AND (c.bio_data_correl_descr_id = d.bio_data_correl_descr_id)) AND ((b.primary_source_code)::text <> 'ARIADNE'::text)) AND ((d.correlation)::text = 'PATHWAY GENE'::text)))
UNION 
         SELECT DISTINCT c.bio_data_id AS bio_marker_id, 
            c.asso_bio_data_id AS asso_bio_marker_id, 
            'HOMOLOGENE_GENE'::text AS correl_type, 
            3 AS mv_id
           FROM bio_marker b, 
            bio_data_correlation c, 
            bio_data_correl_descr d
          WHERE (((b.bio_marker_id = c.bio_data_id) AND (c.bio_data_correl_descr_id = d.bio_data_correl_descr_id)) AND ((d.correlation)::text = 'HOMOLOGENE GENE'::text));


ALTER TABLE biomart.bio_marker_correl_view OWNER TO biomart;

--
-- Name: bio_marker_exp_analysis_mv; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW bio_marker_exp_analysis_mv AS
 SELECT DISTINCT t3.bio_marker_id, 
    t1.bio_experiment_id, 
    t1.bio_assay_analysis_id, 
    ((t1.bio_assay_analysis_id * 100) + t3.bio_marker_id) AS mv_id
   FROM bio_assay_analysis_data t1, 
    bio_experiment t2, 
    bio_marker t3, 
    bio_assay_data_annotation t4
  WHERE ((((t1.bio_experiment_id = t2.bio_experiment_id) AND ((t2.bio_experiment_type)::text = 'Experiment'::text)) AND (t3.bio_marker_id = t4.bio_marker_id)) AND (t1.bio_assay_feature_group_id = t4.bio_assay_feature_group_id));


ALTER TABLE biomart.bio_marker_exp_analysis_mv OWNER TO biomart;

--
-- Name: bio_patient; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_patient (
    bio_patient_id bigint NOT NULL,
    first_name character varying(200),
    last_name character varying(200),
    middle_name character varying(200),
    birth_date timestamp without time zone,
    birth_date_orig character varying(200),
    gender_code character varying(200),
    race_code character varying(200),
    ethnic_group_code character varying(200),
    address_zip_code character varying(200),
    country_code character varying(200),
    informed_consent_code character varying(200),
    bio_experiment_id bigint,
    bio_clinical_trial_p_group_id bigint
);


ALTER TABLE biomart.bio_patient OWNER TO biomart;

--
-- Name: bio_patient_event; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_patient_event (
    bio_patient_event_id bigint NOT NULL,
    bio_patient_id bigint NOT NULL,
    event_code character varying(200),
    event_type_code character varying(200),
    event_date timestamp without time zone,
    site character varying(400),
    bio_clinic_trial_timepoint_id bigint NOT NULL
);


ALTER TABLE biomart.bio_patient_event OWNER TO biomart;

--
-- Name: bio_patient_event_attr; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_patient_event_attr (
    bio_patient_attr_code character varying(200) NOT NULL,
    attribute_text_value character varying(200),
    attribute_numeric_value character varying(200),
    bio_clinic_trial_attr_id bigint NOT NULL,
    bio_patient_attribute_id bigint NOT NULL,
    bio_patient_event_id bigint NOT NULL
);


ALTER TABLE biomart.bio_patient_event_attr OWNER TO biomart;

--
-- Name: bio_sample; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_sample (
    bio_sample_id bigint NOT NULL,
    bio_sample_type character varying(200) NOT NULL,
    characteristics character varying(1000),
    source_code character varying(200),
    experiment_id bigint,
    bio_subject_id bigint,
    source character varying(200),
    bio_bank_id bigint,
    bio_patient_event_id bigint,
    bio_cell_line_id bigint,
    bio_sample_name character varying(100)
);


ALTER TABLE biomart.bio_sample OWNER TO biomart;

--
-- Name: bio_stats_exp_marker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_stats_exp_marker (
    bio_marker_id bigint NOT NULL,
    bio_experiment_id bigint NOT NULL,
    bio_stats_exp_marker_id bigint
);


ALTER TABLE biomart.bio_stats_exp_marker OWNER TO biomart;

--
-- Name: bio_subject; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_subject (
    bio_subject_id bigint NOT NULL,
    site_subject_id bigint,
    source character varying(200),
    source_code character varying(200),
    status character varying(200),
    organism character varying(200),
    bio_subject_type character varying(200) NOT NULL
);


ALTER TABLE biomart.bio_subject OWNER TO biomart;

--
-- Name: bio_taxonomy; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE bio_taxonomy (
    bio_taxonomy_id bigint NOT NULL,
    taxon_name character varying(200) NOT NULL,
    taxon_label character varying(200) NOT NULL,
    ncbi_tax_id character varying(200)
);


ALTER TABLE biomart.bio_taxonomy OWNER TO biomart;

--
-- Name: biobank_sample; Type: TABLE; Schema: biomart; Owner: biomart_user; Tablespace: 
--

CREATE TABLE biobank_sample (
    sample_tube_id character varying(255) NOT NULL,
    accession_number character varying(255) NOT NULL,
    client_sample_tube_id character varying(255) NOT NULL,
    container_id character varying(255) NOT NULL,
    import_date timestamp without time zone NOT NULL,
    source_type character varying(255) NOT NULL
);


ALTER TABLE biomart.biobank_sample OWNER TO biomart_user;

--
-- Name: ctd2_clin_inhib_effect; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd2_clin_inhib_effect (
    ctd_cie_seq bigint,
    ctd_study_id bigint,
    event_description_name character varying(4000),
    event_definition_name character varying(4000),
    adverse_effect_name character varying(4000),
    signal_effect_name character varying(4000),
    pharmaco_parameter_name character varying(500),
    discontinuation_rate_value character varying(250),
    beneficial_effect_name character varying(4000),
    drug_effect character varying(4000),
    clinical_variable_name character varying(250),
    qp_sm_percentage_change character varying(250),
    qp_sm_absolute_change character varying(250),
    qp_sm_rate_of_change character varying(250),
    qp_sm_treatment_period character varying(250),
    qp_sm_group_change character varying(250),
    qp_sm_p_value character varying(250),
    ce_sm_no character varying(250),
    ce_sm_event_rate character varying(250),
    ce_time_to_event character varying(250),
    ce_reduction character varying(250),
    ce_p_value character varying(250),
    clinical_correlation character varying(2000),
    coefficient_value character varying(250),
    statistics_p_value character varying(250),
    statistics_description character varying(4000),
    primary_endpoint_type character varying(250),
    primary_endpoint_definition character varying(4000),
    primary_endpoint_test_name character varying(2000),
    primary_endpoint_time_period character varying(2000),
    primary_endpoint_change character varying(2000),
    primary_endpoint_p_value character varying(2000),
    secondary_endpoint_type character varying(2000),
    secondary_endpoint_definition character varying(4000),
    secondary_endpoint_test_name character varying(2000),
    secondary_endpoint_time_period character varying(4000),
    secondary_endpoint_change character varying(4000),
    secondary_endpoint_p_value character varying(4000)
);


ALTER TABLE biomart.ctd2_clin_inhib_effect OWNER TO biomart;

--
-- Name: ctd2_disease; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd2_disease (
    ctd_disease_seq bigint,
    ctd_study_id bigint,
    disease_type_name character varying(500),
    disease_common_name character varying(500),
    icd10_name character varying(250),
    mesh_name character varying(250),
    study_type_name character varying(2000),
    physiology_name character varying(500)
);


ALTER TABLE biomart.ctd2_disease OWNER TO biomart;

--
-- Name: ctd2_inhib_details; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd2_inhib_details (
    ctd_inhib_seq bigint,
    ctd_study_id bigint,
    common_name_name character varying(500),
    standard_name_name character varying(500),
    experimental_detail_dose character varying(4000),
    exp_detail_exposure_period character varying(4000),
    exp_detail_treatment_name character varying(4000),
    exp_detail_admin_route character varying(4000),
    exp_detail_description character varying(4000),
    exp_detail_placebo character varying(250),
    comparator_name_name character varying(250),
    comp_treatment_name character varying(4000),
    comp_admin_route character varying(4000),
    comp_dose character varying(2000),
    comp_exposure_period character varying(2000)
);


ALTER TABLE biomart.ctd2_inhib_details OWNER TO biomart;

--
-- Name: ctd2_study; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd2_study (
    ctd_study_id bigint,
    ref_article_protocol_id character varying(1000),
    reference_id integer NOT NULL,
    pubmed_id character varying(250),
    pubmed_title character varying(2000),
    protocol_id character varying(1000),
    protocol_title character varying(2000)
);


ALTER TABLE biomart.ctd2_study OWNER TO biomart;

--
-- Name: ctd2_trial_details; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd2_trial_details (
    ctd_td_seq bigint,
    ctd_study_id bigint,
    control character varying(2000),
    blinding_procedure character varying(2000),
    no_of_arms character varying(2000),
    sponsor character varying(2000),
    patient_studied character varying(2000),
    source_type character varying(2000),
    trial_description character varying(4000),
    arm_name character varying(250),
    patient_study character varying(250),
    class_type character varying(250),
    class_value character varying(250),
    asthma_duration character varying(250),
    region character varying(250),
    age character varying(100),
    gender character varying(100),
    minor_participation character varying(100),
    symptom_score character varying(100),
    rescue_medication character varying(2000),
    therapeutic_intervention character varying(255),
    smokers character varying(255),
    former_smokers character varying(255),
    never_smokers character varying(255),
    smoking_pack_years character varying(255),
    pulm_path_name character varying(255),
    pulm_path_pct character varying(50),
    pulm_path_value character varying(50),
    pulm_path_method character varying(255),
    allow_med_therapy_ocs character varying(1000),
    allow_med_therapy_ics character varying(1000),
    allow_med_therapy_laba character varying(1000),
    allow_med_therapy_ltra character varying(1000),
    allow_med_therapy_desc character varying(4000),
    allow_med_therapy_cortster character varying(1000),
    allow_med_therapy_immuno character varying(1000),
    allow_med_therapy_cyto character varying(1000),
    allow_med_treat_ocs character varying(1000),
    allow_med_treat_ics character varying(1000),
    allow_med_treat_laba character varying(1000),
    allow_med_treat_ltra character varying(1000),
    allow_med_treat_desc character varying(4000),
    allow_med_treat_cortster character varying(1000),
    allow_med_treat_immuno character varying(1000),
    allow_med_treat_cyto character varying(1000),
    pat_char_base_clin_var character varying(500),
    pat_char_base_clin_var_pct character varying(250),
    pat_char_base_clin_var_value character varying(250),
    biomarker_name_name character varying(250),
    pat_char_biomarker_pct character varying(250),
    pat_char_biomarker_value character varying(250),
    pat_char_cellinfo_name character varying(250),
    pat_char_cellinfo_type character varying(250),
    pat_char_cellinfo_count character varying(250),
    pat_char_priormed_name character varying(250),
    pat_char_priormed_pct character varying(500),
    pat_char_priormed_dose character varying(250),
    disease_phenotype_name character varying(1000),
    disease_severity_name character varying(500),
    incl_age character varying(2000),
    incl_difficult_to_treat character varying(2000),
    incl_disease_diagnosis character varying(2000),
    incl_steroid_dose character varying(2000),
    incl_laba character varying(2000),
    incl_ocs character varying(2000),
    incl_xolair character varying(2000),
    incl_ltra_inhibitor character varying(2000),
    incl_fev1 character varying(2000),
    incl_fev1_reversibility character varying(2000),
    incl_smoking character varying(2000),
    incl_tlc character varying(2000),
    incl_fvc character varying(2000),
    incl_dlco character varying(2000),
    incl_sgrq character varying(2000),
    incl_hrct character varying(2000),
    incl_biopsy character varying(2000),
    incl_dypsnea_on_exertion character varying(2000),
    incl_concomitant_med character varying(2000),
    incl_former_smokers character varying(2000),
    incl_never_smokers character varying(2000),
    incl_smoking_pack_years character varying(2000),
    incl_fev_fvc character varying(2000),
    trial_des_minimal_symptom character varying(2000),
    trial_des_rescue_med character varying(4000),
    trial_des_exclusion_criteria character varying(4000),
    trial_des_open_label_status character varying(250),
    trial_des_random_status character varying(250),
    trial_des_nature_of_trial character varying(250),
    trial_des_blinded_status character varying(250),
    trial_des_run_in_period character varying(2000),
    trial_des_treatment character varying(2000),
    trial_des_washout_period character varying(2000),
    trial_status_name character varying(2000),
    trial_phase_name character varying(2000)
);


ALTER TABLE biomart.ctd2_trial_details OWNER TO biomart;

--
-- Name: ctd_allowed_meds_treatment; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd_allowed_meds_treatment (
    ctd_study_id bigint,
    trtmt_ocs character varying(4000),
    trtmt_ics character varying(4000),
    trtmt_laba character varying(4000),
    trtmt_ltra character varying(4000),
    trtmt_corticosteroids character varying(4000),
    trtmt_anti_fibrotics character varying(4000),
    trtmt_immunosuppressive character varying(4000),
    trtmt_cytotoxic character varying(4000)
);


ALTER TABLE biomart.ctd_allowed_meds_treatment OWNER TO biomart;

--
-- Name: ctd_full; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd_full (
    clinical_trial_design_id bigint,
    ref_article_protocol_id character varying(4000),
    ref_record_id character varying(4000),
    ref_back_reference character varying(4000),
    ref_article_pmid character varying(4000),
    ref_protocol_id character varying(4000),
    ref_title character varying(4000),
    study_type character varying(4000),
    common_name character varying(4000),
    icd10 character varying(4000),
    mesh character varying(4000),
    disease_type character varying(4000),
    physiology_name character varying(4000),
    trial_status character varying(4000),
    trial_phase character varying(4000),
    nature_of_trial character varying(4000),
    randomization character varying(4000),
    blinded_trial character varying(4000),
    trial_type character varying(4000),
    run_in_period character varying(4000),
    treatment_period character varying(4000),
    washout_period character varying(4000),
    open_label_extension character varying(4000),
    sponsor character varying(4000),
    trial_nbr_of_patients_studied character varying(4000),
    source_type character varying(4000),
    trial_age character varying(4000),
    disease_severity character varying(4000),
    difficult_to_treat character varying(4000),
    asthma_diagnosis character varying(4000),
    inhaled_steroid_dose character varying(4000),
    laba character varying(4000),
    ocs character varying(4000),
    xolair character varying(4000),
    ltra_inhibitors character varying(4000),
    asthma_phenotype character varying(4000),
    fev1 character varying(4000),
    fev1_reversibility character varying(4000),
    tlc character varying(4000),
    fev1_fvc character varying(4000),
    fvc character varying(4000),
    dlco character varying(4000),
    sgrq character varying(4000),
    hrct character varying(4000),
    biopsy character varying(4000),
    dyspnea_on_exertion character varying(4000),
    concomitant_med character varying(4000),
    trial_smokers_pct character varying(4000),
    trial_former_smokers_pct character varying(4000),
    trial_never_smokers_pct character varying(4000),
    trial_pack_years character varying(4000),
    exclusion_criteria text,
    minimal_symptoms character varying(4000),
    rescue_medication_use character varying(4000),
    control_details character varying(4000),
    blinding_procedure character varying(4000),
    number_of_arms character varying(4000),
    description text,
    arm character varying(4000),
    arm_nbr_of_patients_studied character varying(4000),
    arm_classification_type character varying(4000),
    arm_classification_value character varying(4000),
    arm_asthma_duration character varying(4000),
    arm_geographic_region character varying(4000),
    arm_age character varying(4000),
    arm_gender character varying(4000),
    arm_smokers_pct character varying(4000),
    arm_former_smokers_pct character varying(4000),
    arm_never_smokers_pct character varying(4000),
    arm_pack_years character varying(4000),
    minority_participation character varying(4000),
    baseline_symptom_score character varying(4000),
    baseline_rescue_medication_use character varying(4000),
    clinical_variable character varying(4000),
    clinical_variable_pct character varying(4000),
    clinical_variable_value character varying(4000),
    prior_med_drug_name character varying(4000),
    prior_med_pct character varying(4000),
    prior_med_value character varying(4000),
    biomarker_name character varying(4000),
    biomarker_pct character varying(4000),
    biomarker_value character varying(4000),
    cellinfo_type character varying(4000),
    cellinfo_count character varying(4000),
    cellinfo_source character varying(4000),
    pulmonary_pathology_name character varying(4000),
    pulmpath_patient_pct character varying(4000),
    pulmpath_value_unit character varying(4000),
    pulmpath_method character varying(4000),
    runin_ocs character varying(4000),
    runin_ics character varying(4000),
    runin_laba character varying(4000),
    runin_ltra character varying(4000),
    runin_corticosteroids character varying(4000),
    runin_anti_fibrotics character varying(4000),
    runin_immunosuppressive character varying(4000),
    runin_cytotoxic character varying(4000),
    runin_description character varying(4000),
    trtmt_ocs character varying(4000),
    trtmt_ics character varying(4000),
    trtmt_laba character varying(4000),
    trtmt_ltra character varying(4000),
    trtmt_corticosteroids character varying(4000),
    trtmt_anti_fibrotics character varying(4000),
    trtmt_immunosuppressive character varying(4000),
    trtmt_cytotoxic character varying(4000),
    trtmt_description character varying(4000),
    drug_inhibitor_common_name character varying(4000),
    drug_inhibitor_standard_name character varying(4000),
    drug_inhibitor_cas_id character varying(4000),
    drug_inhibitor_dose character varying(4000),
    drug_inhibitor_route_of_admin character varying(4000),
    drug_inhibitor_trtmt_regime character varying(4000),
    comparator_name character varying(4000),
    comparator_dose character varying(4000),
    comparator_time_period character varying(4000),
    comparator_route_of_admin character varying(4000),
    treatment_regime character varying(4000),
    placebo character varying(4000),
    experiment_description character varying(4000),
    primary_endpoint_type character varying(4000),
    primary_endpoint_definition character varying(4000),
    primary_endpoint_change character varying(4000),
    primary_endpoint_time_period character varying(4000),
    primary_endpoint_stat_test character varying(4000),
    primary_endpoint_p_value character varying(4000),
    secondary_type character varying(4000),
    secondary_type_definition character varying(4000),
    secondary_type_change character varying(4000),
    secondary_type_time_period character varying(4000),
    secondary_type_p_value character varying(4000),
    secondary_type_stat_test character varying(4000),
    clinical_variable_name character varying(4000),
    pct_change_from_baseline character varying(4000),
    abs_change_from_baseline character varying(4000),
    rate_of_change_from_baseline character varying(4000),
    average_over_treatment_period character varying(4000),
    within_group_changes character varying(4000),
    stat_measure_p_value character varying(4000),
    definition_of_the_event character varying(4000),
    number_of_events character varying(4000),
    event_rate character varying(4000),
    time_to_event character varying(4000),
    event_pct_reduction character varying(4000),
    event_p_value character varying(4000),
    event_description character varying(4000),
    discontinuation_rate character varying(4000),
    response_rate character varying(4000),
    downstream_signaling_effects character varying(4000),
    beneficial_effects character varying(4000),
    adverse_effects character varying(4000),
    pk_pd_parameter character varying(4000),
    pk_pd_value character varying(4000),
    effect_description character varying(4000),
    biomolecule_name character varying(4000),
    biomolecule_id character varying(4000),
    biomolecule_type character varying(4000),
    biomarker character varying(4000),
    biomarker_type character varying(4000),
    baseline_expr_pct character varying(4000),
    baseline_expr_number character varying(4000),
    baseline_expr_value_fold_mean character varying(4000),
    baseline_expr_sd character varying(4000),
    baseline_expr_sem character varying(4000),
    baseline_expr_unit character varying(4000),
    expr_after_trtmt_pct character varying(4000),
    expr_after_trtmt_number character varying(4000),
    expr_aftertrtmt_valuefold_mean character varying(4000),
    expr_after_trtmt_sd character varying(4000),
    expr_after_trtmt_sem character varying(4000),
    expr_after_trtmt_unit character varying(4000),
    expr_chg_source_type character varying(4000),
    expr_chg_technique character varying(4000),
    expr_chg_description character varying(4000),
    clinical_correlation character varying(4000),
    statistical_test character varying(4000),
    statistical_coefficient_value character varying(4000),
    statistical_test_p_value character varying(4000),
    statistical_test_description character varying(4000),
    drug_inhibitor_time_period character varying(4000)
);


ALTER TABLE biomart.ctd_full OWNER TO biomart;

--
-- Name: ctd_arm_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_arm_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.arm, v.arm_nbr_of_patients_studied) AS id, 
    v.ref_article_protocol_id, 
    v.arm, 
    v.arm_nbr_of_patients_studied, 
    v.arm_classification_type, 
    v.arm_classification_value, 
    v.arm_asthma_duration, 
    v.arm_geographic_region, 
    v.arm_age, 
    v.arm_gender, 
    v.arm_smokers_pct, 
    v.arm_former_smokers_pct, 
    v.arm_never_smokers_pct, 
    v.arm_pack_years, 
    v.minority_participation, 
    v.baseline_symptom_score, 
    v.baseline_rescue_medication_use
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.arm, 
            to_number((ctd_full.arm_nbr_of_patients_studied)::text, '999999999999999'::text) AS arm_nbr_of_patients_studied, 
            ctd_full.arm_classification_type, 
            ctd_full.arm_classification_value, 
            ctd_full.arm_asthma_duration, 
            ctd_full.arm_geographic_region, 
            ctd_full.arm_age, 
            ctd_full.arm_gender, 
            ctd_full.arm_smokers_pct, 
            ctd_full.arm_former_smokers_pct, 
            ctd_full.arm_never_smokers_pct, 
            ctd_full.arm_pack_years, 
            ctd_full.minority_participation, 
            ctd_full.baseline_symptom_score, 
            ctd_full.baseline_rescue_medication_use
           FROM ctd_full
          WHERE ((ctd_full.arm IS NOT NULL) AND ((ctd_full.arm)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.arm, to_number((ctd_full.arm_nbr_of_patients_studied)::text, '999999999999999'::text)) v;


ALTER TABLE biomart.ctd_arm_view OWNER TO biomart;

--
-- Name: ctd_biomarker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd_biomarker (
    ctd_study_id bigint,
    biomarker_name character varying(4000),
    biomarker_pct character varying(4000),
    biomarker_value character varying(4000)
);


ALTER TABLE biomart.ctd_biomarker OWNER TO biomart;

--
-- Name: ctd_biomarker_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_biomarker_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.biomarker_name) AS id, 
    v.ref_article_protocol_id, 
    v.biomarker_name, 
    v.biomarker_pct, 
    v.biomarker_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.biomarker_name, 
            ctd_full.biomarker_pct, 
            ctd_full.biomarker_value
           FROM ctd_full
          WHERE ((ctd_full.biomarker_name IS NOT NULL) AND ((ctd_full.biomarker_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.biomarker_name) v;


ALTER TABLE biomart.ctd_biomarker_view OWNER TO biomart;

--
-- Name: ctd_cell_info_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_cell_info_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.cellinfo_type) AS id, 
    v.ref_article_protocol_id, 
    v.cellinfo_type, 
    v.cellinfo_count, 
    v.cellinfo_source
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.cellinfo_type, 
            ctd_full.cellinfo_count, 
            ctd_full.cellinfo_source
           FROM ctd_full
          WHERE ((ctd_full.cellinfo_type IS NOT NULL) AND ((ctd_full.cellinfo_type)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.cellinfo_type) v;


ALTER TABLE biomart.ctd_cell_info_view OWNER TO biomart;

--
-- Name: ctd_clinical_chars_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_clinical_chars_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.clinical_variable) AS id, 
    v.ref_article_protocol_id, 
    v.clinical_variable, 
    v.clinical_variable_pct, 
    v.clinical_variable_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.clinical_variable, 
            ctd_full.clinical_variable_pct, 
            ctd_full.clinical_variable_value
           FROM ctd_full
          WHERE ((ctd_full.clinical_variable IS NOT NULL) AND ((ctd_full.clinical_variable)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.clinical_variable) v;


ALTER TABLE biomart.ctd_clinical_chars_view OWNER TO biomart;

--
-- Name: ctd_disease; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd_disease (
    ctd_study_id bigint,
    common_name character varying(4000),
    icd10 character varying(4000),
    mesh character varying(4000),
    disease_severity character varying(4000)
);


ALTER TABLE biomart.ctd_disease OWNER TO biomart;

--
-- Name: ctd_drug_effects_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_drug_effects_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.beneficial_effects, v.adverse_effects) AS id, 
    v.ref_article_protocol_id, 
    v.discontinuation_rate, 
    v.response_rate, 
    v.downstream_signaling_effects, 
    v.beneficial_effects, 
    v.adverse_effects, 
    v.pk_pd_parameter, 
    v.pk_pd_value, 
    v.effect_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.discontinuation_rate, 
            ctd_full.response_rate, 
            ctd_full.downstream_signaling_effects, 
            ctd_full.beneficial_effects, 
            ctd_full.adverse_effects, 
            ctd_full.pk_pd_parameter, 
            ctd_full.pk_pd_value, 
            ctd_full.effect_description
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.beneficial_effects, ctd_full.adverse_effects) v;


ALTER TABLE biomart.ctd_drug_effects_view OWNER TO biomart;

--
-- Name: ctd_drug_inhib; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd_drug_inhib (
    ctd_study_id bigint,
    drug_inhibitor_common_name character varying(4000),
    drug_inhibitor_standard_name character varying(4000),
    drug_inhibitor_cas_id character varying(4000)
);


ALTER TABLE biomart.ctd_drug_inhib OWNER TO biomart;

--
-- Name: ctd_drug_inhibitor_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_drug_inhibitor_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.drug_inhibitor_common_name) AS id, 
    v.ref_article_protocol_id, 
    v.drug_inhibitor_common_name, 
    v.drug_inhibitor_standard_name, 
    v.drug_inhibitor_cas_id
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.drug_inhibitor_common_name, 
            ctd_full.drug_inhibitor_standard_name, 
            ctd_full.drug_inhibitor_cas_id
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.drug_inhibitor_common_name) v;


ALTER TABLE biomart.ctd_drug_inhibitor_view OWNER TO biomart;

--
-- Name: ctd_events_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_events_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.definition_of_the_event) AS id, 
    v.ref_article_protocol_id, 
    v.definition_of_the_event, 
    v.number_of_events, 
    v.event_rate, 
    v.time_to_event, 
    v.event_pct_reduction, 
    v.event_p_value, 
    v.event_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.definition_of_the_event, 
            ctd_full.number_of_events, 
            ctd_full.event_rate, 
            ctd_full.time_to_event, 
            ctd_full.event_pct_reduction, 
            ctd_full.event_p_value, 
            ctd_full.event_description
           FROM ctd_full
          WHERE (((ctd_full.definition_of_the_event IS NOT NULL) AND ((ctd_full.definition_of_the_event)::text <> ''::text)) OR ((ctd_full.event_description IS NOT NULL) AND ((ctd_full.event_description)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.definition_of_the_event) v;


ALTER TABLE biomart.ctd_events_view OWNER TO biomart;

--
-- Name: ctd_experiments_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_experiments_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.drug_inhibitor_common_name, v.drug_inhibitor_trtmt_regime) AS id, 
    v.ref_article_protocol_id, 
    v.drug_inhibitor_common_name, 
    v.drug_inhibitor_dose, 
    v.drug_inhibitor_time_period, 
    v.drug_inhibitor_route_of_admin, 
    v.drug_inhibitor_trtmt_regime, 
    v.comparator_name, 
    v.comparator_dose, 
    v.comparator_time_period, 
    v.comparator_route_of_admin, 
    v.treatment_regime, 
    v.placebo, 
    v.experiment_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.drug_inhibitor_common_name, 
            ctd_full.drug_inhibitor_time_period, 
            ctd_full.drug_inhibitor_dose, 
            ctd_full.drug_inhibitor_route_of_admin, 
            ctd_full.drug_inhibitor_trtmt_regime, 
            ctd_full.comparator_name, 
            ctd_full.comparator_dose, 
            ctd_full.comparator_time_period, 
            ctd_full.comparator_route_of_admin, 
            ctd_full.treatment_regime, 
            ctd_full.placebo, 
            ctd_full.experiment_description
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.drug_inhibitor_common_name, ctd_full.drug_inhibitor_trtmt_regime) v;


ALTER TABLE biomart.ctd_experiments_view OWNER TO biomart;

--
-- Name: ctd_expr_after_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_expr_after_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.biomolecule_name) AS id, 
    v.ref_article_protocol_id, 
    v.biomolecule_name, 
    v.expr_after_trtmt_pct, 
    v.expr_after_trtmt_number, 
    v.expr_aftertrtmt_valuefold_mean, 
    v.expr_after_trtmt_sd, 
    v.expr_after_trtmt_sem, 
    v.expr_after_trtmt_unit
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.biomolecule_name, 
            ctd_full.expr_after_trtmt_pct, 
            ctd_full.expr_after_trtmt_number, 
            ctd_full.expr_aftertrtmt_valuefold_mean, 
            ctd_full.expr_after_trtmt_sd, 
            ctd_full.expr_after_trtmt_sem, 
            ctd_full.expr_after_trtmt_unit
           FROM ctd_full
          WHERE (((ctd_full.biomolecule_name IS NOT NULL) AND ((ctd_full.biomolecule_name)::text <> ''::text)) OR ((ctd_full.expr_aftertrtmt_valuefold_mean IS NOT NULL) AND ((ctd_full.expr_aftertrtmt_valuefold_mean)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.biomolecule_name) v;


ALTER TABLE biomart.ctd_expr_after_view OWNER TO biomart;

--
-- Name: ctd_expr_baseline_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_expr_baseline_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.biomolecule_name) AS id, 
    v.ref_article_protocol_id, 
    v.biomolecule_name, 
    v.baseline_expr_pct, 
    v.baseline_expr_number, 
    v.baseline_expr_value_fold_mean, 
    v.baseline_expr_sd, 
    v.baseline_expr_sem, 
    v.baseline_expr_unit
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.biomolecule_name, 
            ctd_full.baseline_expr_pct, 
            ctd_full.baseline_expr_number, 
            ctd_full.baseline_expr_value_fold_mean, 
            ctd_full.baseline_expr_sd, 
            ctd_full.baseline_expr_sem, 
            ctd_full.baseline_expr_unit
           FROM ctd_full
          WHERE (((ctd_full.biomolecule_name IS NOT NULL) AND ((ctd_full.biomolecule_name)::text <> ''::text)) OR ((ctd_full.baseline_expr_value_fold_mean IS NOT NULL) AND ((ctd_full.baseline_expr_value_fold_mean)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.biomolecule_name) v;


ALTER TABLE biomart.ctd_expr_baseline_view OWNER TO biomart;

--
-- Name: ctd_expr_bio_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_expr_bio_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.biomolecule_name) AS id, 
    v.ref_article_protocol_id, 
    v.biomolecule_name, 
    v.biomolecule_id, 
    v.biomolecule_type, 
    v.biomarker, 
    v.biomarker_type
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.biomolecule_name, 
            ctd_full.biomolecule_id, 
            ctd_full.biomolecule_type, 
            ctd_full.biomarker, 
            ctd_full.biomarker_type
           FROM ctd_full
          WHERE (((ctd_full.biomolecule_name IS NOT NULL) AND ((ctd_full.biomolecule_name)::text <> ''::text)) OR ((ctd_full.biomolecule_id IS NOT NULL) AND ((ctd_full.biomolecule_id)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.biomolecule_name) v;


ALTER TABLE biomart.ctd_expr_bio_view OWNER TO biomart;

--
-- Name: ctd_expr_source_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_expr_source_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.expr_chg_source_type) AS id, 
    v.ref_article_protocol_id, 
    v.expr_chg_source_type, 
    v.expr_chg_technique, 
    v.expr_chg_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.expr_chg_source_type, 
            ctd_full.expr_chg_technique, 
            ctd_full.expr_chg_description
           FROM ctd_full
          WHERE (((ctd_full.expr_chg_source_type IS NOT NULL) AND ((ctd_full.expr_chg_source_type)::text <> ''::text)) OR ((ctd_full.expr_chg_description IS NOT NULL) AND ((ctd_full.expr_chg_description)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.expr_chg_source_type) v;


ALTER TABLE biomart.ctd_expr_source_view OWNER TO biomart;

--
-- Name: ctd_full_clinical_endpts_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_full_clinical_endpts_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id) AS id, 
    v.ref_article_protocol_id, 
    v.primary_endpoint_type, 
    v.primary_endpoint_definition, 
    v.primary_endpoint_change, 
    v.primary_endpoint_time_period, 
    v.primary_endpoint_p_value, 
    v.primary_endpoint_stat_test, 
    v.secondary_type, 
    v.secondary_type_definition, 
    v.secondary_type_change, 
    v.secondary_type_time_period, 
    v.secondary_type_p_value, 
    v.secondary_type_stat_test
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.primary_endpoint_type, 
            ctd_full.primary_endpoint_definition, 
            ctd_full.primary_endpoint_change, 
            ctd_full.primary_endpoint_time_period, 
            ctd_full.primary_endpoint_p_value, 
            ctd_full.primary_endpoint_stat_test, 
            ctd_full.secondary_type, 
            ctd_full.secondary_type_definition, 
            ctd_full.secondary_type_change, 
            ctd_full.secondary_type_time_period, 
            ctd_full.secondary_type_p_value, 
            ctd_full.secondary_type_stat_test
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id) v;


ALTER TABLE biomart.ctd_full_clinical_endpts_view OWNER TO biomart;

--
-- Name: ctd_full_search_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_full_search_view AS
 SELECT row_number() OVER (ORDER BY t.ref_article_protocol_id) AS fact_id, 
    t.ref_article_protocol_id, 
    t.mesh, 
    t.common_name, 
    t.drug_inhibitor_standard_name, 
    t.primary_endpoint_type, 
    t.secondary_type, 
    t.biomarker_name, 
    t.disease_severity, 
    t.inhaled_steroid_dose, 
    t.fev1, 
    t.primary_endpoint_time_period, 
    t.primary_endpoint_change, 
    t.primary_endpoint_p_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.mesh, 
            ctd_full.common_name, 
            ctd_full.drug_inhibitor_standard_name, 
            ctd_full.primary_endpoint_type, 
            ctd_full.secondary_type, 
            ctd_full.biomarker_name, 
            ctd_full.disease_severity, 
            ctd_full.inhaled_steroid_dose, 
            ctd_full.fev1, 
            ctd_full.primary_endpoint_time_period, 
            ctd_full.primary_endpoint_change, 
            ctd_full.primary_endpoint_p_value
           FROM ctd_full) t;


ALTER TABLE biomart.ctd_full_search_view OWNER TO biomart;

--
-- Name: ctd_inclusion_criteria; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd_inclusion_criteria (
    ctd_study_id bigint,
    inhaled_steroid_dose character varying(4000),
    laba character varying(4000),
    ocs character varying(4000),
    xolair character varying(4000),
    ltra_inhibitors character varying(4000),
    asthma_phenotype character varying(4000),
    fev1 character varying(4000)
);


ALTER TABLE biomart.ctd_inclusion_criteria OWNER TO biomart;

--
-- Name: ctd_primary_endpts; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd_primary_endpts (
    ctd_study_id bigint,
    primary_type character varying(4000),
    primary_type_definition character varying(4000),
    primary_type_time_period character varying(4000),
    primary_type_change character varying(4000),
    primary_type_p_value character varying(4000),
    id bigint
);


ALTER TABLE biomart.ctd_primary_endpts OWNER TO biomart;

--
-- Name: ctd_primary_endpts_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_primary_endpts_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.primary_endpoint_type) AS id, 
    v.ref_article_protocol_id, 
    v.primary_endpoint_type, 
    v.primary_endpoint_definition, 
    v.primary_endpoint_change, 
    v.primary_endpoint_time_period, 
    v.primary_endpoint_p_value, 
    v.primary_endpoint_stat_test
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.primary_endpoint_type, 
            ctd_full.primary_endpoint_definition, 
            ctd_full.primary_endpoint_change, 
            ctd_full.primary_endpoint_time_period, 
            ctd_full.primary_endpoint_p_value, 
            ctd_full.primary_endpoint_stat_test
           FROM ctd_full
          WHERE (((ctd_full.primary_endpoint_type IS NOT NULL) AND ((ctd_full.primary_endpoint_type)::text <> ''::text)) OR ((ctd_full.primary_endpoint_definition IS NOT NULL) AND ((ctd_full.primary_endpoint_definition)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.primary_endpoint_type) v;


ALTER TABLE biomart.ctd_primary_endpts_view OWNER TO biomart;

--
-- Name: ctd_prior_med_use_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_prior_med_use_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.prior_med_drug_name) AS id, 
    v.ref_article_protocol_id, 
    v.prior_med_drug_name, 
    v.prior_med_pct, 
    v.prior_med_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.prior_med_drug_name, 
            ctd_full.prior_med_pct, 
            ctd_full.prior_med_value
           FROM ctd_full
          WHERE ((ctd_full.prior_med_drug_name IS NOT NULL) AND ((ctd_full.prior_med_drug_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.prior_med_drug_name) v;


ALTER TABLE biomart.ctd_prior_med_use_view OWNER TO biomart;

--
-- Name: ctd_pulmonary_path_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_pulmonary_path_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.pulmonary_pathology_name) AS id, 
    v.ref_article_protocol_id, 
    v.pulmonary_pathology_name, 
    v.pulmpath_patient_pct, 
    v.pulmpath_value_unit, 
    v.pulmpath_method
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.pulmonary_pathology_name, 
            ctd_full.pulmpath_patient_pct, 
            ctd_full.pulmpath_value_unit, 
            ctd_full.pulmpath_method
           FROM ctd_full
          WHERE ((ctd_full.pulmonary_pathology_name IS NOT NULL) AND ((ctd_full.pulmonary_pathology_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.pulmonary_pathology_name) v;


ALTER TABLE biomart.ctd_pulmonary_path_view OWNER TO biomart;

--
-- Name: ctd_quant_params_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_quant_params_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id) AS id, 
    v.ref_article_protocol_id, 
    v.clinical_variable_name, 
    v.pct_change_from_baseline, 
    v.abs_change_from_baseline, 
    v.rate_of_change_from_baseline, 
    v.average_over_treatment_period, 
    v.within_group_changes, 
    v.stat_measure_p_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.clinical_variable_name, 
            ctd_full.pct_change_from_baseline, 
            ctd_full.abs_change_from_baseline, 
            ctd_full.rate_of_change_from_baseline, 
            ctd_full.average_over_treatment_period, 
            ctd_full.within_group_changes, 
            ctd_full.stat_measure_p_value
           FROM ctd_full
          WHERE ((ctd_full.clinical_variable_name IS NOT NULL) AND ((ctd_full.clinical_variable_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id) v;


ALTER TABLE biomart.ctd_quant_params_view OWNER TO biomart;

--
-- Name: ctd_reference_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_reference_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.ref_record_id) AS id, 
    v.ref_article_protocol_id, 
    v.ref_article_pmid, 
    v.ref_protocol_id, 
    v.ref_title, 
    v.ref_record_id, 
    v.ref_back_reference
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.ref_article_pmid, 
            ctd_full.ref_protocol_id, 
            ctd_full.ref_title, 
            ctd_full.ref_record_id, 
            ctd_full.ref_back_reference
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.ref_record_id) v;


ALTER TABLE biomart.ctd_reference_view OWNER TO biomart;

--
-- Name: ctd_runin_therapies_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_runin_therapies_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.runin_description) AS id, 
    v.ref_article_protocol_id, 
    v.runin_ocs, 
    v.runin_ics, 
    v.runin_laba, 
    v.runin_ltra, 
    v.runin_corticosteroids, 
    v.runin_anti_fibrotics, 
    v.runin_immunosuppressive, 
    v.runin_cytotoxic, 
    v.runin_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.runin_ocs, 
            ctd_full.runin_ics, 
            ctd_full.runin_laba, 
            ctd_full.runin_ltra, 
            ctd_full.runin_corticosteroids, 
            ctd_full.runin_anti_fibrotics, 
            ctd_full.runin_immunosuppressive, 
            ctd_full.runin_cytotoxic, 
            ctd_full.runin_description
           FROM ctd_full
          WHERE ((((ctd_full.runin_ocs IS NOT NULL) AND ((ctd_full.runin_ocs)::text <> ''::text)) OR ((ctd_full.runin_description IS NOT NULL) AND ((ctd_full.runin_description)::text <> ''::text))) OR ((ctd_full.runin_immunosuppressive IS NOT NULL) AND ((ctd_full.runin_immunosuppressive)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.runin_description) v;


ALTER TABLE biomart.ctd_runin_therapies_view OWNER TO biomart;

--
-- Name: ctd_sec_endpts; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd_sec_endpts (
    ctd_study_id bigint,
    secondary_type character varying(4000),
    secondary_type_definition character varying(4000),
    secondary_type_time_period character varying(4000),
    secondary_type_change character varying(4000),
    secondary_type_p_value character varying(4000),
    id bigint
);


ALTER TABLE biomart.ctd_sec_endpts OWNER TO biomart;

--
-- Name: ctd_secondary_endpts_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_secondary_endpts_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.secondary_type) AS id, 
    v.ref_article_protocol_id, 
    v.secondary_type, 
    v.secondary_type_definition, 
    v.secondary_type_change, 
    v.secondary_type_time_period, 
    v.secondary_type_p_value, 
    v.secondary_type_stat_test
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.secondary_type, 
            ctd_full.secondary_type_definition, 
            ctd_full.secondary_type_change, 
            ctd_full.secondary_type_time_period, 
            ctd_full.secondary_type_p_value, 
            ctd_full.secondary_type_stat_test
           FROM ctd_full
          WHERE (((ctd_full.secondary_type IS NOT NULL) AND ((ctd_full.secondary_type)::text <> ''::text)) OR ((ctd_full.secondary_type_definition IS NOT NULL) AND ((ctd_full.secondary_type_definition)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.secondary_type) v;


ALTER TABLE biomart.ctd_secondary_endpts_view OWNER TO biomart;

--
-- Name: ctd_stats_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_stats_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.statistical_test) AS id, 
    v.ref_article_protocol_id, 
    v.clinical_correlation, 
    v.statistical_test, 
    v.statistical_coefficient_value, 
    v.statistical_test_p_value, 
    v.statistical_test_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.clinical_correlation, 
            ctd_full.statistical_test, 
            ctd_full.statistical_coefficient_value, 
            ctd_full.statistical_test_p_value, 
            ctd_full.statistical_test_description
           FROM ctd_full
          WHERE (((ctd_full.statistical_test_description IS NOT NULL) AND ((ctd_full.statistical_test_description)::text <> ''::text)) OR ((ctd_full.statistical_test IS NOT NULL) AND ((ctd_full.statistical_test)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.statistical_test) v;


ALTER TABLE biomart.ctd_stats_view OWNER TO biomart;

--
-- Name: ctd_study; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE ctd_study (
    ctd_study_id bigint,
    ref_article_protocol_id character varying(4000),
    ref_article_pmid character varying(4000),
    ref_protocol_id character varying(4000)
);


ALTER TABLE biomart.ctd_study OWNER TO biomart;

--
-- Name: ctd_study_details_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_study_details_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.common_name) AS id, 
    v.ref_article_protocol_id, 
    v.study_type, 
    v.common_name, 
    v.icd10, 
    v.mesh, 
    v.disease_type, 
    v.physiology_name
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.study_type, 
            ctd_full.common_name, 
            ctd_full.icd10, 
            ctd_full.mesh, 
            ctd_full.disease_type, 
            ctd_full.physiology_name
           FROM ctd_full
          WHERE ((ctd_full.common_name IS NOT NULL) AND ((ctd_full.common_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.common_name) v;


ALTER TABLE biomart.ctd_study_details_view OWNER TO biomart;

--
-- Name: ctd_td_design_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_design_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.nature_of_trial, v.trial_type) AS id, 
    v.ref_article_protocol_id, 
    v.nature_of_trial, 
    v.randomization, 
    v.blinded_trial, 
    v.trial_type, 
    v.run_in_period, 
    v.treatment_period, 
    v.washout_period, 
    v.open_label_extension
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.nature_of_trial, 
            ctd_full.randomization, 
            ctd_full.blinded_trial, 
            ctd_full.trial_type, 
            ctd_full.run_in_period, 
            ctd_full.treatment_period, 
            ctd_full.washout_period, 
            ctd_full.open_label_extension
           FROM ctd_full
          WHERE (((ctd_full.trial_type IS NOT NULL) AND ((ctd_full.trial_type)::text <> ''::text)) OR ((ctd_full.nature_of_trial IS NOT NULL) AND ((ctd_full.nature_of_trial)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.nature_of_trial, ctd_full.trial_type) v;


ALTER TABLE biomart.ctd_td_design_view OWNER TO biomart;

--
-- Name: ctd_td_excl_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_excl_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id) AS id, 
    v.ref_article_protocol_id, 
    v.exclusion_criteria1, 
    v.exclusion_criteria2, 
    v.minimal_symptoms, 
    v.rescue_medication_use, 
    v.control_details, 
    v.blinding_procedure, 
    v.number_of_arms, 
    v.description1, 
    v.description2
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            "substring"(ctd_full.exclusion_criteria, 1, 4000) AS exclusion_criteria1, 
            "substring"(ctd_full.exclusion_criteria, 4001, 2000) AS exclusion_criteria2, 
            ctd_full.minimal_symptoms, 
            ctd_full.rescue_medication_use, 
            ctd_full.control_details, 
            ctd_full.blinding_procedure, 
            ctd_full.number_of_arms, 
            "substring"(ctd_full.description, 1, 4000) AS description1, 
            "substring"(ctd_full.description, 4001, 2000) AS description2
           FROM ctd_full
          WHERE (((ctd_full.blinding_procedure IS NOT NULL) AND ((ctd_full.blinding_procedure)::text <> ''::text)) OR ((ctd_full.number_of_arms IS NOT NULL) AND ((ctd_full.number_of_arms)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id) v;


ALTER TABLE biomart.ctd_td_excl_view OWNER TO biomart;

--
-- Name: ctd_td_inclusion_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_inclusion_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.disease_severity, v.fev1) AS id, 
    v.ref_article_protocol_id, 
    v.trial_age, 
    v.disease_severity, 
    v.difficult_to_treat, 
    v.asthma_diagnosis, 
    v.inhaled_steroid_dose, 
    v.laba, 
    v.ocs, 
    v.xolair, 
    v.ltra_inhibitors, 
    v.asthma_phenotype, 
    v.fev1, 
    v.fev1_reversibility, 
    v.tlc, 
    v.fev1_fvc, 
    v.fvc, 
    v.dlco, 
    v.sgrq, 
    v.hrct, 
    v.biopsy, 
    v.dyspnea_on_exertion, 
    v.concomitant_med
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.trial_age, 
            ctd_full.disease_severity, 
            ctd_full.difficult_to_treat, 
            ctd_full.asthma_diagnosis, 
            ctd_full.inhaled_steroid_dose, 
            ctd_full.laba, 
            ctd_full.ocs, 
            ctd_full.xolair, 
            ctd_full.ltra_inhibitors, 
            ctd_full.asthma_phenotype, 
            ctd_full.fev1, 
            ctd_full.fev1_reversibility, 
            ctd_full.tlc, 
            ctd_full.fev1_fvc, 
            ctd_full.fvc, 
            ctd_full.dlco, 
            ctd_full.sgrq, 
            ctd_full.hrct, 
            ctd_full.biopsy, 
            ctd_full.dyspnea_on_exertion, 
            ctd_full.concomitant_med
           FROM ctd_full
          WHERE ((((ctd_full.fev1 IS NOT NULL) AND ((ctd_full.fev1)::text <> ''::text)) OR ((ctd_full.disease_severity IS NOT NULL) AND ((ctd_full.disease_severity)::text <> ''::text))) OR ((ctd_full.trial_age IS NOT NULL) AND ((ctd_full.trial_age)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.disease_severity, ctd_full.fev1) v;


ALTER TABLE biomart.ctd_td_inclusion_view OWNER TO biomart;

--
-- Name: ctd_td_smoker_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_smoker_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.trial_smokers_pct) AS id, 
    v.ref_article_protocol_id, 
    v.trial_smokers_pct, 
    v.trial_former_smokers_pct, 
    v.trial_never_smokers_pct, 
    v.trial_pack_years
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.trial_smokers_pct, 
            ctd_full.trial_former_smokers_pct, 
            ctd_full.trial_never_smokers_pct, 
            ctd_full.trial_pack_years
           FROM ctd_full
          WHERE (((ctd_full.trial_smokers_pct IS NOT NULL) AND ((ctd_full.trial_smokers_pct)::text <> ''::text)) OR ((ctd_full.trial_never_smokers_pct IS NOT NULL) AND ((ctd_full.trial_never_smokers_pct)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.trial_smokers_pct) v;


ALTER TABLE biomart.ctd_td_smoker_view OWNER TO biomart;

--
-- Name: ctd_td_sponsor_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_sponsor_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.sponsor, v.trial_nbr_of_patients_studied) AS id, 
    v.ref_article_protocol_id, 
    v.sponsor, 
    v.trial_nbr_of_patients_studied, 
    v.source_type
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.sponsor, 
            ctd_full.trial_nbr_of_patients_studied, 
            ctd_full.source_type
           FROM ctd_full
          WHERE (((ctd_full.sponsor IS NOT NULL) AND ((ctd_full.sponsor)::text <> ''::text)) OR ((ctd_full.trial_nbr_of_patients_studied IS NOT NULL) AND ((ctd_full.trial_nbr_of_patients_studied)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.sponsor, ctd_full.trial_nbr_of_patients_studied) v;


ALTER TABLE biomart.ctd_td_sponsor_view OWNER TO biomart;

--
-- Name: ctd_td_status_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_status_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id) AS id, 
    v.ref_article_protocol_id, 
    v.trial_status, 
    v.trial_phase
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.trial_status, 
            ctd_full.trial_phase
           FROM ctd_full
          WHERE (((ctd_full.trial_status IS NOT NULL) AND ((ctd_full.trial_status)::text <> ''::text)) OR ((ctd_full.trial_phase IS NOT NULL) AND ((ctd_full.trial_phase)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id) v;


ALTER TABLE biomart.ctd_td_status_view OWNER TO biomart;

--
-- Name: ctd_treatment_phases_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_treatment_phases_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.trtmt_description, v.trtmt_ocs) AS id, 
    v.ref_article_protocol_id, 
    v.trtmt_ocs, 
    v.trtmt_ics, 
    v.trtmt_laba, 
    v.trtmt_ltra, 
    v.trtmt_corticosteroids, 
    v.trtmt_anti_fibrotics, 
    v.trtmt_immunosuppressive, 
    v.trtmt_cytotoxic, 
    v.trtmt_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.trtmt_ocs, 
            ctd_full.trtmt_ics, 
            ctd_full.trtmt_laba, 
            ctd_full.trtmt_ltra, 
            ctd_full.trtmt_corticosteroids, 
            ctd_full.trtmt_anti_fibrotics, 
            ctd_full.trtmt_immunosuppressive, 
            ctd_full.trtmt_cytotoxic, 
            ctd_full.trtmt_description
           FROM ctd_full
          WHERE ((((ctd_full.trtmt_ocs IS NOT NULL) AND ((ctd_full.trtmt_ocs)::text <> ''::text)) OR ((ctd_full.trtmt_description IS NOT NULL) AND ((ctd_full.trtmt_description)::text <> ''::text))) OR ((ctd_full.trtmt_immunosuppressive IS NOT NULL) AND ((ctd_full.trtmt_immunosuppressive)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.trtmt_description, ctd_full.trtmt_ocs) v;


ALTER TABLE biomart.ctd_treatment_phases_view OWNER TO biomart;

--
-- Name: hibernate_sequence; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE hibernate_sequence
    START WITH 226
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE biomart.hibernate_sequence OWNER TO biomart;

--
-- Name: seq_bio_data_fact_id; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE seq_bio_data_fact_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE biomart.seq_bio_data_fact_id OWNER TO biomart;

--
-- Name: seq_bio_data_id; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE seq_bio_data_id
    START WITH 1082041
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE biomart.seq_bio_data_id OWNER TO biomart;

--
-- Name: seq_clinical_trial_design_id; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE seq_clinical_trial_design_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE biomart.seq_clinical_trial_design_id OWNER TO biomart;

--
-- Name: tmp_analysis_data_tea_rank; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE TABLE tmp_analysis_data_tea_rank (
    analysis_data_id bigint NOT NULL,
    analysis_id bigint NOT NULL,
    rank1 bigint
);


ALTER TABLE biomart.tmp_analysis_data_tea_rank OWNER TO biomart;

SET search_path = deapp, pg_catalog;

--
-- Name: de_chromosomal_region; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_chromosomal_region (
    region_id bigint NOT NULL,
    gpl_id character varying(50),
    chromosome character varying(2),
    start_bp bigint,
    end_bp bigint,
    num_probes integer,
    region_name character varying(100),
    gene_symbol character varying(100),
    gene_id bigint,
    organism character varying(200)
);


ALTER TABLE deapp.de_chromosomal_region OWNER TO deapp;

--
-- Name: de_chromosomal_region_region_id_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_chromosomal_region_region_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_chromosomal_region_region_id_seq OWNER TO deapp;

--
-- Name: de_chromosomal_region_region_id_seq; Type: SEQUENCE OWNED BY; Schema: deapp; Owner: deapp
--

ALTER SEQUENCE de_chromosomal_region_region_id_seq OWNED BY de_chromosomal_region.region_id;


--
-- Name: de_gpl_info; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_gpl_info (
    platform character varying(50) NOT NULL,
    title character varying(500),
    organism character varying(100),
    annotation_date timestamp without time zone,
    marker_type character varying(100),
    genome_build character varying(20),
    release_nbr numeric
);


ALTER TABLE deapp.de_gpl_info OWNER TO deapp;

--
-- Name: de_mrna_annotation; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_mrna_annotation (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(100),
    probeset_id bigint,
    gene_id bigint,
    organism character varying(200)
);


ALTER TABLE deapp.de_mrna_annotation OWNER TO deapp;

--
-- Name: de_parent_cd_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_parent_cd_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE deapp.de_parent_cd_seq OWNER TO deapp;

--
-- Name: de_pathway; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_pathway (
    name character varying(300),
    description character varying(510),
    id bigint NOT NULL,
    type character varying(100),
    source character varying(100),
    externalid character varying(100),
    pathway_uid character varying(200),
    user_id bigint
);


ALTER TABLE deapp.de_pathway OWNER TO deapp;

--
-- Name: de_pathway_gene; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_pathway_gene (
    id bigint NOT NULL,
    pathway_id bigint,
    gene_symbol character varying(200),
    gene_id character varying(200)
);


ALTER TABLE deapp.de_pathway_gene OWNER TO deapp;

--
-- Name: de_saved_comparison; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_saved_comparison (
    comparison_id bigint NOT NULL,
    query_id1 bigint,
    query_id2 bigint
);


ALTER TABLE deapp.de_saved_comparison OWNER TO deapp;

--
-- Name: de_snp_calls_by_gsm; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_calls_by_gsm (
    gsm_num character varying(10),
    patient_num bigint,
    snp_name character varying(100),
    snp_calls character varying(4)
);


ALTER TABLE deapp.de_snp_calls_by_gsm OWNER TO deapp;

--
-- Name: de_snp_copy_number; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_copy_number (
    patient_num bigint,
    snp_name character varying(50),
    chrom character varying(2),
    chrom_pos bigint,
    copy_number smallint
);


ALTER TABLE deapp.de_snp_copy_number OWNER TO deapp;

--
-- Name: de_snp_data_by_patient; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_data_by_patient (
    snp_data_by_patient_id bigint NOT NULL,
    snp_dataset_id bigint,
    trial_name character varying(255),
    patient_num bigint,
    chrom character varying(16),
    data_by_patient_chr text,
    ped_by_patient_chr text
);


ALTER TABLE deapp.de_snp_data_by_patient OWNER TO deapp;

--
-- Name: de_snp_data_by_probe; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_data_by_probe (
    snp_data_by_probe_id bigint NOT NULL,
    probe_id bigint,
    probe_name character varying(255),
    snp_id bigint,
    snp_name character varying(255),
    trial_name character varying(255),
    data_by_probe text
);


ALTER TABLE deapp.de_snp_data_by_probe OWNER TO deapp;

--
-- Name: de_snp_data_dataset_loc; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_data_dataset_loc (
    snp_data_dataset_loc_id bigint,
    trial_name character varying(255),
    snp_dataset_id bigint,
    location bigint
);


ALTER TABLE deapp.de_snp_data_dataset_loc OWNER TO deapp;

--
-- Name: de_snp_gene_map; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_gene_map (
    snp_id bigint,
    snp_name character varying(255),
    entrez_gene_id bigint
);


ALTER TABLE deapp.de_snp_gene_map OWNER TO deapp;

--
-- Name: de_snp_info; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_info (
    snp_info_id bigint NOT NULL,
    name character varying(255),
    chrom character varying(16),
    chrom_pos bigint
);


ALTER TABLE deapp.de_snp_info OWNER TO deapp;

--
-- Name: de_snp_probe; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_probe (
    snp_probe_id bigint NOT NULL,
    probe_name character varying(255),
    snp_id bigint,
    snp_name character varying(255),
    vendor_name character varying(255)
);


ALTER TABLE deapp.de_snp_probe OWNER TO deapp;

--
-- Name: de_snp_probe_sorted_def; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_probe_sorted_def (
    snp_probe_sorted_def_id bigint NOT NULL,
    platform_name character varying(255),
    num_probe bigint,
    chrom character varying(16),
    probe_def text,
    snp_id_def text
);


ALTER TABLE deapp.de_snp_probe_sorted_def OWNER TO deapp;

--
-- Name: de_snp_subject_sorted_def; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_snp_subject_sorted_def (
    snp_subject_sorted_def_id bigint NOT NULL,
    trial_name character varying(255),
    patient_position integer,
    patient_num bigint,
    subject_id character varying(255)
);


ALTER TABLE deapp.de_snp_subject_sorted_def OWNER TO deapp;

--
-- Name: de_subject_acgh_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_subject_acgh_data (
    trial_name character varying(50),
    region_id bigint NOT NULL,
    assay_id bigint NOT NULL,
    patient_id bigint,
    chip double precision,
    segmented double precision,
    flag smallint,
    probloss double precision,
    probnorm double precision,
    probgain double precision,
    probamp double precision
);


ALTER TABLE deapp.de_subject_acgh_data OWNER TO deapp;

--
-- Name: COLUMN de_subject_acgh_data.chip; Type: COMMENT; Schema: deapp; Owner: deapp
--

COMMENT ON COLUMN de_subject_acgh_data.chip IS 'log2ratio';


--
-- Name: COLUMN de_subject_acgh_data.segmented; Type: COMMENT; Schema: deapp; Owner: deapp
--

COMMENT ON COLUMN de_subject_acgh_data.segmented IS 'segmented log2ratio';


--
-- Name: COLUMN de_subject_acgh_data.flag; Type: COMMENT; Schema: deapp; Owner: deapp
--

COMMENT ON COLUMN de_subject_acgh_data.flag IS 'call  -1:loss, 0:normal, 1:gain, 2:amplification';


--
-- Name: de_subject_microarray_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_subject_microarray_data (
    trial_name character varying(50),
    probeset_id bigint,
    assay_id bigint,
    patient_id bigint,
    raw_intensity double precision,
    log_intensity double precision,
    zscore double precision,
    raw_intensity_4 double precision,
    partition_id numeric
);


ALTER TABLE deapp.de_subject_microarray_data OWNER TO deapp;

--
-- Name: de_subject_microarray_logs; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_subject_microarray_logs (
    probeset character varying(50),
    raw_intensity bigint,
    pvalue double precision,
    refseq character varying(50),
    gene_symbol character varying(50),
    assay_id bigint,
    patient_id bigint,
    subject_id character varying(20),
    trial_name character varying(15),
    timepoint character varying(30),
    log_intensity bigint
);


ALTER TABLE deapp.de_subject_microarray_logs OWNER TO deapp;

--
-- Name: de_subject_microarray_med; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_subject_microarray_med (
    probeset character varying(50),
    raw_intensity bigint,
    log_intensity bigint,
    gene_symbol character varying(50),
    assay_id bigint,
    patient_id bigint,
    subject_id character varying(20),
    trial_name character varying(15),
    timepoint character varying(30),
    pvalue double precision,
    refseq character varying(50),
    mean_intensity bigint,
    stddev_intensity bigint,
    median_intensity bigint,
    zscore bigint
);


ALTER TABLE deapp.de_subject_microarray_med OWNER TO deapp;

--
-- Name: de_subject_protein_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_subject_protein_data (
    trial_name character varying(15),
    component character varying(15),
    intensity bigint,
    patient_id bigint,
    subject_id character varying(10),
    gene_symbol character varying(100),
    gene_id integer,
    assay_id bigint,
    timepoint character varying(20),
    n_value bigint,
    mean_intensity bigint,
    stddev_intensity bigint,
    median_intensity bigint,
    zscore bigint
);


ALTER TABLE deapp.de_subject_protein_data OWNER TO deapp;

--
-- Name: de_subject_rbm_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_subject_rbm_data (
    trial_name character varying(15),
    antigen_name character varying(100),
    n_value bigint,
    patient_id bigint,
    gene_symbol character varying(100),
    gene_id integer,
    assay_id bigint,
    normalized_value double precision,
    concept_cd character varying(100),
    timepoint character varying(100),
    data_uid character varying(100),
    value bigint,
    log_intensity bigint,
    mean_intensity bigint,
    stddev_intensity bigint,
    median_intensity bigint,
    zscore bigint,
    rbm_panel character varying(50)
);


ALTER TABLE deapp.de_subject_rbm_data OWNER TO deapp;

--
-- Name: de_subject_sample_mapping; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_subject_sample_mapping (
    patient_id bigint,
    site_id character varying(100),
    subject_id character varying(100),
    subject_type character varying(100),
    concept_code character varying(1000),
    assay_id bigint NOT NULL,
    patient_uid character varying(50),
    sample_type character varying(100),
    assay_uid character varying(100),
    trial_name character varying(30),
    timepoint character varying(100),
    timepoint_cd character varying(50),
    sample_type_cd character varying(50),
    tissue_type_cd character varying(50),
    platform character varying(50),
    platform_cd character varying(50),
    tissue_type character varying(100),
    data_uid character varying(100),
    gpl_id character varying(20),
    rbm_panel character varying(50),
    sample_id bigint,
    sample_cd character varying(200),
    category_cd character varying(1000),
    source_cd character varying(50),
    omic_source_study character varying(200),
    omic_patient_id bigint,
    partition_id numeric
);


ALTER TABLE deapp.de_subject_sample_mapping OWNER TO deapp;

--
-- Name: de_subject_snp_dataset; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_subject_snp_dataset (
    subject_snp_dataset_id bigint NOT NULL,
    dataset_name character varying(255),
    concept_cd character varying(255),
    platform_name character varying(255),
    trial_name character varying(255),
    patient_num bigint,
    timepoint character varying(255),
    subject_id character varying(255),
    sample_type character varying(255),
    paired_dataset_id bigint,
    patient_gender character varying(1)
);


ALTER TABLE deapp.de_subject_snp_dataset OWNER TO deapp;

--
-- Name: de_xtrial_child_map; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_xtrial_child_map (
    concept_cd character varying(50) NOT NULL,
    parent_cd bigint NOT NULL,
    manually_mapped bigint,
    study_id character varying(50)
);


ALTER TABLE deapp.de_xtrial_child_map OWNER TO deapp;

--
-- Name: de_xtrial_parent_names; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE de_xtrial_parent_names (
    parent_cd bigint NOT NULL,
    across_path character varying(500),
    manually_created bigint
);


ALTER TABLE deapp.de_xtrial_parent_names OWNER TO deapp;

--
-- Name: deapp_annotation; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE deapp_annotation (
    annotation_type character varying(50),
    annotation_value character varying(100),
    gene_id bigint,
    gene_symbol character varying(200)
);


ALTER TABLE deapp.deapp_annotation OWNER TO deapp;

--
-- Name: haploview_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE TABLE haploview_data (
    i2b2_id bigint,
    jnj_id character varying(30),
    father_id integer,
    mother_id integer,
    sex smallint,
    affection_status smallint,
    chromosome character varying(10),
    gene character varying(50),
    release smallint,
    release_date timestamp without time zone,
    trial_name character varying(50),
    snp_data text
);


ALTER TABLE deapp.haploview_data OWNER TO deapp;

--
-- Name: seq_assay_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_assay_id
    START WITH 41
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE deapp.seq_assay_id OWNER TO deapp;

--
-- Name: seq_data_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_data_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE deapp.seq_data_id OWNER TO deapp;

--
-- Name: seq_mrna_partition_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_mrna_partition_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE deapp.seq_mrna_partition_id OWNER TO deapp;

SET search_path = i2b2demodata, pg_catalog;

--
-- Name: archive_observation_fact; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE archive_observation_fact (
    encounter_num numeric(38,0),
    patient_num numeric(38,0),
    concept_cd character varying(50),
    provider_id character varying(50),
    start_date timestamp without time zone,
    modifier_cd character varying(100),
    instance_num numeric(18,0),
    valtype_cd character varying(50),
    tval_char character varying(255),
    nval_num numeric(18,5),
    valueflag_cd character varying(50),
    quantity_num numeric(18,5),
    units_cd character varying(50),
    end_date timestamp without time zone,
    location_cd character varying(50),
    observation_blob text,
    confidence_num numeric(18,5),
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0),
    archive_upload_id numeric(22,0)
);


ALTER TABLE i2b2demodata.archive_observation_fact OWNER TO i2b2demodata;

--
-- Name: async_job; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE async_job (
    id integer,
    job_name character varying(200),
    job_status character varying(200),
    run_time character varying(200),
    last_run_on timestamp(6) without time zone,
    viewer_url character varying(4000),
    alt_viewer_url character varying(600),
    job_results text,
    job_type character varying(20)
);


ALTER TABLE i2b2demodata.async_job OWNER TO i2b2demodata;

--
-- Name: code_lookup; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE code_lookup (
    table_cd character varying(100) NOT NULL,
    column_cd character varying(100) NOT NULL,
    code_cd character varying(50) NOT NULL,
    name_char character varying(650),
    lookup_blob text,
    upload_date timestamp without time zone,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.code_lookup OWNER TO i2b2demodata;

--
-- Name: concept_counts; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE concept_counts (
    concept_path character varying(500),
    parent_concept_path character varying(500),
    patient_count numeric(18,0)
);


ALTER TABLE i2b2demodata.concept_counts OWNER TO i2b2demodata;

--
-- Name: concept_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE concept_dimension (
    concept_path character varying(700) NOT NULL,
    concept_cd character varying(50) NOT NULL,
    name_char character varying(2000),
    concept_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.concept_dimension OWNER TO i2b2demodata;

--
-- Name: concept_id; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE concept_id
    START WITH 200
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.concept_id OWNER TO i2b2demodata;

--
-- Name: datamart_report; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE datamart_report (
    total_patient numeric(38,0),
    total_observationfact numeric(38,0),
    total_event numeric(38,0),
    report_date timestamp without time zone
);


ALTER TABLE i2b2demodata.datamart_report OWNER TO i2b2demodata;

--
-- Name: encounter_mapping; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE encounter_mapping (
    encounter_ide character varying(200) NOT NULL,
    encounter_ide_source character varying(50) NOT NULL,
    encounter_num numeric(38,0) NOT NULL,
    patient_ide character varying(200),
    patient_ide_source character varying(50),
    encounter_ide_status character varying(50),
    upload_date timestamp without time zone,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.encounter_mapping OWNER TO i2b2demodata;

--
-- Name: modifier_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE modifier_dimension (
    modifier_path character varying(700) NOT NULL,
    modifier_cd character varying(50),
    name_char character varying(2000),
    modifier_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.modifier_dimension OWNER TO i2b2demodata;

--
-- Name: news_updates; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE news_updates (
    newsid integer,
    ranbyuser character varying(200),
    rowsaffected integer,
    operation character varying(200),
    datasetname character varying(200),
    updatedate timestamp(6) without time zone,
    commentfield character varying(200)
);


ALTER TABLE i2b2demodata.news_updates OWNER TO i2b2demodata;

--
-- Name: observation_fact; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE observation_fact (
    encounter_num numeric(38,0),
    patient_num numeric(38,0) NOT NULL,
    concept_cd character varying(50) NOT NULL,
    provider_id character varying(50) NOT NULL,
    start_date timestamp without time zone,
    modifier_cd character varying(100) NOT NULL,
    instance_num numeric(18,0),
    valtype_cd character varying(50),
    tval_char character varying(255),
    nval_num numeric(18,5),
    valueflag_cd character varying(50),
    quantity_num numeric(18,5),
    units_cd character varying(50),
    end_date timestamp without time zone,
    location_cd character varying(50),
    observation_blob text,
    confidence_num numeric(18,5),
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.observation_fact OWNER TO i2b2demodata;

--
-- Name: patient_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE patient_dimension (
    patient_num numeric(38,0) NOT NULL,
    vital_status_cd character varying(50),
    birth_date timestamp without time zone,
    death_date timestamp without time zone,
    sex_cd character varying(50),
    age_in_years_num numeric(38,0),
    language_cd character varying(50),
    race_cd character varying(50),
    marital_status_cd character varying(50),
    religion_cd character varying(50),
    zip_cd character varying(10),
    statecityzip_path character varying(700),
    income_cd character varying(50),
    patient_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.patient_dimension OWNER TO i2b2demodata;

--
-- Name: patient_mapping; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE patient_mapping (
    patient_ide character varying(200) NOT NULL,
    patient_ide_source character varying(50) NOT NULL,
    patient_num numeric(38,0) NOT NULL,
    patient_ide_status character varying(50),
    upload_date timestamp without time zone,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.patient_mapping OWNER TO i2b2demodata;

--
-- Name: patient_trial; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE patient_trial (
    patient_num numeric,
    trial character varying(30),
    secure_obj_token character varying(50)
);


ALTER TABLE i2b2demodata.patient_trial OWNER TO i2b2demodata;

--
-- Name: provider_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE provider_dimension (
    provider_id character varying(50) NOT NULL,
    provider_path character varying(700) NOT NULL,
    name_char character varying(850),
    provider_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.provider_dimension OWNER TO i2b2demodata;

--
-- Name: qt_analysis_plugin; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_analysis_plugin (
    plugin_id numeric(10,0) NOT NULL,
    plugin_name character varying(2000),
    description character varying(2000),
    version_cd character varying(50),
    parameter_info text,
    parameter_info_xsd character varying(2000),
    command_line character varying(2000),
    working_folder character varying(2000),
    commandoption_cd character varying(2000),
    plugin_icon character varying(2000),
    status_cd character varying(50),
    user_id character varying(50),
    group_id character varying(50),
    create_date timestamp without time zone,
    update_date timestamp without time zone
);


ALTER TABLE i2b2demodata.qt_analysis_plugin OWNER TO i2b2demodata;

--
-- Name: qt_analysis_plugin_result_type; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_analysis_plugin_result_type (
    plugin_id numeric(10,0) NOT NULL,
    result_type_id numeric(10,0) NOT NULL
);


ALTER TABLE i2b2demodata.qt_analysis_plugin_result_type OWNER TO i2b2demodata;

--
-- Name: qt_breakdown_path; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_breakdown_path (
    name character varying(100),
    value character varying(2000),
    create_date timestamp without time zone,
    update_date timestamp without time zone,
    user_id character varying(50)
);


ALTER TABLE i2b2demodata.qt_breakdown_path OWNER TO i2b2demodata;

--
-- Name: qt_sq_qper_pecid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qper_pecid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qper_pecid OWNER TO i2b2demodata;

--
-- Name: qt_patient_enc_collection; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_patient_enc_collection (
    patient_enc_coll_id numeric(10,0) DEFAULT nextval('qt_sq_qper_pecid'::regclass) NOT NULL,
    result_instance_id numeric(5,0),
    set_index numeric(10,0),
    patient_num numeric(10,0),
    encounter_num numeric(10,0)
);


ALTER TABLE i2b2demodata.qt_patient_enc_collection OWNER TO i2b2demodata;

--
-- Name: qt_sq_qpr_pcid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qpr_pcid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qpr_pcid OWNER TO i2b2demodata;

--
-- Name: qt_patient_set_collection; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_patient_set_collection (
    patient_set_coll_id numeric(10,0) DEFAULT nextval('qt_sq_qpr_pcid'::regclass) NOT NULL,
    result_instance_id numeric(5,0),
    set_index numeric(10,0),
    patient_num numeric(10,0)
);


ALTER TABLE i2b2demodata.qt_patient_set_collection OWNER TO i2b2demodata;

--
-- Name: qt_sq_pqm_qmid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_pqm_qmid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_pqm_qmid OWNER TO i2b2demodata;

--
-- Name: qt_pdo_query_master; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_pdo_query_master (
    query_master_id numeric(5,0) DEFAULT nextval('qt_sq_pqm_qmid'::regclass) NOT NULL,
    user_id character varying(50) NOT NULL,
    group_id character varying(50) NOT NULL,
    create_date timestamp without time zone NOT NULL,
    request_xml text,
    i2b2_request_xml text
);


ALTER TABLE i2b2demodata.qt_pdo_query_master OWNER TO i2b2demodata;

--
-- Name: qt_privilege; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_privilege (
    protection_label_cd character varying(1500),
    dataprot_cd character varying(1000),
    hivemgmt_cd character varying(1000),
    plugin_id numeric(10,0)
);


ALTER TABLE i2b2demodata.qt_privilege OWNER TO i2b2demodata;

--
-- Name: qt_sq_qi_qiid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qi_qiid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qi_qiid OWNER TO i2b2demodata;

--
-- Name: qt_query_instance; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_query_instance (
    query_instance_id numeric(5,0) DEFAULT nextval('qt_sq_qi_qiid'::regclass) NOT NULL,
    query_master_id numeric(5,0),
    user_id character varying(50) NOT NULL,
    group_id character varying(50) NOT NULL,
    batch_mode character varying(50),
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    delete_flag character varying(3),
    status_type_id numeric(5,0),
    message text
);


ALTER TABLE i2b2demodata.qt_query_instance OWNER TO i2b2demodata;

--
-- Name: qt_sq_qm_qmid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qm_qmid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qm_qmid OWNER TO i2b2demodata;

--
-- Name: qt_query_master; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_query_master (
    query_master_id numeric(5,0) DEFAULT nextval('qt_sq_qm_qmid'::regclass) NOT NULL,
    name character varying(250) NOT NULL,
    user_id character varying(50) NOT NULL,
    group_id character varying(50) NOT NULL,
    master_type_cd character varying(2000),
    plugin_id numeric(10,0),
    create_date timestamp without time zone NOT NULL,
    delete_date timestamp without time zone,
    delete_flag character varying(3),
    generated_sql text,
    request_xml text,
    i2b2_request_xml text
);


ALTER TABLE i2b2demodata.qt_query_master OWNER TO i2b2demodata;

--
-- Name: qt_sq_qri_qriid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qri_qriid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qri_qriid OWNER TO i2b2demodata;

--
-- Name: qt_query_result_instance; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_query_result_instance (
    result_instance_id numeric(5,0) DEFAULT nextval('qt_sq_qri_qriid'::regclass) NOT NULL,
    query_instance_id numeric(5,0),
    result_type_id numeric(3,0) NOT NULL,
    set_size numeric(10,0),
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    delete_flag character varying(3),
    status_type_id numeric(3,0) NOT NULL,
    message text,
    description character varying(200),
    real_set_size numeric(10,0),
    obfusc_method character varying(500)
);


ALTER TABLE i2b2demodata.qt_query_result_instance OWNER TO i2b2demodata;

--
-- Name: qt_sq_qr_qrid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qr_qrid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qr_qrid OWNER TO i2b2demodata;

--
-- Name: qt_query_result_type; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_query_result_type (
    result_type_id numeric(3,0) DEFAULT nextval('qt_sq_qr_qrid'::regclass) NOT NULL,
    name character varying(100),
    description character varying(200),
    display_type_id character varying(500),
    visual_attribute_type_id character varying(3)
);


ALTER TABLE i2b2demodata.qt_query_result_type OWNER TO i2b2demodata;

--
-- Name: qt_sq_qs_qsid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qs_qsid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qs_qsid OWNER TO i2b2demodata;

--
-- Name: qt_query_status_type; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_query_status_type (
    status_type_id numeric(3,0) DEFAULT nextval('qt_sq_qs_qsid'::regclass) NOT NULL,
    name character varying(100),
    description character varying(200)
);


ALTER TABLE i2b2demodata.qt_query_status_type OWNER TO i2b2demodata;

--
-- Name: qt_sq_qxr_xrid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qxr_xrid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qxr_xrid OWNER TO i2b2demodata;

--
-- Name: qt_xml_result; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE qt_xml_result (
    xml_result_id numeric(5,0) DEFAULT nextval('qt_sq_qxr_xrid'::regclass) NOT NULL,
    result_instance_id numeric(5,0),
    xml_value character varying(4000)
);


ALTER TABLE i2b2demodata.qt_xml_result OWNER TO i2b2demodata;

--
-- Name: sample_categories; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE sample_categories (
    trial_name character varying(100),
    tissue_type character varying(2000),
    data_types character varying(2000),
    disease character varying(2000),
    tissue_state character varying(2000),
    sample_id character varying(250),
    biobank character varying(3),
    source_organism character varying(255),
    treatment character varying(255),
    sample_treatment character varying(2000),
    subject_treatment character varying(2000),
    timepoint character varying(250)
);


ALTER TABLE i2b2demodata.sample_categories OWNER TO i2b2demodata;

--
-- Name: seq_patient_num; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE seq_patient_num
    START WITH 1000000200
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.seq_patient_num OWNER TO i2b2demodata;

--
-- Name: sq_up_patdim_patientnum; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE sq_up_patdim_patientnum
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE i2b2demodata.sq_up_patdim_patientnum OWNER TO i2b2demodata;

--
-- Name: set_type; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE set_type (
    id integer DEFAULT nextval('sq_up_patdim_patientnum'::regclass) NOT NULL,
    name character varying(500),
    create_date timestamp without time zone
);


ALTER TABLE i2b2demodata.set_type OWNER TO i2b2demodata;

--
-- Name: set_upload_status; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE set_upload_status (
    upload_id numeric NOT NULL,
    set_type_id integer NOT NULL,
    source_cd character varying(50) NOT NULL,
    no_of_record numeric,
    loaded_record numeric,
    deleted_record numeric,
    load_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    load_status character varying(100),
    message text,
    input_file_name character varying(500),
    log_file_name character varying(500),
    transform_name character varying(500)
);


ALTER TABLE i2b2demodata.set_upload_status OWNER TO i2b2demodata;

--
-- Name: source_master; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE source_master (
    source_cd character varying(50) NOT NULL,
    description character varying(300),
    create_date timestamp without time zone
);


ALTER TABLE i2b2demodata.source_master OWNER TO i2b2demodata;

--
-- Name: sq_async_job; Type: SEQUENCE; Schema: i2b2demodata; Owner: biomart_user
--

CREATE SEQUENCE sq_async_job
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.sq_async_job OWNER TO biomart_user;

--
-- Name: sq_up_encdim_encounternum; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE sq_up_encdim_encounternum
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE i2b2demodata.sq_up_encdim_encounternum OWNER TO i2b2demodata;

--
-- Name: sq_uploadstatus_uploadid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE sq_uploadstatus_uploadid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE i2b2demodata.sq_uploadstatus_uploadid OWNER TO i2b2demodata;

--
-- Name: upload_status; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE upload_status (
    upload_id numeric(38,0) DEFAULT nextval('sq_uploadstatus_uploadid'::regclass) NOT NULL,
    upload_label character varying(500) NOT NULL,
    user_id character varying(100) NOT NULL,
    source_cd character varying(50) NOT NULL,
    no_of_record numeric,
    loaded_record numeric,
    deleted_record numeric,
    load_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    load_status character varying(100),
    message text,
    input_file_name character varying(500),
    log_file_name character varying(500),
    transform_name character varying(500)
);


ALTER TABLE i2b2demodata.upload_status OWNER TO i2b2demodata;

--
-- Name: visit_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE TABLE visit_dimension (
    encounter_num numeric(38,0) NOT NULL,
    patient_num numeric(38,0) NOT NULL,
    active_status_cd character varying(50),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    inout_cd character varying(50),
    location_cd character varying(50),
    location_path character varying(900),
    length_of_stay numeric(38,0),
    visit_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.visit_dimension OWNER TO i2b2demodata;

SET search_path = i2b2hive, pg_catalog;

--
-- Name: crc_analysis_job; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE crc_analysis_job (
    job_id character varying(10) NOT NULL,
    queue_name character varying(50),
    status_type_id integer,
    domain_id character varying(255),
    project_id character varying(500),
    user_id character varying(255),
    request_xml text,
    create_date timestamp without time zone,
    update_date timestamp without time zone
);


ALTER TABLE i2b2hive.crc_analysis_job OWNER TO i2b2hive;

--
-- Name: crc_db_lookup; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE crc_db_lookup (
    c_domain_id character varying(255) NOT NULL,
    c_project_path character varying(255) NOT NULL,
    c_owner_id character varying(255) NOT NULL,
    c_db_fullschema character varying(255) NOT NULL,
    c_db_datasource character varying(255) NOT NULL,
    c_db_servertype character varying(255) NOT NULL,
    c_db_nicename character varying(255),
    c_db_tooltip character varying(255),
    c_comment text,
    c_entry_date timestamp without time zone,
    c_change_date timestamp without time zone,
    c_status_cd character(1)
);


ALTER TABLE i2b2hive.crc_db_lookup OWNER TO i2b2hive;

--
-- Name: hilosequences; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE hilosequences (
    sequencename character varying(50) NOT NULL,
    highvalues integer NOT NULL
);


ALTER TABLE i2b2hive.hilosequences OWNER TO i2b2hive;

--
-- Name: jms_messages; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE jms_messages (
    messageid integer NOT NULL,
    destination character varying(150) NOT NULL,
    txid integer,
    txop character(1),
    messageblob bytea
);


ALTER TABLE i2b2hive.jms_messages OWNER TO i2b2hive;

--
-- Name: jms_roles; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE jms_roles (
    roleid character varying(32) NOT NULL,
    userid character varying(32) NOT NULL
);


ALTER TABLE i2b2hive.jms_roles OWNER TO i2b2hive;

--
-- Name: jms_subscriptions; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE jms_subscriptions (
    clientid character varying(128) NOT NULL,
    subname character varying(128) NOT NULL,
    topic character varying(255) NOT NULL,
    selector character varying(255)
);


ALTER TABLE i2b2hive.jms_subscriptions OWNER TO i2b2hive;

--
-- Name: jms_transactions; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE jms_transactions (
    txid integer NOT NULL
);


ALTER TABLE i2b2hive.jms_transactions OWNER TO i2b2hive;

--
-- Name: jms_users; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE jms_users (
    userid character varying(32) NOT NULL,
    passwd character varying(32) NOT NULL,
    clientid character varying(128)
);


ALTER TABLE i2b2hive.jms_users OWNER TO i2b2hive;

--
-- Name: ont_db_lookup; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE ont_db_lookup (
    c_domain_id character varying(255) NOT NULL,
    c_project_path character varying(255) NOT NULL,
    c_owner_id character varying(255) NOT NULL,
    c_db_fullschema character varying(255) NOT NULL,
    c_db_datasource character varying(255) NOT NULL,
    c_db_servertype character varying(255) NOT NULL,
    c_db_nicename character varying(255),
    c_db_tooltip character varying(255),
    c_comment text,
    c_entry_date timestamp without time zone,
    c_change_date timestamp without time zone,
    c_status_cd character(1)
);


ALTER TABLE i2b2hive.ont_db_lookup OWNER TO i2b2hive;

--
-- Name: timers; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE timers (
    timerid character varying(80) NOT NULL,
    targetid character varying(250) NOT NULL,
    initialdate timestamp with time zone NOT NULL,
    timerinterval bigint,
    instancepk bytea,
    info bytea
);


ALTER TABLE i2b2hive.timers OWNER TO i2b2hive;

--
-- Name: work_db_lookup; Type: TABLE; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE TABLE work_db_lookup (
    c_domain_id character varying(255) NOT NULL,
    c_project_path character varying(255) NOT NULL,
    c_owner_id character varying(255) NOT NULL,
    c_db_fullschema character varying(255) NOT NULL,
    c_db_datasource character varying(255) NOT NULL,
    c_db_servertype character varying(255) NOT NULL,
    c_db_nicename character varying(255),
    c_db_tooltip character varying(255),
    c_comment character varying(4000),
    c_entry_date timestamp without time zone,
    c_change_date timestamp without time zone,
    c_status_cd character(1)
);


ALTER TABLE i2b2hive.work_db_lookup OWNER TO i2b2hive;

SET search_path = i2b2metadata, pg_catalog;

--
-- Name: birn; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

CREATE TABLE birn (
    c_hlevel numeric(22,0) NOT NULL,
    c_fullname character varying(700) NOT NULL,
    c_name character varying(2000) NOT NULL,
    c_synonym_cd character(1) NOT NULL,
    c_visualattributes character(3) NOT NULL,
    c_totalnum numeric(22,0),
    c_basecode character varying(50),
    c_metadataxml text,
    c_facttablecolumn character varying(50) NOT NULL,
    c_tablename character varying(50) NOT NULL,
    c_columnname character varying(50) NOT NULL,
    c_columndatatype character varying(50) NOT NULL,
    c_operator character varying(10) NOT NULL,
    c_dimcode character varying(700) NOT NULL,
    c_comment text,
    c_tooltip character varying(900),
    m_applied_path character varying(700) NOT NULL,
    update_date timestamp without time zone NOT NULL,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    valuetype_cd character varying(50),
    m_exclusion_cd character varying(25),
    c_path character varying(700),
    c_symbol character varying(50)
);


ALTER TABLE i2b2metadata.birn OWNER TO i2b2metadata;

--
-- Name: custom_meta; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

CREATE TABLE custom_meta (
    c_hlevel numeric(22,0) NOT NULL,
    c_fullname character varying(700) NOT NULL,
    c_name character varying(2000) NOT NULL,
    c_synonym_cd character(1) NOT NULL,
    c_visualattributes character(3) NOT NULL,
    c_totalnum numeric(22,0),
    c_basecode character varying(50),
    c_metadataxml text,
    c_facttablecolumn character varying(50) NOT NULL,
    c_tablename character varying(50) NOT NULL,
    c_columnname character varying(50) NOT NULL,
    c_columndatatype character varying(50) NOT NULL,
    c_operator character varying(10) NOT NULL,
    c_dimcode character varying(700) NOT NULL,
    c_comment text,
    c_tooltip character varying(900),
    m_applied_path character varying(700) NOT NULL,
    update_date timestamp without time zone NOT NULL,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    valuetype_cd character varying(50),
    m_exclusion_cd character varying(25),
    c_path character varying(700),
    c_symbol character varying(50)
);


ALTER TABLE i2b2metadata.custom_meta OWNER TO i2b2metadata;

--
-- Name: i2b2; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

CREATE TABLE i2b2 (
    c_hlevel numeric(22,0) NOT NULL,
    c_fullname character varying(700) NOT NULL,
    c_name character varying(2000) NOT NULL,
    c_synonym_cd character(1) NOT NULL,
    c_visualattributes character(3) NOT NULL,
    c_totalnum numeric(22,0),
    c_basecode character varying(50),
    c_metadataxml text,
    c_facttablecolumn character varying(50) NOT NULL,
    c_tablename character varying(150) NOT NULL,
    c_columnname character varying(50) NOT NULL,
    c_columndatatype character varying(50) NOT NULL,
    c_operator character varying(10) NOT NULL,
    c_dimcode character varying(700) NOT NULL,
    c_comment text,
    c_tooltip character varying(900),
    m_applied_path character varying(700) NOT NULL,
    update_date timestamp without time zone NOT NULL,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    valuetype_cd character varying(50),
    m_exclusion_cd character varying(25),
    c_path character varying(700),
    c_symbol character varying(50)
);


ALTER TABLE i2b2metadata.i2b2 OWNER TO i2b2metadata;

--
-- Name: i2b2_secure; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

CREATE TABLE i2b2_secure (
    c_hlevel numeric(22,0),
    c_fullname character varying(700),
    c_name character varying(2000),
    c_synonym_cd character(1),
    c_visualattributes character(3),
    c_totalnum numeric(22,0),
    c_basecode character varying(50),
    c_metadataxml text,
    c_facttablecolumn character varying(50),
    c_tablename character varying(150),
    c_columnname character varying(50),
    c_columndatatype character varying(50),
    c_operator character varying(10),
    c_dimcode character varying(700),
    c_comment text,
    c_tooltip character varying(900),
    m_applied_path character varying(700),
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    valuetype_cd character varying(50),
    m_exclusion_cd character varying(25),
    c_path character varying(700),
    c_symbol character varying(50),
    i2b2_id numeric(18,0),
    secure_obj_token character varying(50)
);


ALTER TABLE i2b2metadata.i2b2_secure OWNER TO i2b2metadata;

--
-- Name: i2b2_tags; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

CREATE TABLE i2b2_tags (
    tag_id integer NOT NULL,
    path character varying(400),
    tag character varying(400),
    tag_type character varying(400),
    tags_idx integer NOT NULL
);


ALTER TABLE i2b2metadata.i2b2_tags OWNER TO i2b2metadata;

--
-- Name: ont_sq_ps_prid; Type: SEQUENCE; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE SEQUENCE ont_sq_ps_prid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2metadata.ont_sq_ps_prid OWNER TO i2b2metadata;

--
-- Name: ont_process_status; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

CREATE TABLE ont_process_status (
    process_id numeric(5,0) DEFAULT nextval('ont_sq_ps_prid'::regclass) NOT NULL,
    process_type_cd character varying(50),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    process_step_cd character varying(50),
    process_status_cd character varying(50),
    crc_upload_id numeric(38,0),
    status_cd character varying(50),
    message character varying(2000),
    entry_date timestamp without time zone,
    change_date timestamp without time zone,
    changedby_char character(50)
);


ALTER TABLE i2b2metadata.ont_process_status OWNER TO i2b2metadata;

--
-- Name: schemes; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

CREATE TABLE schemes (
    c_key character varying(50) NOT NULL,
    c_name character varying(50) NOT NULL,
    c_description character varying(100)
);


ALTER TABLE i2b2metadata.schemes OWNER TO i2b2metadata;

--
-- Name: seq_i2b2metadata; Type: SEQUENCE; Schema: i2b2metadata; Owner: postgres
--

CREATE SEQUENCE seq_i2b2metadata
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 10;


ALTER TABLE i2b2metadata.seq_i2b2metadata OWNER TO postgres;

--
-- Name: table_access; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

CREATE TABLE table_access (
    c_table_cd character varying(50) NOT NULL,
    c_table_name character varying(50) NOT NULL,
    c_protected_access character(1),
    c_hlevel numeric(22,0) NOT NULL,
    c_fullname character varying(700) NOT NULL,
    c_name character varying(2000) NOT NULL,
    c_synonym_cd character(1) NOT NULL,
    c_visualattributes character(3) NOT NULL,
    c_totalnum numeric(22,0),
    c_basecode character varying(50),
    c_metadataxml text,
    c_facttablecolumn character varying(50) NOT NULL,
    c_dimtablename character varying(50) NOT NULL,
    c_columnname character varying(50) NOT NULL,
    c_columndatatype character varying(50) NOT NULL,
    c_operator character varying(10) NOT NULL,
    c_dimcode character varying(700) NOT NULL,
    c_comment text,
    c_tooltip character varying(900),
    c_entry_date timestamp without time zone,
    c_change_date timestamp without time zone,
    c_status_cd character(1),
    valuetype_cd character varying(50)
);


ALTER TABLE i2b2metadata.table_access OWNER TO i2b2metadata;

SET search_path = i2b2pm, pg_catalog;

--
-- Name: pm_cell_data; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_cell_data (
    cell_id character varying(50) NOT NULL,
    project_path character varying(255) NOT NULL,
    name character varying(255),
    method_cd character varying(255),
    url character varying(255),
    can_override numeric(1,0),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_cell_data OWNER TO i2b2pm;

--
-- Name: pm_params; Type: SEQUENCE; Schema: i2b2pm; Owner: i2b2pm
--

CREATE SEQUENCE pm_params
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2pm.pm_params OWNER TO i2b2pm;

--
-- Name: pm_cell_params; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_cell_params (
    id numeric DEFAULT nextval('pm_params'::regclass) NOT NULL,
    datatype_cd character varying(50),
    cell_id character varying(50) NOT NULL,
    project_path character varying(255) NOT NULL,
    param_name_cd character varying(50) NOT NULL,
    value character varying(255),
    can_override numeric(1,0),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_cell_params OWNER TO i2b2pm;

--
-- Name: pm_global_params; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_global_params (
    id numeric DEFAULT nextval('pm_params'::regclass) NOT NULL,
    datatype_cd character varying(50),
    param_name_cd character varying(50) NOT NULL,
    project_path character varying(255) NOT NULL,
    value character varying(255),
    can_override numeric(1,0),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_global_params OWNER TO i2b2pm;

--
-- Name: pm_hive_data; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_hive_data (
    domain_id character varying(50) NOT NULL,
    helpurl character varying(255),
    domain_name character varying(255),
    environment_cd character varying(255),
    active numeric(1,0),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_hive_data OWNER TO i2b2pm;

--
-- Name: pm_hive_params; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_hive_params (
    id numeric DEFAULT nextval('pm_params'::regclass) NOT NULL,
    datatype_cd character varying(50),
    domain_id character varying(50) NOT NULL,
    param_name_cd character varying(50) NOT NULL,
    value character varying(255),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_hive_params OWNER TO i2b2pm;

--
-- Name: pm_project_data; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_project_data (
    project_id character varying(50) NOT NULL,
    project_name character varying(255),
    project_wiki character varying(255),
    project_key character varying(255),
    project_path character varying(255),
    project_description character varying(2000),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_project_data OWNER TO i2b2pm;

--
-- Name: pm_project_params; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_project_params (
    id numeric DEFAULT nextval('pm_params'::regclass) NOT NULL,
    datatype_cd character varying(50),
    project_id character varying(50) NOT NULL,
    param_name_cd character varying(50) NOT NULL,
    value character varying(255),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_project_params OWNER TO i2b2pm;

--
-- Name: pm_project_user_params; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_project_user_params (
    id numeric DEFAULT nextval('pm_params'::regclass) NOT NULL,
    datatype_cd character varying(50),
    project_id character varying(50) NOT NULL,
    user_id character varying(50) NOT NULL,
    param_name_cd character varying(50) NOT NULL,
    value character varying(255),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_project_user_params OWNER TO i2b2pm;

--
-- Name: pm_project_user_roles; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_project_user_roles (
    project_id character varying(50) NOT NULL,
    user_id character varying(50) NOT NULL,
    user_role_cd character varying(255) NOT NULL,
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_project_user_roles OWNER TO i2b2pm;

--
-- Name: pm_role_requirement; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_role_requirement (
    table_cd character varying(50) NOT NULL,
    column_cd character varying(50) NOT NULL,
    read_hivemgmt_cd character varying(50) NOT NULL,
    write_hivemgmt_cd character varying(50) NOT NULL,
    name_char character varying(2000),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_role_requirement OWNER TO i2b2pm;

--
-- Name: pm_user_data; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_user_data (
    user_id character varying(50) NOT NULL,
    full_name character varying(255),
    password character varying(255),
    email character varying(255),
    project_path character varying(255),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_user_data OWNER TO i2b2pm;

--
-- Name: pm_user_params; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_user_params (
    id numeric DEFAULT nextval('pm_params'::regclass) NOT NULL,
    datatype_cd character varying(50),
    user_id character varying(50) NOT NULL,
    param_name_cd character varying(50) NOT NULL,
    value character varying(255),
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_user_params OWNER TO i2b2pm;

--
-- Name: pm_user_session; Type: TABLE; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

CREATE TABLE pm_user_session (
    user_id character varying(50) NOT NULL,
    session_id character varying(50) NOT NULL,
    expired_date timestamp without time zone,
    change_date timestamp without time zone,
    entry_date timestamp without time zone,
    changeby_char character varying(50),
    status_cd character varying(50)
);


ALTER TABLE i2b2pm.pm_user_session OWNER TO i2b2pm;

--
-- Name: trip; Type: TABLE; Schema: i2b2pm; Owner: biomart_user; Tablespace: 
--

CREATE TABLE trip (
    id bigint NOT NULL,
    city character varying(255) NOT NULL,
    end_date timestamp without time zone NOT NULL,
    name character varying(255) NOT NULL,
    notes character varying(255) NOT NULL,
    purpose character varying(255) NOT NULL,
    start_date timestamp without time zone NOT NULL
);


ALTER TABLE i2b2pm.trip OWNER TO biomart_user;

SET search_path = i2b2workdata, pg_catalog;

--
-- Name: workplace; Type: TABLE; Schema: i2b2workdata; Owner: i2b2workdata; Tablespace: 
--

CREATE TABLE workplace (
    c_name character varying(255) NOT NULL,
    c_user_id character varying(255) NOT NULL,
    c_group_id character varying(255) NOT NULL,
    c_share_id character varying(255),
    c_index character varying(255) NOT NULL,
    c_parent_index character varying(255),
    c_visualattributes character(3) NOT NULL,
    c_protected_access character(1),
    c_tooltip character varying(255),
    c_work_xml text,
    c_work_xml_schema text,
    c_work_xml_i2b2_type character varying(255),
    c_entry_date date,
    c_change_date date,
    c_status_cd character(1)
);


ALTER TABLE i2b2workdata.workplace OWNER TO i2b2workdata;

--
-- Name: workplace_access; Type: TABLE; Schema: i2b2workdata; Owner: i2b2workdata; Tablespace: 
--

CREATE TABLE workplace_access (
    c_table_cd character varying(255) NOT NULL,
    c_table_name character varying(255) NOT NULL,
    c_protected_access character(1),
    c_hlevel integer NOT NULL,
    c_name character varying(255) NOT NULL,
    c_user_id character varying(255) NOT NULL,
    c_group_id character varying(255) NOT NULL,
    c_share_id character varying(255),
    c_index character varying(255) NOT NULL,
    c_parent_index character varying(255),
    c_visualattributes character(3) NOT NULL,
    c_tooltip character varying(255),
    c_entry_date date,
    c_change_date date,
    c_status_cd character(1)
);


ALTER TABLE i2b2workdata.workplace_access OWNER TO i2b2workdata;

SET search_path = public, pg_catalog;

--
-- Name: hibernate_sequence; Type: SEQUENCE; Schema: public; Owner: biomart_user
--

CREATE SEQUENCE hibernate_sequence
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.hibernate_sequence OWNER TO biomart_user;

SET search_path = searchapp, pg_catalog;

--
-- Name: hibernate_sequence; Type: SEQUENCE; Schema: searchapp; Owner: searchapp
--

CREATE SEQUENCE hibernate_sequence
    START WITH 100041
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE searchapp.hibernate_sequence OWNER TO searchapp;

--
-- Name: plugin; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE plugin (
    plugin_seq bigint NOT NULL,
    name character varying(200) NOT NULL,
    plugin_name character varying(90) NOT NULL,
    has_modules character(1) DEFAULT 'N'::bpchar,
    has_form character(1) DEFAULT 'N'::bpchar,
    default_link character varying(70) NOT NULL,
    form_link character varying(70),
    form_page character varying(100),
    active character(1)
);


ALTER TABLE searchapp.plugin OWNER TO searchapp;

--
-- Name: plugin_module; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE plugin_module (
    module_seq bigint NOT NULL,
    plugin_seq bigint NOT NULL,
    name character varying(70) NOT NULL,
    params text,
    version character varying(10) DEFAULT 0.1,
    active character(1) DEFAULT 'Y'::bpchar,
    has_form character(1) DEFAULT 'N'::bpchar,
    form_link character varying(90),
    form_page character varying(90),
    module_name character varying(50) NOT NULL,
    category character varying(50)
);


ALTER TABLE searchapp.plugin_module OWNER TO searchapp;

--
-- Name: plugin_module_seq; Type: SEQUENCE; Schema: searchapp; Owner: searchapp
--

CREATE SEQUENCE plugin_module_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE searchapp.plugin_module_seq OWNER TO searchapp;

--
-- Name: plugin_seq; Type: SEQUENCE; Schema: searchapp; Owner: searchapp
--

CREATE SEQUENCE plugin_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE searchapp.plugin_seq OWNER TO searchapp;

--
-- Name: search_app_access_log; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_app_access_log (
    id bigint,
    access_time timestamp without time zone,
    event character varying(255),
    request_url character varying(255),
    user_name character varying(255),
    event_message text
);


ALTER TABLE searchapp.search_app_access_log OWNER TO searchapp;

--
-- Name: search_auth_group; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_auth_group (
    id bigint NOT NULL,
    group_category character varying(255)
);


ALTER TABLE searchapp.search_auth_group OWNER TO searchapp;

--
-- Name: search_auth_group_member; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_auth_group_member (
    auth_user_id bigint,
    auth_group_id bigint
);


ALTER TABLE searchapp.search_auth_group_member OWNER TO searchapp;

--
-- Name: search_auth_principal; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_auth_principal (
    id bigint NOT NULL,
    principal_type character varying(255),
    date_created timestamp without time zone NOT NULL,
    description character varying(255),
    last_updated timestamp without time zone NOT NULL,
    name character varying(255),
    unique_id character varying(255),
    enabled boolean
);


ALTER TABLE searchapp.search_auth_principal OWNER TO searchapp;

--
-- Name: search_auth_sec_object_access; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_auth_sec_object_access (
    auth_sec_obj_access_id bigint NOT NULL,
    auth_principal_id bigint,
    secure_object_id bigint,
    secure_access_level_id bigint
);


ALTER TABLE searchapp.search_auth_sec_object_access OWNER TO searchapp;

--
-- Name: search_auth_user; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_auth_user (
    id bigint NOT NULL,
    email character varying(255),
    email_show boolean,
    passwd character varying(255),
    user_real_name character varying(255),
    username character varying(255)
);


ALTER TABLE searchapp.search_auth_user OWNER TO searchapp;

--
-- Name: search_auth_user_sec_access; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_auth_user_sec_access (
    search_auth_user_sec_access_id bigint NOT NULL,
    search_auth_user_id bigint,
    search_secure_object_id bigint,
    search_sec_access_level_id bigint
);


ALTER TABLE searchapp.search_auth_user_sec_access OWNER TO searchapp;

--
-- Name: search_auth_user_sec_access_v; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_auth_user_sec_access_v AS
        (         SELECT sasoa.auth_sec_obj_access_id AS search_auth_user_sec_access_id, 
                    sasoa.auth_principal_id AS search_auth_user_id, 
                    sasoa.secure_object_id AS search_secure_object_id, 
                    sasoa.secure_access_level_id AS search_sec_access_level_id
                   FROM search_auth_user sau, 
                    search_auth_sec_object_access sasoa
                  WHERE (sau.id = sasoa.auth_principal_id)
        UNION 
                 SELECT sasoa.auth_sec_obj_access_id AS search_auth_user_sec_access_id, 
                    sagm.auth_user_id AS search_auth_user_id, 
                    sasoa.secure_object_id AS search_secure_object_id, 
                    sasoa.secure_access_level_id AS search_sec_access_level_id
                   FROM search_auth_group sag, 
                    search_auth_group_member sagm, 
                    search_auth_sec_object_access sasoa
                  WHERE ((sag.id = sagm.auth_group_id) AND (sag.id = sasoa.auth_principal_id)))
UNION 
         SELECT sasoa.auth_sec_obj_access_id AS search_auth_user_sec_access_id, 
            NULL::bigint AS search_auth_user_id, 
            sasoa.secure_object_id AS search_secure_object_id, 
            sasoa.secure_access_level_id AS search_sec_access_level_id
           FROM search_auth_group sag, 
            search_auth_sec_object_access sasoa
          WHERE (((sag.group_category)::text = 'EVERYONE_GROUP'::text) AND (sag.id = sasoa.auth_principal_id));


ALTER TABLE searchapp.search_auth_user_sec_access_v OWNER TO searchapp;

--
-- Name: search_bio_mkr_correl_fast_mv; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_bio_mkr_correl_fast_mv (
    domain_object_id bigint,
    asso_bio_marker_id bigint,
    correl_type character varying(19),
    value_metric bigint,
    mv_id bigint
);


ALTER TABLE searchapp.search_bio_mkr_correl_fast_mv OWNER TO searchapp;

--
-- Name: search_gene_signature; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_gene_signature (
    search_gene_signature_id bigint NOT NULL,
    name character varying(100) NOT NULL,
    description character varying(1000),
    unique_id character varying(50),
    create_date timestamp without time zone NOT NULL,
    created_by_auth_user_id bigint NOT NULL,
    last_modified_date timestamp without time zone,
    modified_by_auth_user_id bigint,
    version_number character varying(50),
    public_flag boolean DEFAULT false,
    deleted_flag boolean DEFAULT false,
    parent_gene_signature_id bigint,
    source_concept_id bigint,
    source_other character varying(255),
    owner_concept_id bigint,
    stimulus_description character varying(1000),
    stimulus_dosing character varying(255),
    treatment_description character varying(1000),
    treatment_dosing character varying(255),
    treatment_bio_compound_id bigint,
    treatment_protocol_number character varying(50),
    pmid_list character varying(255),
    species_concept_id bigint NOT NULL,
    species_mouse_src_concept_id bigint,
    species_mouse_detail character varying(255),
    tissue_type_concept_id bigint,
    experiment_type_concept_id bigint,
    experiment_type_in_vivo_descr character varying(255),
    experiment_type_atcc_ref character varying(255),
    analytic_cat_concept_id bigint,
    analytic_cat_other character varying(255),
    bio_assay_platform_id bigint NOT NULL,
    analyst_name character varying(100),
    norm_method_concept_id bigint,
    norm_method_other character varying(255),
    analysis_method_concept_id bigint,
    analysis_method_other character varying(255),
    multiple_testing_correction boolean,
    p_value_cutoff_concept_id bigint NOT NULL,
    upload_file character varying(255) NOT NULL,
    search_gene_sig_file_schema_id bigint DEFAULT 1,
    fold_chg_metric_concept_id bigint,
    experiment_type_cell_line_id bigint
);


ALTER TABLE searchapp.search_gene_signature OWNER TO searchapp;

--
-- Name: search_gene_signature_item; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_gene_signature_item (
    search_gene_signature_id bigint NOT NULL,
    bio_marker_id bigint,
    fold_chg_metric bigint,
    bio_data_unique_id character varying(200),
    id bigint NOT NULL,
    bio_assay_feature_group_id bigint
);


ALTER TABLE searchapp.search_gene_signature_item OWNER TO searchapp;

--
-- Name: search_bio_mkr_correl_fast_view; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_bio_mkr_correl_fast_view AS
 SELECT i.search_gene_signature_id AS domain_object_id, 
    i.bio_marker_id AS asso_bio_marker_id, 
    'GENE_SIGNATURE_ITEM' AS correl_type, 
        CASE
            WHEN (i.fold_chg_metric IS NULL) THEN (1)::bigint
            ELSE i.fold_chg_metric
        END AS value_metric, 
    3 AS mv_id
   FROM search_gene_signature_item i, 
    search_gene_signature gs
  WHERE ((i.search_gene_signature_id = gs.search_gene_signature_id) AND (gs.deleted_flag = false));


ALTER TABLE searchapp.search_bio_mkr_correl_fast_view OWNER TO searchapp;

--
-- Name: search_custom_filter; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_custom_filter (
    search_custom_filter_id bigint NOT NULL,
    search_user_id bigint NOT NULL,
    name character varying(200) NOT NULL,
    description character varying(2000),
    private character(1) DEFAULT 'N'::bpchar
);


ALTER TABLE searchapp.search_custom_filter OWNER TO searchapp;

--
-- Name: search_custom_filter_item; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_custom_filter_item (
    search_custom_filter_item_id bigint NOT NULL,
    search_custom_filter_id bigint NOT NULL,
    unique_id character varying(200) NOT NULL,
    bio_data_type character varying(100) NOT NULL
);


ALTER TABLE searchapp.search_custom_filter_item OWNER TO searchapp;

--
-- Name: search_gene_sig_file_schema; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_gene_sig_file_schema (
    search_gene_sig_file_schema_id bigint NOT NULL,
    name character varying(100) NOT NULL,
    description character varying(255),
    number_columns bigint DEFAULT 2,
    supported boolean DEFAULT false
);


ALTER TABLE searchapp.search_gene_sig_file_schema OWNER TO searchapp;

--
-- Name: search_keyword; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_keyword (
    keyword character varying(200),
    bio_data_id bigint,
    unique_id character varying(500) NOT NULL,
    search_keyword_id bigint NOT NULL,
    data_category character varying(200) NOT NULL,
    source_code character varying(100),
    display_data_category character varying(200),
    owner_auth_user_id bigint
);


ALTER TABLE searchapp.search_keyword OWNER TO searchapp;

--
-- Name: search_keyword_term; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_keyword_term (
    keyword_term character varying(200),
    search_keyword_id bigint,
    rank bigint,
    search_keyword_term_id bigint NOT NULL,
    term_length bigint,
    owner_auth_user_id bigint
);


ALTER TABLE searchapp.search_keyword_term OWNER TO searchapp;

--
-- Name: search_request_map; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_request_map (
    id bigint,
    version bigint,
    config_attribute character varying(255),
    url character varying(255)
);


ALTER TABLE searchapp.search_request_map OWNER TO searchapp;

--
-- Name: search_role; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_role (
    id bigint NOT NULL,
    version bigint,
    authority character varying(255),
    description character varying(255)
);


ALTER TABLE searchapp.search_role OWNER TO searchapp;

--
-- Name: search_role_auth_user; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_role_auth_user (
    people_id bigint,
    authorities_id bigint
);


ALTER TABLE searchapp.search_role_auth_user OWNER TO searchapp;

--
-- Name: search_sec_access_level; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_sec_access_level (
    search_sec_access_level_id bigint NOT NULL,
    access_level_name character varying(200),
    access_level_value bigint
);


ALTER TABLE searchapp.search_sec_access_level OWNER TO searchapp;

--
-- Name: search_secure_object; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_secure_object (
    search_secure_object_id bigint NOT NULL,
    bio_data_id bigint,
    display_name character varying(100),
    data_type character varying(200),
    bio_data_unique_id character varying(200)
);


ALTER TABLE searchapp.search_secure_object OWNER TO searchapp;

--
-- Name: search_secure_object_path; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE TABLE search_secure_object_path (
    search_secure_object_id bigint,
    i2b2_concept_path character varying(2000),
    search_secure_obj_path_id bigint NOT NULL
);


ALTER TABLE searchapp.search_secure_object_path OWNER TO searchapp;

--
-- Name: search_user_settings; Type: TABLE; Schema: searchapp; Owner: biomart_user; Tablespace: 
--

CREATE TABLE search_user_settings (
    id bigint NOT NULL,
    setting_name character varying(255) NOT NULL,
    user_id bigint NOT NULL,
    setting_value character varying(255) NOT NULL
);


ALTER TABLE searchapp.search_user_settings OWNER TO biomart_user;

--
-- Name: seq_search_data_id; Type: SEQUENCE; Schema: searchapp; Owner: searchapp
--

CREATE SEQUENCE seq_search_data_id
    START WITH 1789472
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE searchapp.seq_search_data_id OWNER TO searchapp;

SET search_path = tm_cz, pg_catalog;

--
-- Name: annotation_deapp; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE annotation_deapp (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(100),
    gene_id character varying(100),
    probeset_id bigint,
    organism character varying(200)
);


ALTER TABLE tm_cz.annotation_deapp OWNER TO tm_cz;

--
-- Name: cz_job_audit; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE cz_job_audit (
    seq_id bigint NOT NULL,
    job_id bigint NOT NULL,
    database_name character varying(50),
    procedure_name character varying(100),
    step_desc character varying(1000),
    step_status character varying(50),
    records_manipulated bigint,
    step_number bigint,
    job_date timestamp without time zone,
    time_elapsed_secs double precision DEFAULT 0
);


ALTER TABLE tm_cz.cz_job_audit OWNER TO tm_cz;

--
-- Name: cz_job_error; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE cz_job_error (
    job_id bigint NOT NULL,
    error_number character varying(30),
    error_message character varying(1000),
    error_stack character varying(2000),
    seq_id bigint NOT NULL,
    error_backtrace character varying(2000)
);


ALTER TABLE tm_cz.cz_job_error OWNER TO tm_cz;

--
-- Name: cz_job_master; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE cz_job_master (
    job_id bigint NOT NULL,
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    active character varying(1),
    time_elapsed_secs double precision DEFAULT 0,
    build_id bigint,
    session_id bigint,
    database_name character varying(50),
    job_status character varying(50),
    job_name character varying(500)
);


ALTER TABLE tm_cz.cz_job_master OWNER TO tm_cz;

--
-- Name: cz_job_message; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE cz_job_message (
    job_id bigint NOT NULL,
    message_id bigint,
    message_line bigint,
    message_procedure character varying(100),
    info_message character varying(2000),
    seq_id bigint NOT NULL
);


ALTER TABLE tm_cz.cz_job_message OWNER TO tm_cz;

--
-- Name: emt_temp_seq; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE emt_temp_seq
    START WITH 11621
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.emt_temp_seq OWNER TO tm_cz;

--
-- Name: node_curation; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE node_curation (
    node_type character varying(25),
    node_name character varying(250),
    display_name character varying(250),
    display_in_ui character(1),
    data_type character(1),
    global_flag character(1),
    study_id character varying(30),
    curator_name character varying(250),
    curation_date timestamp without time zone,
    active_flag character(1)
);


ALTER TABLE tm_cz.node_curation OWNER TO tm_cz;

--
-- Name: probeset_deapp; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE probeset_deapp (
    probeset_id bigint NOT NULL,
    probeset character varying(100) NOT NULL,
    platform character varying(100) NOT NULL,
    organism character varying(200)
);


ALTER TABLE tm_cz.probeset_deapp OWNER TO tm_cz;

--
-- Name: rtqalimits_testid_seq; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE rtqalimits_testid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.rtqalimits_testid_seq OWNER TO tm_cz;

--
-- Name: rtqastatslist_testid_seq; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE rtqastatslist_testid_seq
    START WITH 80000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.rtqastatslist_testid_seq OWNER TO tm_cz;

--
-- Name: seq_child_rollup_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_child_rollup_id
    START WITH 1681
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.seq_child_rollup_id OWNER TO tm_cz;

--
-- Name: seq_cz; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz
    START WITH 141
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999
    CACHE 20;


ALTER TABLE tm_cz.seq_cz OWNER TO tm_cz;

--
-- Name: seq_cz_data; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_data
    START WITH 5
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_data OWNER TO tm_cz;

--
-- Name: seq_cz_data_file; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_data_file
    START WITH 6
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_data_file OWNER TO tm_cz;

--
-- Name: seq_cz_dw_version_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_dw_version_id
    START WITH 41
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_dw_version_id OWNER TO tm_cz;

--
-- Name: seq_cz_job_audit; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_job_audit
    START WITH 123843
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_job_audit OWNER TO tm_cz;

--
-- Name: seq_cz_job_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_job_id
    START WITH 413
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.seq_cz_job_id OWNER TO tm_cz;

--
-- Name: seq_cz_job_master; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_job_master
    START WITH 12627
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_job_master OWNER TO tm_cz;

--
-- Name: seq_cz_job_message; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_job_message
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_job_message OWNER TO tm_cz;

--
-- Name: seq_cz_person_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_person_id
    START WITH 41
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_person_id OWNER TO tm_cz;

--
-- Name: seq_cz_test; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_test
    START WITH 8259
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_test OWNER TO tm_cz;

--
-- Name: seq_cz_test_category; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_test_category
    START WITH 5
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_test_category OWNER TO tm_cz;

--
-- Name: seq_probeset_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_probeset_id
    START WITH 230000
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999
    CACHE 20;


ALTER TABLE tm_cz.seq_probeset_id OWNER TO tm_cz;

--
-- Name: table_index; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE table_index (
    schema_name character varying(1000),
    table_name character varying(1000),
    index_name character varying(1000),
    index_sql character varying(4000)
);


ALTER TABLE tm_cz.table_index OWNER TO tm_cz;

--
-- Name: tmp_num_data_types; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE tmp_num_data_types (
    category_cd character varying(200),
    data_label character varying(500),
    period character varying(100),
    sample_type character varying(100),
    visit_name character varying(100)
);


ALTER TABLE tm_cz.tmp_num_data_types OWNER TO tm_cz;

--
-- Name: tmp_subject_info; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE tmp_subject_info (
    usubjid character varying(100),
    age_in_years_num smallint,
    sex_cd character varying(50),
    race_cd character varying(50)
);


ALTER TABLE tm_cz.tmp_subject_info OWNER TO tm_cz;

--
-- Name: tmp_trial_data; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE tmp_trial_data (
    usubjid character varying(50),
    study_id character varying(25),
    data_type character(1),
    visit_name character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    unit_cd character varying(50),
    category_path character varying(250),
    sub_category_path_1 character varying(250),
    sub_category_path_2 character varying(250),
    patient_num bigint,
    sourcesystem_cd character varying(50),
    base_path character varying(1250)
);


ALTER TABLE tm_cz.tmp_trial_data OWNER TO tm_cz;

--
-- Name: tmp_trial_nodes; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE TABLE tmp_trial_nodes (
    leaf_node character varying(4000),
    category_cd character varying(200),
    visit_name character varying(100),
    sample_type character varying(100),
    period character varying(100),
    data_label character varying(500),
    node_name character varying(500),
    data_value character varying(500)
);


ALTER TABLE tm_cz.tmp_trial_nodes OWNER TO tm_cz;

SET search_path = tm_lz, pg_catalog;

--
-- Name: lt_src_clinical_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: 
--

CREATE TABLE lt_src_clinical_data (
    study_id character varying(25),
    site_id character varying(50),
    subject_id character varying(20),
    visit_name character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    category_cd character varying(250),
    ctrl_vocab_code character varying(200),
    visit_date character varying(200),
    units_cd character varying(200),
    end_date character varying(200),
    obs_string character varying(200),
    valuetype_cd character varying(200),
    date_ind character varying(200)
);


ALTER TABLE tm_lz.lt_src_clinical_data OWNER TO tm_lz;

--
-- Name: lt_src_deapp_annot; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: 
--

CREATE TABLE lt_src_deapp_annot (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(100),
    gene_id character varying(250),
    organism character varying(200)
);


ALTER TABLE tm_lz.lt_src_deapp_annot OWNER TO tm_lz;

--
-- Name: lt_src_mrna_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: 
--

CREATE TABLE lt_src_mrna_data (
    trial_name character varying(25),
    probeset character varying(100),
    expr_id character varying(100),
    intensity_value character varying(50)
);


ALTER TABLE tm_lz.lt_src_mrna_data OWNER TO tm_lz;

--
-- Name: lt_src_mrna_subj_samp_map; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: 
--

CREATE TABLE lt_src_mrna_subj_samp_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200),
    source_cd character varying(200)
);


ALTER TABLE tm_lz.lt_src_mrna_subj_samp_map OWNER TO tm_lz;

--
-- Name: lt_src_study_metadata; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: 
--

CREATE TABLE lt_src_study_metadata (
    study_id character varying(100),
    title character varying(1000),
    description character varying(2000),
    design character varying(2000),
    start_date character varying(50),
    completion_date character varying(50),
    primary_investigator character varying(400),
    contact_field character varying(400),
    status character varying(100),
    overall_design character varying(2000),
    institution character varying(100),
    country character varying(50),
    biomarker_type character varying(255),
    target character varying(255),
    access_type character varying(100),
    study_owner character varying(510),
    study_phase character varying(100),
    blinding_procedure character varying(1000),
    studytype character varying(510),
    duration_of_study_weeks character varying(200),
    number_of_patients character varying(200),
    number_of_sites character varying(200),
    route_of_administration character varying(510),
    dosing_regimen character varying(3500),
    group_assignment character varying(510),
    type_of_control character varying(510),
    primary_end_points character varying(2000),
    secondary_end_points character varying(3500),
    inclusion_criteria character varying(4000),
    exclusion_criteria character varying(4000),
    subjects character varying(2000),
    gender_restriction_mfb character varying(510),
    min_age character varying(100),
    max_age character varying(100),
    secondary_ids character varying(510),
    development_partner character varying(100),
    geo_platform character varying(100),
    main_findings character varying(2000),
    search_area character varying(100),
    compound character varying(1000),
    disease character varying(1000),
    pubmed_ids character varying(1000),
    organism character varying(200)
);


ALTER TABLE tm_lz.lt_src_study_metadata OWNER TO tm_lz;

SET search_path = tm_wz, pg_catalog;

--
-- Name: wrk_clinical_data; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wrk_clinical_data (
    study_id character varying(25),
    site_id character varying(50),
    subject_id character varying(20),
    visit_name character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    category_cd character varying(250),
    usubjid character varying(200),
    category_path character varying(1000),
    data_type character varying(10),
    ctrl_vocab_code character varying(200),
    visit_date character varying(50),
    units_cd character varying(200),
    end_date character varying(200),
    obs_string character varying(200),
    valuetype_cd character varying(20),
    date_ind character varying(20)
);


ALTER TABLE tm_wz.wrk_clinical_data OWNER TO tm_wz;

--
-- Name: wrk_mrna_data; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wrk_mrna_data (
    probeset character varying(100),
    expr_id character varying(100),
    raw_intensity character varying(50)
);


ALTER TABLE tm_wz.wrk_mrna_data OWNER TO tm_wz;

--
-- Name: wt_clinical_data_dups; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_clinical_data_dups (
    site_id character varying(50),
    subject_id character varying(20),
    visit_name character varying(100),
    data_label character varying(500),
    category_cd character varying(250)
);


ALTER TABLE tm_wz.wt_clinical_data_dups OWNER TO tm_wz;

--
-- Name: wt_del_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_del_nodes (
    c_fullname character varying(1000),
    c_basecode character varying(1000)
);


ALTER TABLE tm_wz.wt_del_nodes OWNER TO tm_wz;

--
-- Name: wt_folder_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_folder_nodes (
    folder_path character varying(1000)
);


ALTER TABLE tm_wz.wt_folder_nodes OWNER TO tm_wz;

--
-- Name: wt_mrna_node_values; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_mrna_node_values (
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    transform_method character varying(2000)
);


ALTER TABLE tm_wz.wt_mrna_node_values OWNER TO tm_wz;

--
-- Name: wt_mrna_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_mrna_nodes (
    leaf_node character varying(2000),
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    node_name character varying(2000),
    concept_cd character varying(100),
    transform_method character varying(2000),
    node_type character varying(50)
);


ALTER TABLE tm_wz.wt_mrna_nodes OWNER TO tm_wz;

--
-- Name: wt_num_data_types; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_num_data_types (
    category_cd character varying(200),
    data_label character varying(500),
    visit_name character varying(100)
);


ALTER TABLE tm_wz.wt_num_data_types OWNER TO tm_wz;

--
-- Name: wt_subject_info; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_subject_info (
    usubjid character varying(100),
    age_in_years_num smallint,
    sex_cd character varying(50),
    race_cd character varying(50)
);


ALTER TABLE tm_wz.wt_subject_info OWNER TO tm_wz;

--
-- Name: wt_subject_microarray_calcs; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_subject_microarray_calcs (
    probeset_id bigint,
    mean_intensity numeric(18,4),
    median_intensity numeric(18,4),
    stddev_intensity numeric(18,4)
);


ALTER TABLE tm_wz.wt_subject_microarray_calcs OWNER TO tm_wz;

--
-- Name: wt_subject_microarray_logs; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_subject_microarray_logs (
    assay_id bigint,
    probeset_id bigint,
    patient_id bigint,
    raw_intensity numeric(18,4),
    log_intensity numeric(18,4)
);


ALTER TABLE tm_wz.wt_subject_microarray_logs OWNER TO tm_wz;

--
-- Name: wt_subject_microarray_med; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_subject_microarray_med (
    probeset_id bigint,
    intensity_value bigint,
    log_intensity bigint,
    assay_id bigint,
    patient_id bigint,
    mean_intensity bigint,
    stddev_intensity bigint,
    median_intensity bigint,
    zscore bigint
);


ALTER TABLE tm_wz.wt_subject_microarray_med OWNER TO tm_wz;

--
-- Name: wt_subject_mrna_data; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_subject_mrna_data (
    probeset character varying(500),
    expr_id character varying(500),
    intensity_value bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_mrna_data OWNER TO tm_wz;

--
-- Name: wt_subject_mrna_probeset; Type: TABLE; Schema: tm_wz; Owner: postgres; Tablespace: 
--

CREATE TABLE wt_subject_mrna_probeset (
    probeset_id bigint,
    patient_id bigint,
    intensity_value numeric(18,4),
    assay_id bigint
);


ALTER TABLE tm_wz.wt_subject_mrna_probeset OWNER TO postgres;

--
-- Name: wt_trial_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_trial_nodes (
    leaf_node character varying(4000),
    category_cd character varying(200),
    visit_name character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    data_type character varying(10),
    obs_string character varying(200),
    valuetype_cd character varying(20),
    node_name character varying(1000)
);


ALTER TABLE tm_wz.wt_trial_nodes OWNER TO tm_wz;

SET search_path = deapp, pg_catalog;

--
-- Name: region_id; Type: DEFAULT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_chromosomal_region ALTER COLUMN region_id SET DEFAULT nextval('de_chromosomal_region_region_id_seq'::regclass);


SET search_path = biomart, pg_catalog;

--
-- Name: bio_aa_data_t_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_aa_data_t_pk PRIMARY KEY (bio_asy_analysis_data_id);


--
-- Name: bio_assay_analysis_platform_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_asy_analysis_pltfm
    ADD CONSTRAINT bio_assay_analysis_platform_pk PRIMARY KEY (bio_asy_analysis_pltfm_id);


--
-- Name: bio_assay_platform_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_assay_platform
    ADD CONSTRAINT bio_assay_platform_pk PRIMARY KEY (bio_assay_platform_id);


--
-- Name: bio_assay_sample_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_assay_sample
    ADD CONSTRAINT bio_assay_sample_pk PRIMARY KEY (bio_assay_id, bio_sample_id, bio_clinic_trial_timepoint_id);


--
-- Name: bio_asy_dt_stats_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_asy_data_stats_all
    ADD CONSTRAINT bio_asy_dt_stats_pk PRIMARY KEY (bio_assay_data_stats_id);


--
-- Name: bio_asy_dt_stats_s_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_stats_s_pk PRIMARY KEY (bio_assay_data_stats_id);


--
-- Name: bio_asy_feature_grp_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_assay_feature_group
    ADD CONSTRAINT bio_asy_feature_grp_pk PRIMARY KEY (bio_assay_feature_group_id);


--
-- Name: bio_cancer_gene_curation_fact_; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_cgdcp_data
    ADD CONSTRAINT bio_cancer_gene_curation_fact_ PRIMARY KEY (bio_data_id);


--
-- Name: bio_clinical_trial_patient_grp; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_clinc_trial_attr
    ADD CONSTRAINT bio_clinical_trial_patient_grp PRIMARY KEY (bio_clinc_trial_attr_id);


--
-- Name: bio_clinical_trial_pt_group; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_clinc_trial_pt_group
    ADD CONSTRAINT bio_clinical_trial_pt_group PRIMARY KEY (bio_clinical_trial_p_group_id);


--
-- Name: bio_clinical_trial_time_point_; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_clinc_trial_time_pt
    ADD CONSTRAINT bio_clinical_trial_time_point_ PRIMARY KEY (bio_clinc_trial_tm_pt_id);


--
-- Name: bio_concept_code_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_concept_code
    ADD CONSTRAINT bio_concept_code_pk PRIMARY KEY (bio_concept_code_id);


--
-- Name: bio_concept_code_uk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_concept_code
    ADD CONSTRAINT bio_concept_code_uk UNIQUE (bio_concept_code, code_type_name);


--
-- Name: bio_content_ref_n_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_content_reference
    ADD CONSTRAINT bio_content_ref_n_pk PRIMARY KEY (bio_content_reference_id);


--
-- Name: bio_data_analysis_dataset_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_asy_analysis_dataset
    ADD CONSTRAINT bio_data_analysis_dataset_pk PRIMARY KEY (bio_assay_dataset_id, bio_assay_analysis_id);


--
-- Name: bio_data_anl_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_assay_analysis
    ADD CONSTRAINT bio_data_anl_pk PRIMARY KEY (bio_assay_analysis_id);


--
-- Name: bio_data_attr_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_data_attribute
    ADD CONSTRAINT bio_data_attr_pk PRIMARY KEY (bio_data_attribute_id);


--
-- Name: bio_data_compound_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_data_compound
    ADD CONSTRAINT bio_data_compound_pk PRIMARY KEY (bio_data_id, bio_compound_id);


--
-- Name: bio_data_correlation_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_data_correlation
    ADD CONSTRAINT bio_data_correlation_pk PRIMARY KEY (bio_data_correl_id);


--
-- Name: bio_data_disease_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_data_disease
    ADD CONSTRAINT bio_data_disease_pk PRIMARY KEY (bio_data_id, bio_disease_id);


--
-- Name: bio_data_ext_code_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_data_ext_code
    ADD CONSTRAINT bio_data_ext_code_pk PRIMARY KEY (bio_data_ext_code_id);


--
-- Name: bio_data_literature_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_data_literature
    ADD CONSTRAINT bio_data_literature_pk PRIMARY KEY (bio_data_id);


--
-- Name: bio_data_uid_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_data_uid
    ADD CONSTRAINT bio_data_uid_pk PRIMARY KEY (bio_data_id);


--
-- Name: bio_data_uid_uk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_data_uid
    ADD CONSTRAINT bio_data_uid_uk UNIQUE (unique_id);


--
-- Name: bio_dataset_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_assay_dataset
    ADD CONSTRAINT bio_dataset_pk PRIMARY KEY (bio_assay_dataset_id);


--
-- Name: bio_experiment_data_fact_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_assay_data
    ADD CONSTRAINT bio_experiment_data_fact_pk PRIMARY KEY (bio_assay_data_id);


--
-- Name: bio_external_analysis_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_curation_dataset
    ADD CONSTRAINT bio_external_analysis_pk PRIMARY KEY (bio_curation_dataset_id);


--
-- Name: bio_externalanalysis_fact_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_curated_data
    ADD CONSTRAINT bio_externalanalysis_fact_pk PRIMARY KEY (bio_data_id);


--
-- Name: bio_lit_alt_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_lit_alt_data
    ADD CONSTRAINT bio_lit_alt_data_pk PRIMARY KEY (bio_lit_alt_data_id);


--
-- Name: bio_lit_amd_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_lit_amd_data
    ADD CONSTRAINT bio_lit_amd_data_pk PRIMARY KEY (bio_lit_amd_data_id);


--
-- Name: bio_lit_inh_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_lit_inh_data
    ADD CONSTRAINT bio_lit_inh_data_pk PRIMARY KEY (bio_lit_inh_data_id);


--
-- Name: bio_lit_int_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_lit_int_data
    ADD CONSTRAINT bio_lit_int_data_pk PRIMARY KEY (bio_lit_int_data_id);


--
-- Name: bio_lit_model_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_lit_model_data
    ADD CONSTRAINT bio_lit_model_data_pk PRIMARY KEY (bio_lit_model_data_id);


--
-- Name: bio_lit_pe_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_lit_pe_data
    ADD CONSTRAINT bio_lit_pe_data_pk PRIMARY KEY (bio_lit_pe_data_id);


--
-- Name: bio_lit_ref_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_lit_ref_data
    ADD CONSTRAINT bio_lit_ref_data_pk PRIMARY KEY (bio_lit_ref_data_id);


--
-- Name: bio_lit_sum_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_lit_sum_data
    ADD CONSTRAINT bio_lit_sum_data_pk PRIMARY KEY (bio_lit_sum_data_id);


--
-- Name: bio_marker_relationship_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_data_correl_descr
    ADD CONSTRAINT bio_marker_relationship_pk PRIMARY KEY (bio_data_correl_descr_id);


--
-- Name: bio_patient_attribute_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_patient_event_attr
    ADD CONSTRAINT bio_patient_attribute_pk PRIMARY KEY (bio_patient_attribute_id);


--
-- Name: bio_patient_event_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_patient_event
    ADD CONSTRAINT bio_patient_event_pk PRIMARY KEY (bio_patient_event_id);


--
-- Name: bio_patient_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_patient
    ADD CONSTRAINT bio_patient_pk PRIMARY KEY (bio_patient_id);


--
-- Name: bio_s_e_m_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_stats_exp_marker
    ADD CONSTRAINT bio_s_e_m_pk PRIMARY KEY (bio_marker_id, bio_experiment_id);


--
-- Name: bio_subject_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_subject
    ADD CONSTRAINT bio_subject_pk PRIMARY KEY (bio_subject_id);


--
-- Name: bio_taxon_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_taxonomy
    ADD CONSTRAINT bio_taxon_pk PRIMARY KEY (bio_taxonomy_id);


--
-- Name: biobank_sample_pkey; Type: CONSTRAINT; Schema: biomart; Owner: biomart_user; Tablespace: 
--

ALTER TABLE ONLY biobank_sample
    ADD CONSTRAINT biobank_sample_pkey PRIMARY KEY (sample_tube_id);


--
-- Name: biomarker_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_marker
    ADD CONSTRAINT biomarker_pk PRIMARY KEY (bio_marker_id);


--
-- Name: biosample_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_sample
    ADD CONSTRAINT biosample_pk PRIMARY KEY (bio_sample_id);


--
-- Name: celllinedictionary_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_cell_line
    ADD CONSTRAINT celllinedictionary_pk PRIMARY KEY (bio_cell_line_id);


--
-- Name: clinicaltrialdim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_clinical_trial
    ADD CONSTRAINT clinicaltrialdim_pk PRIMARY KEY (bio_experiment_id);


--
-- Name: compounddim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_compound
    ADD CONSTRAINT compounddim_pk PRIMARY KEY (bio_compound_id);


--
-- Name: diseasedim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_disease
    ADD CONSTRAINT diseasedim_pk PRIMARY KEY (bio_disease_id);


--
-- Name: experimentdim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_experiment
    ADD CONSTRAINT experimentdim_pk PRIMARY KEY (bio_experiment_id);


--
-- Name: external_file_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_content
    ADD CONSTRAINT external_file_pk PRIMARY KEY (bio_file_content_id);


--
-- Name: external_file_repository_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_content_repository
    ADD CONSTRAINT external_file_repository_pk PRIMARY KEY (bio_content_repo_id);


--
-- Name: rbmorderdim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_assay
    ADD CONSTRAINT rbmorderdim_pk PRIMARY KEY (bio_assay_id);


--
-- Name: sys_c0020430; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: 
--

ALTER TABLE ONLY bio_marker
    ADD CONSTRAINT sys_c0020430 UNIQUE (organism, primary_external_id);


SET search_path = deapp, pg_catalog;

--
-- Name: de_chromosomal_region_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_chromosomal_region
    ADD CONSTRAINT de_chromosomal_region_pkey PRIMARY KEY (region_id);


--
-- Name: de_gpl_info_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_gpl_info
    ADD CONSTRAINT de_gpl_info_pkey PRIMARY KEY (platform);


--
-- Name: de_subject_acgh_data_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_subject_acgh_data
    ADD CONSTRAINT de_subject_acgh_data_pkey PRIMARY KEY (assay_id, region_id);


--
-- Name: dextpn_parent_node_u; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_xtrial_parent_names
    ADD CONSTRAINT dextpn_parent_node_u UNIQUE (across_path);


--
-- Name: sys_c0020600; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_snp_probe_sorted_def
    ADD CONSTRAINT sys_c0020600 PRIMARY KEY (snp_probe_sorted_def_id);


--
-- Name: sys_c0020601; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_snp_data_by_probe
    ADD CONSTRAINT sys_c0020601 PRIMARY KEY (snp_data_by_probe_id);


--
-- Name: sys_c0020602; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_snp_data_by_patient
    ADD CONSTRAINT sys_c0020602 PRIMARY KEY (snp_data_by_patient_id);


--
-- Name: sys_c0020604; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_xtrial_parent_names
    ADD CONSTRAINT sys_c0020604 PRIMARY KEY (parent_cd);


--
-- Name: sys_c0020605; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_xtrial_child_map
    ADD CONSTRAINT sys_c0020605 PRIMARY KEY (concept_cd);


--
-- Name: sys_c0020606; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_subject_snp_dataset
    ADD CONSTRAINT sys_c0020606 PRIMARY KEY (subject_snp_dataset_id);


--
-- Name: sys_c0020607; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_snp_subject_sorted_def
    ADD CONSTRAINT sys_c0020607 PRIMARY KEY (snp_subject_sorted_def_id);


--
-- Name: sys_c0020609; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_snp_probe
    ADD CONSTRAINT sys_c0020609 PRIMARY KEY (snp_probe_id);


--
-- Name: sys_c0020611; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_snp_info
    ADD CONSTRAINT sys_c0020611 PRIMARY KEY (snp_info_id);


--
-- Name: u_snp_info_name; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_snp_info
    ADD CONSTRAINT u_snp_info_name UNIQUE (name);


--
-- Name: u_snp_probe_name; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: 
--

ALTER TABLE ONLY de_snp_probe
    ADD CONSTRAINT u_snp_probe_name UNIQUE (probe_name);


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: analysis_plugin_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_analysis_plugin
    ADD CONSTRAINT analysis_plugin_pk PRIMARY KEY (plugin_id);


--
-- Name: analysis_plugin_result_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_analysis_plugin_result_type
    ADD CONSTRAINT analysis_plugin_result_pk PRIMARY KEY (plugin_id, result_type_id);


--
-- Name: code_lookup_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY code_lookup
    ADD CONSTRAINT code_lookup_pk PRIMARY KEY (table_cd, column_cd, code_cd);


--
-- Name: concept_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY concept_dimension
    ADD CONSTRAINT concept_dimension_pk PRIMARY KEY (concept_path);


--
-- Name: encounter_mapping_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY encounter_mapping
    ADD CONSTRAINT encounter_mapping_pk PRIMARY KEY (encounter_ide, encounter_ide_source);


--
-- Name: modifier_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY modifier_dimension
    ADD CONSTRAINT modifier_dimension_pk PRIMARY KEY (modifier_path);


--
-- Name: observation_fact_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY observation_fact
    ADD CONSTRAINT observation_fact_pkey PRIMARY KEY (patient_num, concept_cd, provider_id, modifier_cd);


--
-- Name: patient_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY patient_dimension
    ADD CONSTRAINT patient_dimension_pk PRIMARY KEY (patient_num);


--
-- Name: patient_mapping_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY patient_mapping
    ADD CONSTRAINT patient_mapping_pk PRIMARY KEY (patient_ide, patient_ide_source);


--
-- Name: pk_sourcemaster_sourcecd; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY source_master
    ADD CONSTRAINT pk_sourcemaster_sourcecd PRIMARY KEY (source_cd);


--
-- Name: pk_st_id; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY set_type
    ADD CONSTRAINT pk_st_id PRIMARY KEY (id);


--
-- Name: pk_up_upstatus_idsettypeid; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY set_upload_status
    ADD CONSTRAINT pk_up_upstatus_idsettypeid PRIMARY KEY (upload_id, set_type_id);


--
-- Name: pk_up_upstatus_uploadid; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY upload_status
    ADD CONSTRAINT pk_up_upstatus_uploadid PRIMARY KEY (upload_id);


--
-- Name: provider_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY provider_dimension
    ADD CONSTRAINT provider_dimension_pk PRIMARY KEY (provider_path, provider_id);


--
-- Name: qt_patient_enc_collection_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_patient_enc_collection
    ADD CONSTRAINT qt_patient_enc_collection_pkey PRIMARY KEY (patient_enc_coll_id);


--
-- Name: qt_patient_set_collection_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_patient_set_collection
    ADD CONSTRAINT qt_patient_set_collection_pkey PRIMARY KEY (patient_set_coll_id);


--
-- Name: qt_pdo_query_master_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_pdo_query_master
    ADD CONSTRAINT qt_pdo_query_master_pkey PRIMARY KEY (query_master_id);


--
-- Name: qt_query_instance_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_query_instance
    ADD CONSTRAINT qt_query_instance_pkey PRIMARY KEY (query_instance_id);


--
-- Name: qt_query_master_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_query_master
    ADD CONSTRAINT qt_query_master_pkey PRIMARY KEY (query_master_id);


--
-- Name: qt_query_result_instance_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_query_result_instance
    ADD CONSTRAINT qt_query_result_instance_pkey PRIMARY KEY (result_instance_id);


--
-- Name: qt_query_result_type_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_query_result_type
    ADD CONSTRAINT qt_query_result_type_pkey PRIMARY KEY (result_type_id);


--
-- Name: qt_query_status_type_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_query_status_type
    ADD CONSTRAINT qt_query_status_type_pkey PRIMARY KEY (status_type_id);


--
-- Name: qt_xml_result_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY qt_xml_result
    ADD CONSTRAINT qt_xml_result_pkey PRIMARY KEY (xml_result_id);


--
-- Name: visit_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

ALTER TABLE ONLY visit_dimension
    ADD CONSTRAINT visit_dimension_pk PRIMARY KEY (encounter_num, patient_num);


SET search_path = i2b2hive, pg_catalog;

--
-- Name: analsis_job_pk; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY crc_analysis_job
    ADD CONSTRAINT analsis_job_pk PRIMARY KEY (job_id);


--
-- Name: crc_db_lookup_pk; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY crc_db_lookup
    ADD CONSTRAINT crc_db_lookup_pk PRIMARY KEY (c_domain_id, c_project_path, c_owner_id);


--
-- Name: hilo_pk; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY hilosequences
    ADD CONSTRAINT hilo_pk PRIMARY KEY (sequencename);


--
-- Name: jms_messages_pkey; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY jms_messages
    ADD CONSTRAINT jms_messages_pkey PRIMARY KEY (messageid, destination);


--
-- Name: jms_roles_pkey; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY jms_roles
    ADD CONSTRAINT jms_roles_pkey PRIMARY KEY (userid, roleid);


--
-- Name: jms_subscriptions_pkey; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY jms_subscriptions
    ADD CONSTRAINT jms_subscriptions_pkey PRIMARY KEY (clientid, subname);


--
-- Name: jms_transactions_pkey; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY jms_transactions
    ADD CONSTRAINT jms_transactions_pkey PRIMARY KEY (txid);


--
-- Name: jms_users_pkey; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY jms_users
    ADD CONSTRAINT jms_users_pkey PRIMARY KEY (userid);


--
-- Name: ont_db_lookup_pk; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY ont_db_lookup
    ADD CONSTRAINT ont_db_lookup_pk PRIMARY KEY (c_domain_id, c_project_path, c_owner_id);


--
-- Name: timers_pk; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY timers
    ADD CONSTRAINT timers_pk PRIMARY KEY (timerid, targetid);


--
-- Name: work_db_lookup_pk; Type: CONSTRAINT; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

ALTER TABLE ONLY work_db_lookup
    ADD CONSTRAINT work_db_lookup_pk PRIMARY KEY (c_domain_id, c_project_path, c_owner_id);


SET search_path = i2b2metadata, pg_catalog;

--
-- Name: ont_process_status_pkey; Type: CONSTRAINT; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

ALTER TABLE ONLY ont_process_status
    ADD CONSTRAINT ont_process_status_pkey PRIMARY KEY (process_id);


--
-- Name: schemes_pk; Type: CONSTRAINT; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

ALTER TABLE ONLY schemes
    ADD CONSTRAINT schemes_pk PRIMARY KEY (c_key);


--
-- Name: table_access_pk; Type: CONSTRAINT; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: 
--

ALTER TABLE ONLY table_access
    ADD CONSTRAINT table_access_pk PRIMARY KEY (c_table_cd);


SET search_path = i2b2pm, pg_catalog;

--
-- Name: pm_cell_data_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_cell_data
    ADD CONSTRAINT pm_cell_data_pkey PRIMARY KEY (cell_id, project_path);


--
-- Name: pm_cell_params_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_cell_params
    ADD CONSTRAINT pm_cell_params_pkey PRIMARY KEY (id);


--
-- Name: pm_global_params_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_global_params
    ADD CONSTRAINT pm_global_params_pkey PRIMARY KEY (id);


--
-- Name: pm_hive_data_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_hive_data
    ADD CONSTRAINT pm_hive_data_pkey PRIMARY KEY (domain_id);


--
-- Name: pm_hive_params_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_hive_params
    ADD CONSTRAINT pm_hive_params_pkey PRIMARY KEY (id);


--
-- Name: pm_project_data_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_project_data
    ADD CONSTRAINT pm_project_data_pkey PRIMARY KEY (project_id);


--
-- Name: pm_project_params_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_project_params
    ADD CONSTRAINT pm_project_params_pkey PRIMARY KEY (id);


--
-- Name: pm_project_user_params_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_project_user_params
    ADD CONSTRAINT pm_project_user_params_pkey PRIMARY KEY (id);


--
-- Name: pm_project_user_roles_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_project_user_roles
    ADD CONSTRAINT pm_project_user_roles_pkey PRIMARY KEY (project_id, user_id, user_role_cd);


--
-- Name: pm_role_requirement_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_role_requirement
    ADD CONSTRAINT pm_role_requirement_pkey PRIMARY KEY (table_cd, column_cd, read_hivemgmt_cd, write_hivemgmt_cd);


--
-- Name: pm_user_data_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_user_data
    ADD CONSTRAINT pm_user_data_pkey PRIMARY KEY (user_id);


--
-- Name: pm_user_params_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_user_params
    ADD CONSTRAINT pm_user_params_pkey PRIMARY KEY (id);


--
-- Name: pm_user_session_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: i2b2pm; Tablespace: 
--

ALTER TABLE ONLY pm_user_session
    ADD CONSTRAINT pm_user_session_pkey PRIMARY KEY (session_id, user_id);


--
-- Name: trip_pkey; Type: CONSTRAINT; Schema: i2b2pm; Owner: biomart_user; Tablespace: 
--

ALTER TABLE ONLY trip
    ADD CONSTRAINT trip_pkey PRIMARY KEY (id);


SET search_path = i2b2workdata, pg_catalog;

--
-- Name: workplace_access_pk; Type: CONSTRAINT; Schema: i2b2workdata; Owner: i2b2workdata; Tablespace: 
--

ALTER TABLE ONLY workplace_access
    ADD CONSTRAINT workplace_access_pk PRIMARY KEY (c_index);


--
-- Name: workplace_pk; Type: CONSTRAINT; Schema: i2b2workdata; Owner: i2b2workdata; Tablespace: 
--

ALTER TABLE ONLY workplace
    ADD CONSTRAINT workplace_pk PRIMARY KEY (c_index);


SET search_path = searchapp, pg_catalog;

--
-- Name: pk_auth_usr_group; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_auth_group
    ADD CONSTRAINT pk_auth_usr_group PRIMARY KEY (id);


--
-- Name: pk_search_principal; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_auth_principal
    ADD CONSTRAINT pk_search_principal PRIMARY KEY (id);


--
-- Name: plugin_module_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY plugin_module
    ADD CONSTRAINT plugin_module_pk PRIMARY KEY (module_seq);


--
-- Name: plugin_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY plugin
    ADD CONSTRAINT plugin_pk PRIMARY KEY (plugin_seq);


--
-- Name: sch_sec_a_a_s_a_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_auth_sec_object_access
    ADD CONSTRAINT sch_sec_a_a_s_a_pk PRIMARY KEY (auth_sec_obj_access_id);


--
-- Name: search_cust_fil_item_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_custom_filter_item
    ADD CONSTRAINT search_cust_fil_item_pk PRIMARY KEY (search_custom_filter_item_id);


--
-- Name: search_custom_filter_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_custom_filter
    ADD CONSTRAINT search_custom_filter_pk PRIMARY KEY (search_custom_filter_id);


--
-- Name: search_gene_sig_descr_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT search_gene_sig_descr_pk PRIMARY KEY (search_gene_signature_id);


--
-- Name: search_gene_sig_file_sche_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_gene_sig_file_schema
    ADD CONSTRAINT search_gene_sig_file_sche_pk PRIMARY KEY (search_gene_sig_file_schema_id);


--
-- Name: search_gene_signature_ite_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_gene_signature_item
    ADD CONSTRAINT search_gene_signature_ite_pk PRIMARY KEY (id);


--
-- Name: search_keyword_uk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_keyword
    ADD CONSTRAINT search_keyword_uk UNIQUE (unique_id, data_category);


--
-- Name: search_kw_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_keyword
    ADD CONSTRAINT search_kw_pk PRIMARY KEY (search_keyword_id);


--
-- Name: search_kw_term_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_keyword_term
    ADD CONSTRAINT search_kw_term_pk PRIMARY KEY (search_keyword_term_id);


--
-- Name: search_sec_a_u_s_a_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_auth_user_sec_access
    ADD CONSTRAINT search_sec_a_u_s_a_pk PRIMARY KEY (search_auth_user_sec_access_id);


--
-- Name: search_sec_ac_level_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_sec_access_level
    ADD CONSTRAINT search_sec_ac_level_pk PRIMARY KEY (search_sec_access_level_id);


--
-- Name: search_sec_obj__path_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_secure_object_path
    ADD CONSTRAINT search_sec_obj__path_pk PRIMARY KEY (search_secure_obj_path_id);


--
-- Name: search_sec_obj_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_secure_object
    ADD CONSTRAINT search_sec_obj_pk PRIMARY KEY (search_secure_object_id);


--
-- Name: search_user_settings_pkey; Type: CONSTRAINT; Schema: searchapp; Owner: biomart_user; Tablespace: 
--

ALTER TABLE ONLY search_user_settings
    ADD CONSTRAINT search_user_settings_pkey PRIMARY KEY (id);


--
-- Name: sys_c0011119; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_auth_user
    ADD CONSTRAINT sys_c0011119 PRIMARY KEY (id);


--
-- Name: sys_c0011120; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: 
--

ALTER TABLE ONLY search_role
    ADD CONSTRAINT sys_c0011120 PRIMARY KEY (id);


SET search_path = biomart, pg_catalog;

--
-- Name: baad_fgn_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baad_fgn_idx ON bio_assay_analysis_data USING btree (feature_group_name);


--
-- Name: baad_idx11; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baad_idx11 ON bio_assay_analysis_data USING btree (bio_experiment_id, bio_assay_analysis_id, bio_asy_analysis_data_id);


--
-- Name: baad_idx12; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baad_idx12 ON bio_assay_analysis_data USING btree (bio_experiment_id, bio_assay_analysis_id, bio_assay_feature_group_id);


--
-- Name: baad_idx14; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baad_idx14 ON bio_assay_analysis_data USING btree (bio_assay_feature_group_id, bio_asy_analysis_data_id);


--
-- Name: baad_idx4; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baad_idx4 ON bio_assay_analysis_data USING btree (bio_assay_platform_id);


--
-- Name: baad_idx6; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baad_idx6 ON bio_assay_analysis_data USING btree (bio_experiment_id, bio_assay_analysis_id);


--
-- Name: baad_idx7; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baad_idx7 ON bio_assay_analysis_data USING btree (bio_assay_analysis_id, bio_asy_analysis_data_id);


--
-- Name: baadt_f_idx13; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baadt_f_idx13 ON bio_assay_analysis_data_tea USING btree (bio_assay_feature_group_id, bio_asy_analysis_data_id);


--
-- Name: baadt_idex12; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baadt_idex12 ON bio_assay_analysis_data_tea USING btree (feature_group_name, bio_asy_analysis_data_id);


--
-- Name: baadt_idx10; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baadt_idx10 ON bio_assay_analysis_data_tea USING btree (bio_assay_feature_group_id, bio_experiment_id);


--
-- Name: baadt_idx11; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baadt_idx11 ON bio_assay_analysis_data_tea USING btree (bio_experiment_id, bio_assay_analysis_id, bio_asy_analysis_data_id);


--
-- Name: baadt_idx17; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baadt_idx17 ON bio_assay_analysis_data_tea USING btree (bio_assay_analysis_id, tea_rank);


--
-- Name: baadt_idx6; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baadt_idx6 ON bio_assay_analysis_data_tea USING btree (bio_experiment_id, bio_assay_analysis_id);


--
-- Name: baadt_idx7; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX baadt_idx7 ON bio_assay_analysis_data_tea USING btree (bio_assay_analysis_id, bio_asy_analysis_data_id);


--
-- Name: bad_idx13; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bad_idx13 ON bio_assay_analysis_data USING btree (bio_assay_analysis_id, bio_assay_feature_group_id);


--
-- Name: bdc_index1; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bdc_index1 ON bio_data_correlation USING btree (asso_bio_data_id);


--
-- Name: bio_a__d_s_ds_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_a__d_s_ds_idx ON bio_asy_data_stats_all USING btree (bio_assay_dataset_id);


--
-- Name: bio_a__d_s_exp_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_a__d_s_exp_idx ON bio_asy_data_stats_all USING btree (bio_experiment_id);


--
-- Name: bio_a__d_s_f_g_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_a__d_s_f_g_idx ON bio_asy_data_stats_all USING btree (feature_group_name);


--
-- Name: bio_a_d_s_ds__s_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_a_d_s_ds__s_idx ON bio_assay_data_stats USING btree (bio_assay_dataset_id);


--
-- Name: bio_a_d_s_exp__s_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_a_d_s_exp__s_idx ON bio_assay_data_stats USING btree (bio_experiment_id);


--
-- Name: bio_a_d_s_f_g_s_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_a_d_s_f_g_s_idx ON bio_assay_data_stats USING btree (feature_group_name, bio_assay_data_stats_id);


--
-- Name: bio_a_d_s_fgi_s_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_a_d_s_fgi_s_idx ON bio_assay_data_stats USING btree (bio_assay_feature_group_id, bio_assay_data_stats_id);


--
-- Name: bio_a_o_an_idx2; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_a_o_an_idx2 ON bio_assay_data_annotation USING btree (bio_assay_feature_group_id, bio_marker_id);


--
-- Name: bio_a_o_fg_id_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_a_o_fg_id_idx ON bio_assay_data_annotation USING btree (bio_assay_feature_group_id);


--
-- Name: bio_assay_analysis_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_assay_analysis_pk ON bio_assay_analysis USING btree (bio_assay_analysis_id);


--
-- Name: bio_assay_data_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_assay_data_pk ON bio_assay_data USING btree (bio_assay_data_id);


--
-- Name: bio_assay_dataset_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_assay_dataset_pk ON bio_assay_dataset USING btree (bio_assay_dataset_id);


--
-- Name: bio_assay_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_assay_pk ON bio_assay USING btree (bio_assay_id);


--
-- Name: bio_asy_analysis_dataset_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_asy_analysis_dataset_pk ON bio_asy_analysis_dataset USING btree (bio_assay_dataset_id, bio_assay_analysis_id);


--
-- Name: bio_asy_analysis_pltfm_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_asy_analysis_pltfm_pk ON bio_asy_analysis_pltfm USING btree (bio_asy_analysis_pltfm_id);


--
-- Name: bio_asy_feature_grp_name_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_asy_feature_grp_name_idx ON bio_assay_feature_group USING btree (feature_group_name, bio_assay_feature_group_id);


--
-- Name: bio_cell_line_dict_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_cell_line_dict_pk ON bio_cell_line USING btree (bio_cell_line_id);


--
-- Name: bio_cell_line_name_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_cell_line_name_idx ON bio_cell_line USING btree (cell_line_name, bio_cell_line_id);


--
-- Name: bio_cgdcp_data_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_cgdcp_data_pk ON bio_cgdcp_data USING btree (bio_data_id);


--
-- Name: bio_clinc_trial_attr_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_clinc_trial_attr_pk ON bio_clinc_trial_attr USING btree (bio_clinc_trial_attr_id);


--
-- Name: bio_clinc_trial_pt_group_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_clinc_trial_pt_group_pk ON bio_clinc_trial_pt_group USING btree (bio_clinical_trial_p_group_id);


--
-- Name: bio_clinc_trial_time_pt_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_clinc_trial_time_pt_pk ON bio_clinc_trial_time_pt USING btree (bio_clinc_trial_tm_pt_id);


--
-- Name: bio_clinical_trial_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_clinical_trial_pk ON bio_clinical_trial USING btree (bio_experiment_id);


--
-- Name: bio_compound_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_compound_pk ON bio_compound USING btree (bio_compound_id);


--
-- Name: bio_concept_code_type_index; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_concept_code_type_index ON bio_concept_code USING btree (code_type_name);


--
-- Name: bio_content_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_content_pk ON bio_content USING btree (bio_file_content_id);


--
-- Name: bio_content_reference_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_content_reference_pk ON bio_content_reference USING btree (bio_content_reference_id);


--
-- Name: bio_content_repository_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_content_repository_pk ON bio_content_repository USING btree (bio_content_repo_id);


--
-- Name: bio_curated_data_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_curated_data_pk ON bio_curated_data USING btree (bio_data_id);


--
-- Name: bio_curation_dataset_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_curation_dataset_pk ON bio_curation_dataset USING btree (bio_curation_dataset_id);


--
-- Name: bio_d_e_c_did_ct_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_d_e_c_did_ct_idx ON bio_data_ext_code USING btree (bio_data_id, code_type);


--
-- Name: bio_d_fg_m_marker2_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_d_fg_m_marker2_pk ON bio_assay_data_annotation USING btree (bio_marker_id, bio_assay_feature_group_id);


--
-- Name: bio_d_o_m_marker2_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_d_o_m_marker2_pk ON bio_data_omic_marker USING btree (bio_marker_id, bio_data_id);


--
-- Name: bio_data_attribute_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_data_attribute_pk ON bio_data_attribute USING btree (bio_data_attribute_id);


--
-- Name: bio_data_correl_descr_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_data_correl_descr_pk ON bio_data_correl_descr USING btree (bio_data_correl_descr_id);


--
-- Name: bio_data_e_c_c_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_data_e_c_c_idx ON bio_data_ext_code USING btree (code);


--
-- Name: bio_data_e_c_t_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_data_e_c_t_idx ON bio_data_ext_code USING btree (code_type);


--
-- Name: bio_data_o_m_did_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_data_o_m_did_idx ON bio_data_omic_marker USING btree (bio_data_id);


--
-- Name: bio_dd_idx2; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_dd_idx2 ON bio_data_disease USING btree (bio_disease_id);


--
-- Name: bio_disease_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_disease_pk ON bio_disease USING btree (bio_disease_id);


--
-- Name: bio_dt_dis_did_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_dt_dis_did_idx ON bio_data_disease USING btree (bio_data_id);


--
-- Name: bio_exp_acen_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_exp_acen_idx ON bio_experiment USING btree (accession);


--
-- Name: bio_exp_type_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_exp_type_idx ON bio_experiment USING btree (bio_experiment_type);


--
-- Name: bio_experiment_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_experiment_pk ON bio_experiment USING btree (bio_experiment_id);


--
-- Name: bio_marker_c_mv_idx1; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_marker_c_mv_idx1 ON bio_marker_correl_mv USING btree (bio_marker_id, asso_bio_marker_id);


--
-- Name: bio_marker_c_mv_idx2; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_marker_c_mv_idx2 ON bio_marker_correl_mv USING btree (asso_bio_marker_id, bio_marker_id);


--
-- Name: bio_marker_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_marker_pk ON bio_marker USING btree (bio_marker_id);


--
-- Name: bio_mkr_ext_id; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_mkr_ext_id ON bio_marker USING btree (primary_external_id);


--
-- Name: bio_mkr_type_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_mkr_type_idx ON bio_marker USING btree (bio_marker_type);


--
-- Name: bio_patient_event_attr_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_patient_event_attr_pk ON bio_patient_event_attr USING btree (bio_patient_attribute_id);


--
-- Name: bio_sample_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX bio_sample_pk ON bio_sample USING btree (bio_sample_id);


--
-- Name: bio_stats_exp_mk_exp_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_stats_exp_mk_exp_idx ON bio_stats_exp_marker USING btree (bio_experiment_id);


--
-- Name: bio_stats_exp_mk_mk_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX bio_stats_exp_mk_mk_idx ON bio_stats_exp_marker USING btree (bio_marker_id);


--
-- Name: idx_baadt_fg_ad; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX idx_baadt_fg_ad ON bio_assay_analysis_data_tea USING btree (bio_assay_feature_group_id, bio_assay_analysis_id);


--
-- Name: idx_baadt_idx10; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX idx_baadt_idx10 ON bio_assay_analysis_data_tea USING btree (bio_experiment_type, bio_asy_analysis_data_id);


--
-- Name: pk_baad; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE UNIQUE INDEX pk_baad ON bio_assay_analysis_data USING btree (bio_asy_analysis_data_id);


--
-- Name: tmp_a_d_tea_r_index1; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: 
--

CREATE INDEX tmp_a_d_tea_r_index1 ON tmp_analysis_data_tea_rank USING btree (analysis_data_id);


SET search_path = deapp, pg_catalog;

--
-- Name: de_microarray_data_idx1; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_microarray_data_idx1 ON de_subject_microarray_data USING btree (trial_name, assay_id, probeset_id);


--
-- Name: de_microarray_data_idx2; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_microarray_data_idx2 ON de_subject_microarray_data USING btree (assay_id, probeset_id);


--
-- Name: de_microarray_data_idx4; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_microarray_data_idx4 ON de_subject_microarray_data USING btree (trial_name);


--
-- Name: de_microarray_data_idx5; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_microarray_data_idx5 ON de_subject_microarray_data USING btree (assay_id, patient_id, probeset_id);


--
-- Name: de_mrna_annotation_index1; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_mrna_annotation_index1 ON de_mrna_annotation USING btree (probeset_id);


--
-- Name: de_pathway_gene_idx4; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_pathway_gene_idx4 ON de_pathway_gene USING btree (gene_symbol);


--
-- Name: de_pathway_gene_index1; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_pathway_gene_index1 ON de_pathway_gene USING btree (pathway_id, gene_symbol);


--
-- Name: de_subject_acgh_data_patient; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_subject_acgh_data_patient ON de_subject_acgh_data USING btree (patient_id);


--
-- Name: de_subject_acgh_data_region; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_subject_acgh_data_region ON de_subject_acgh_data USING btree (region_id);


--
-- Name: de_subject_smpl_mpng_idx2; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX de_subject_smpl_mpng_idx2 ON de_subject_sample_mapping USING btree (patient_id, timepoint_cd, platform_cd, assay_id, trial_name);


--
-- Name: idx_de_microarray_data_1; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX idx_de_microarray_data_1 ON de_subject_microarray_data USING btree (trial_name, assay_id, probeset_id);


--
-- Name: idx_de_microarray_data_2; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX idx_de_microarray_data_2 ON de_subject_microarray_data USING btree (assay_id, probeset_id);


--
-- Name: idx_pathway_gene_pathway; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: 
--

CREATE INDEX idx_pathway_gene_pathway ON de_pathway_gene USING btree (pathway_id);


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: cd_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX cd_uploadid_idx ON concept_dimension USING btree (upload_id);


--
-- Name: cl_idx_name_char; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX cl_idx_name_char ON code_lookup USING btree (name_char);


--
-- Name: cl_idx_uploadid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX cl_idx_uploadid ON code_lookup USING btree (upload_id);


--
-- Name: em_encnum_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX em_encnum_idx ON encounter_mapping USING btree (encounter_num);


--
-- Name: em_idx_encpath; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX em_idx_encpath ON encounter_mapping USING btree (encounter_ide, encounter_ide_source, patient_ide, patient_ide_source, encounter_num);


--
-- Name: em_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX em_uploadid_idx ON encounter_mapping USING btree (upload_id);


--
-- Name: fact_modifier_patient; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX fact_modifier_patient ON observation_fact USING btree (modifier_cd, patient_num);


--
-- Name: idx_concept_dim_1; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX idx_concept_dim_1 ON concept_dimension USING btree (concept_cd);


--
-- Name: idx_concept_dim_2; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX idx_concept_dim_2 ON concept_dimension USING btree (concept_path);


--
-- Name: idx_ob_fact_1; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX idx_ob_fact_1 ON observation_fact USING btree (concept_cd);


--
-- Name: idx_ob_fact_2; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX idx_ob_fact_2 ON observation_fact USING btree (concept_cd, patient_num, encounter_num);


--
-- Name: md_idx_uploadid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX md_idx_uploadid ON modifier_dimension USING btree (upload_id);


--
-- Name: patd_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX patd_uploadid_idx ON patient_dimension USING btree (upload_id);


--
-- Name: pd_idx_allpatientdim; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX pd_idx_allpatientdim ON patient_dimension USING btree (patient_num, vital_status_cd, birth_date, death_date, sex_cd, age_in_years_num, language_cd, race_cd, marital_status_cd, religion_cd, zip_cd, income_cd);


--
-- Name: pd_idx_dates; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX pd_idx_dates ON patient_dimension USING btree (patient_num, vital_status_cd, birth_date, death_date);


--
-- Name: pd_idx_name_char; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX pd_idx_name_char ON provider_dimension USING btree (provider_id, name_char);


--
-- Name: pd_idx_statecityzip; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX pd_idx_statecityzip ON patient_dimension USING btree (statecityzip_path, patient_num);


--
-- Name: pk_archive_obsfact; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX pk_archive_obsfact ON archive_observation_fact USING btree (encounter_num, patient_num, concept_cd, provider_id, start_date, modifier_cd, archive_upload_id);


--
-- Name: pm_encpnum_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX pm_encpnum_idx ON patient_mapping USING btree (patient_ide, patient_ide_source, patient_num);


--
-- Name: pm_patnum_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX pm_patnum_idx ON patient_mapping USING btree (patient_num);


--
-- Name: pm_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX pm_uploadid_idx ON patient_mapping USING btree (upload_id);


--
-- Name: prod_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX prod_uploadid_idx ON provider_dimension USING btree (upload_id);


--
-- Name: qt_apnamevergrp_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX qt_apnamevergrp_idx ON qt_analysis_plugin USING btree (plugin_name, version_cd, group_id);


--
-- Name: qt_idx_pqm_ugid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX qt_idx_pqm_ugid ON qt_pdo_query_master USING btree (user_id, group_id);


--
-- Name: qt_idx_qi_mstartid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX qt_idx_qi_mstartid ON qt_query_instance USING btree (query_master_id, start_date);


--
-- Name: qt_idx_qi_ugid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX qt_idx_qi_ugid ON qt_query_instance USING btree (user_id, group_id);


--
-- Name: qt_idx_qm_ugid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX qt_idx_qm_ugid ON qt_query_master USING btree (user_id, group_id, master_type_cd);


--
-- Name: qt_idx_qpsc_riid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX qt_idx_qpsc_riid ON qt_patient_set_collection USING btree (result_instance_id);


--
-- Name: vd_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX vd_uploadid_idx ON visit_dimension USING btree (upload_id);


--
-- Name: visit_dim_pk; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE UNIQUE INDEX visit_dim_pk ON visit_dimension USING btree (patient_num, encounter_num);


--
-- Name: visitdim_en_pn_lp_io_sd_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX visitdim_en_pn_lp_io_sd_idx ON visit_dimension USING btree (encounter_num, patient_num, location_path, inout_cd, start_date);


--
-- Name: visitdim_std_edd_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX visitdim_std_edd_idx ON visit_dimension USING btree (start_date, end_date);


SET search_path = i2b2hive, pg_catalog;

--
-- Name: crc_idx_aj_qnstid; Type: INDEX; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE INDEX crc_idx_aj_qnstid ON crc_analysis_job USING btree (queue_name, status_type_id);


--
-- Name: jms_messages_destination; Type: INDEX; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE INDEX jms_messages_destination ON jms_messages USING btree (destination);


--
-- Name: jms_messages_txop_txid; Type: INDEX; Schema: i2b2hive; Owner: i2b2hive; Tablespace: 
--

CREATE INDEX jms_messages_txop_txid ON jms_messages USING btree (txop, txid);


SET search_path = searchapp, pg_catalog;

--
-- Name: search_keyword_index1; Type: INDEX; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE INDEX search_keyword_index1 ON search_keyword USING btree (keyword);


--
-- Name: search_keyword_index2; Type: INDEX; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE INDEX search_keyword_index2 ON search_keyword USING btree (bio_data_id);


--
-- Name: search_keyword_index3; Type: INDEX; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE INDEX search_keyword_index3 ON search_keyword USING btree (owner_auth_user_id);


--
-- Name: search_kw_term_skid_idx; Type: INDEX; Schema: searchapp; Owner: searchapp; Tablespace: 
--

CREATE INDEX search_kw_term_skid_idx ON search_keyword_term USING btree (search_keyword_id);


SET search_path = tm_cz, pg_catalog;

--
-- Name: cz_job_audit_pk; Type: INDEX; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE UNIQUE INDEX cz_job_audit_pk ON cz_job_audit USING btree (seq_id);


--
-- Name: cz_job_master_pk; Type: INDEX; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE UNIQUE INDEX cz_job_master_pk ON cz_job_master USING btree (job_id);


--
-- Name: node_curation_pk; Type: INDEX; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE UNIQUE INDEX node_curation_pk ON node_curation USING btree (node_type, node_name, study_id);


--
-- Name: probeset_deapp_i1; Type: INDEX; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE INDEX probeset_deapp_i1 ON probeset_deapp USING btree (probeset_id);


--
-- Name: probeset_deapp_i2; Type: INDEX; Schema: tm_cz; Owner: tm_cz; Tablespace: 
--

CREATE INDEX probeset_deapp_i2 ON probeset_deapp USING btree (probeset, platform);


SET search_path = tm_wz, pg_catalog;

--
-- Name: wt_subject_mrna_calcs_i1; Type: INDEX; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE INDEX wt_subject_mrna_calcs_i1 ON wt_subject_microarray_calcs USING btree (probeset_id);


--
-- Name: wt_subject_mrna_logs_i1; Type: INDEX; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE INDEX wt_subject_mrna_logs_i1 ON wt_subject_microarray_logs USING btree (probeset_id);


SET search_path = biomart, pg_catalog;

--
-- Name: trg_bio_assay_analysis_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_analysis_id BEFORE INSERT ON bio_assay_analysis FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_analysis_id();


--
-- Name: trg_bio_assay_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_data_id BEFORE INSERT ON bio_assay_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_data_id();


--
-- Name: trg_bio_assay_dataset_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_dataset_id BEFORE INSERT ON bio_assay_dataset FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_dataset_id();


--
-- Name: trg_bio_assay_f_g_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_f_g_id BEFORE INSERT ON bio_assay_feature_group FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_f_g_id();


--
-- Name: trg_bio_assay_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_id BEFORE INSERT ON bio_assay FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_id();


--
-- Name: trg_bio_assay_platform_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_platform_id BEFORE INSERT ON bio_assay_platform FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_platform_id();


--
-- Name: trg_bio_asy_analysis_pltfm_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_asy_analysis_pltfm_id BEFORE INSERT ON bio_asy_analysis_pltfm FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_asy_analysis_pltfm_id();


--
-- Name: trg_bio_asy_dt_stats_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_asy_dt_stats_id BEFORE INSERT ON bio_asy_data_stats_all FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_asy_dt_stats_id();


--
-- Name: trg_bio_cell_line_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_cell_line_id BEFORE INSERT ON bio_cell_line FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_cell_line_id();


--
-- Name: trg_bio_cl_trl_time_pt_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_cl_trl_time_pt_id BEFORE INSERT ON bio_clinc_trial_time_pt FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_cl_trl_time_pt_id();


--
-- Name: trg_bio_clin_trl_pt_grp_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_clin_trl_pt_grp_id BEFORE INSERT ON bio_clinc_trial_pt_group FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_clin_trl_pt_grp_id();


--
-- Name: trg_bio_cln_trl_attr_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_cln_trl_attr_id BEFORE INSERT ON bio_clinc_trial_attr FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_cln_trl_attr_id();


--
-- Name: trg_bio_compound_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_compound_id BEFORE INSERT ON bio_compound FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_compound_id();


--
-- Name: trg_bio_concept_code_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_concept_code_id BEFORE INSERT ON bio_concept_code FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_concept_code_id();


--
-- Name: trg_bio_content_ref_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_content_ref_id BEFORE INSERT ON bio_content_reference FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_content_ref_id();


--
-- Name: trg_bio_content_repo_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_content_repo_id BEFORE INSERT ON bio_content_repository FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_content_repo_id();


--
-- Name: trg_bio_curation_dataset_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_curation_dataset_id BEFORE INSERT ON bio_curation_dataset FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_curation_dataset_id();


--
-- Name: trg_bio_data_attr_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_data_attr_id BEFORE INSERT ON bio_data_attribute FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_data_attr_id();


--
-- Name: trg_bio_data_correl_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_data_correl_id BEFORE INSERT ON bio_data_correlation FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_data_correl_id();


--
-- Name: trg_bio_data_ext_code_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_data_ext_code_id BEFORE INSERT ON bio_data_ext_code FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_data_ext_code_id();


--
-- Name: trg_bio_disease_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_disease_id BEFORE INSERT ON bio_disease FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_disease_id();


--
-- Name: trg_bio_experiment_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_experiment_id BEFORE INSERT ON bio_experiment FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_experiment_id();


--
-- Name: trg_bio_file_content_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_file_content_id BEFORE INSERT ON bio_content FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_file_content_id();


--
-- Name: trg_bio_lit_alt_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_alt_data_id BEFORE INSERT ON bio_lit_alt_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_alt_data_id();


--
-- Name: trg_bio_lit_amd_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_amd_data_id BEFORE INSERT ON bio_lit_amd_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_amd_data_id();


--
-- Name: trg_bio_lit_inh_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_inh_data_id BEFORE INSERT ON bio_lit_inh_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_inh_data_id();


--
-- Name: trg_bio_lit_int_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_int_data_id BEFORE INSERT ON bio_lit_int_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_int_data_id();


--
-- Name: trg_bio_lit_model_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_model_data_id BEFORE INSERT ON bio_lit_model_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_model_data_id();


--
-- Name: trg_bio_lit_pe_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_pe_data_id BEFORE INSERT ON bio_lit_pe_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_pe_data_id();


--
-- Name: trg_bio_lit_ref_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_ref_data_id BEFORE INSERT ON bio_lit_ref_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_ref_data_id();


--
-- Name: trg_bio_lit_sum_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_sum_data_id BEFORE INSERT ON bio_lit_sum_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_sum_data_id();


--
-- Name: trg_bio_marker_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_marker_id BEFORE INSERT ON bio_marker FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_marker_id();


--
-- Name: trg_bio_mkr_correl_descr_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_mkr_correl_descr_id BEFORE INSERT ON bio_data_correl_descr FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_mkr_correl_descr_id();


--
-- Name: trg_bio_patient_event_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_patient_event_id BEFORE INSERT ON bio_patient_event FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_patient_event_id();


--
-- Name: trg_bio_patient_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_patient_id BEFORE INSERT ON bio_patient FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_patient_id();


--
-- Name: trg_bio_pt_evt_attr_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_pt_evt_attr_id BEFORE INSERT ON bio_patient_event_attr FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_pt_evt_attr_id();


--
-- Name: trg_bio_sample_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_sample_id BEFORE INSERT ON bio_sample FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_sample_id();


--
-- Name: trg_bio_subject_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_subject_id BEFORE INSERT ON bio_subject FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_subject_id();


--
-- Name: trg_bio_taxon_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_taxon_id BEFORE INSERT ON bio_taxonomy FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_taxon_id();


--
-- Name: trg_ctd2_clin_inhib_effect; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_clin_inhib_effect BEFORE INSERT ON ctd2_clin_inhib_effect FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_clin_inhib_effect();


--
-- Name: trg_ctd2_disease; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_disease BEFORE INSERT ON ctd2_disease FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_disease();


--
-- Name: trg_ctd2_inhib_details; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_inhib_details BEFORE INSERT ON ctd2_inhib_details FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_inhib_details();


--
-- Name: trg_ctd2_study_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_study_id BEFORE INSERT ON ctd2_study FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_study_id();


--
-- Name: trg_ctd2_trial_details; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_trial_details BEFORE INSERT ON ctd2_trial_details FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_trial_details();


--
-- Name: trig_clinical_trial_design_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trig_clinical_trial_design_id BEFORE INSERT ON ctd_full FOR EACH ROW EXECUTE PROCEDURE tf_trig_clinical_trial_design_id();


SET search_path = deapp, pg_catalog;

--
-- Name: de_parent_cd_trg; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER de_parent_cd_trg BEFORE INSERT ON de_xtrial_parent_names FOR EACH ROW WHEN ((COALESCE((new.parent_cd)::text, ''::text) = ''::text)) EXECUTE PROCEDURE tf_de_parent_cd_trg();


--
-- Name: trg_de_snp_info_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_snp_info_id BEFORE INSERT ON de_snp_info FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_snp_info_id();


--
-- Name: trg_de_snp_probe_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_snp_probe_id BEFORE INSERT ON de_snp_probe FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_snp_probe_id();


--
-- Name: trg_de_snp_probe_sorted_def_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_snp_probe_sorted_def_id BEFORE INSERT ON de_snp_probe_sorted_def FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_snp_probe_sorted_def_id();


--
-- Name: trg_de_subject_snp_dataset_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_subject_snp_dataset_id BEFORE INSERT ON de_subject_snp_dataset FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_subject_snp_dataset_id();


--
-- Name: trg_de_subject_sorted_def_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_subject_sorted_def_id BEFORE INSERT ON de_snp_subject_sorted_def FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_subject_sorted_def_id();


--
-- Name: trg_snp_data_by_patient_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_snp_data_by_patient_id BEFORE INSERT ON de_snp_data_by_patient FOR EACH ROW EXECUTE PROCEDURE tf_trg_snp_data_by_patient_id();


--
-- Name: trg_snp_data_by_pprobe_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_snp_data_by_pprobe_id BEFORE INSERT ON de_snp_data_by_probe FOR EACH ROW EXECUTE PROCEDURE tf_trg_snp_data_by_pprobe_id();


--
-- Name: trg_snp_subject_sorted_def_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_snp_subject_sorted_def_id BEFORE INSERT ON de_snp_subject_sorted_def FOR EACH ROW EXECUTE PROCEDURE tf_trg_snp_subject_sorted_def_id();


SET search_path = i2b2metadata, pg_catalog;

--
-- Name: trg_i2b2_tag_id; Type: TRIGGER; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE TRIGGER trg_i2b2_tag_id BEFORE INSERT ON i2b2_tags FOR EACH ROW EXECUTE PROCEDURE tf_trg_i2b2_tag_id();


SET search_path = searchapp, pg_catalog;

--
-- Name: trgi_search_a_u_sec_access_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_a_u_sec_access_id BEFORE INSERT ON search_auth_user_sec_access FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_a_u_sec_access_id();


--
-- Name: trgi_search_au_obj_access_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_au_obj_access_id BEFORE INSERT ON search_auth_sec_object_access FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_au_obj_access_id();


--
-- Name: trgi_search_au_prcpl_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_au_prcpl_id BEFORE INSERT ON search_auth_principal FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_au_prcpl_id();


--
-- Name: trgi_search_cust_fil_item_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_cust_fil_item_id BEFORE INSERT ON search_custom_filter_item FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_cust_fil_item_id();


--
-- Name: trgi_search_custom_filter_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_custom_filter_id BEFORE INSERT ON search_custom_filter FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_custom_filter_id();


--
-- Name: trgi_search_keyword_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_keyword_id BEFORE INSERT ON search_keyword FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_keyword_id();


--
-- Name: trgi_search_keyword_term_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_keyword_term_id BEFORE INSERT ON search_keyword_term FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_keyword_term_id();


--
-- Name: trgi_search_sec_acc_level_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_sec_acc_level_id BEFORE INSERT ON search_sec_access_level FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_sec_acc_level_id();


--
-- Name: trgi_search_sec_obj_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_sec_obj_id BEFORE INSERT ON search_secure_object FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_sec_obj_id();


--
-- Name: trgi_search_sec_obj_path_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trgi_search_sec_obj_path_id BEFORE INSERT ON search_secure_object_path FOR EACH ROW EXECUTE PROCEDURE tf_trgi_search_sec_obj_path_id();


SET search_path = tm_cz, pg_catalog;

--
-- Name: trg_cz_job_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_job_id BEFORE INSERT ON cz_job_master FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_job_id();


--
-- Name: trg_cz_seq_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_seq_id BEFORE INSERT ON cz_job_audit FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_seq_id();


--
-- Name: trg_probeset_deapp; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_probeset_deapp BEFORE INSERT ON probeset_deapp FOR EACH ROW EXECUTE PROCEDURE tf_trg_probeset_deapp();


SET search_path = biomart, pg_catalog;

--
-- Name: bio_assay_analysis_data_n_fk1; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data
    ADD CONSTRAINT bio_assay_analysis_data_n_fk1 FOREIGN KEY (bio_assay_analysis_id) REFERENCES bio_assay_analysis(bio_assay_analysis_id);


--
-- Name: bio_assay_analysis_data_n_fk2; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data
    ADD CONSTRAINT bio_assay_analysis_data_n_fk2 FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_assay_analysis_data_n_fk3; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data
    ADD CONSTRAINT bio_assay_analysis_data_n_fk3 FOREIGN KEY (bio_assay_platform_id) REFERENCES bio_assay_platform(bio_assay_platform_id);


--
-- Name: bio_assay_analysis_data_t_fk1; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_assay_analysis_data_t_fk1 FOREIGN KEY (bio_assay_analysis_id) REFERENCES bio_assay_analysis(bio_assay_analysis_id);


--
-- Name: bio_assay_analysis_data_t_fk2; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_assay_analysis_data_t_fk2 FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_assay_analysis_data_t_fk3; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_assay_analysis_data_t_fk3 FOREIGN KEY (bio_assay_platform_id) REFERENCES bio_assay_platform(bio_assay_platform_id);


--
-- Name: bio_assay_ans_pltfm_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis
    ADD CONSTRAINT bio_assay_ans_pltfm_fk FOREIGN KEY (bio_asy_analysis_pltfm_id) REFERENCES bio_asy_analysis_pltfm(bio_asy_analysis_pltfm_id);


--
-- Name: bio_assay_sample_bio_assay_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_sample
    ADD CONSTRAINT bio_assay_sample_bio_assay_fk FOREIGN KEY (bio_assay_id) REFERENCES bio_assay(bio_assay_id);


--
-- Name: bio_assay_sample_bio_sample_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_sample
    ADD CONSTRAINT bio_assay_sample_bio_sample_fk FOREIGN KEY (bio_sample_id) REFERENCES bio_sample(bio_sample_id);


--
-- Name: bio_asy_ad_fg_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data
    ADD CONSTRAINT bio_asy_ad_fg_fk FOREIGN KEY (bio_assay_feature_group_id) REFERENCES bio_assay_feature_group(bio_assay_feature_group_id);


--
-- Name: bio_asy_ad_tea_fg_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_asy_ad_tea_fg_fk FOREIGN KEY (bio_assay_feature_group_id) REFERENCES bio_assay_feature_group(bio_assay_feature_group_id);


--
-- Name: bio_asy_asy_pfm_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay
    ADD CONSTRAINT bio_asy_asy_pfm_fk FOREIGN KEY (bio_assay_platform_id) REFERENCES bio_assay_platform(bio_assay_platform_id);


--
-- Name: bio_asy_dt_ds_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data
    ADD CONSTRAINT bio_asy_dt_ds_fk FOREIGN KEY (bio_assay_dataset_id) REFERENCES bio_assay_dataset(bio_assay_dataset_id);


--
-- Name: bio_asy_dt_fg_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_fg_fk FOREIGN KEY (bio_assay_feature_group_id) REFERENCES bio_assay_feature_group(bio_assay_feature_group_id);


--
-- Name: bio_asy_dt_stat_exp_s_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_stat_exp_s_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_asy_dt_stats_ds_s_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_stats_ds_s_fk FOREIGN KEY (bio_assay_dataset_id) REFERENCES bio_assay_dataset(bio_assay_dataset_id);


--
-- Name: bio_asy_dt_stats_smp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_asy_data_stats_all
    ADD CONSTRAINT bio_asy_dt_stats_smp_fk FOREIGN KEY (bio_sample_id) REFERENCES bio_sample(bio_sample_id);


--
-- Name: bio_asy_dt_stats_smp_s_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_stats_smp_s_fk FOREIGN KEY (bio_sample_id) REFERENCES bio_sample(bio_sample_id);


--
-- Name: bio_asy_exp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data
    ADD CONSTRAINT bio_asy_exp_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_cli_trial_time_trl_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_clinc_trial_time_pt
    ADD CONSTRAINT bio_cli_trial_time_trl_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_clinical_trial(bio_experiment_id);


--
-- Name: bio_clinc_trl_pt_grp_exp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_clinc_trial_pt_group
    ADD CONSTRAINT bio_clinc_trl_pt_grp_exp_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_clinical_trial(bio_experiment_id);


--
-- Name: bio_clinical_trial_bio_experim; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_clinical_trial
    ADD CONSTRAINT bio_clinical_trial_bio_experim FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_clinical_trial_property_bi; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_clinc_trial_attr
    ADD CONSTRAINT bio_clinical_trial_property_bi FOREIGN KEY (bio_experiment_id) REFERENCES bio_clinical_trial(bio_experiment_id);


--
-- Name: bio_content_ref_cont_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_content_reference
    ADD CONSTRAINT bio_content_ref_cont_fk FOREIGN KEY (bio_content_id) REFERENCES bio_content(bio_file_content_id);


--
-- Name: bio_data_anl_ds_anl_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_asy_analysis_dataset
    ADD CONSTRAINT bio_data_anl_ds_anl_fk FOREIGN KEY (bio_assay_analysis_id) REFERENCES bio_assay_analysis(bio_assay_analysis_id);


--
-- Name: bio_data_anl_ds_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_asy_analysis_dataset
    ADD CONSTRAINT bio_data_anl_ds_fk FOREIGN KEY (bio_assay_dataset_id) REFERENCES bio_assay_dataset(bio_assay_dataset_id);


--
-- Name: bio_dataset_experiment_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_dataset
    ADD CONSTRAINT bio_dataset_experiment_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_df_cmp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_compound
    ADD CONSTRAINT bio_df_cmp_fk FOREIGN KEY (bio_compound_id) REFERENCES bio_compound(bio_compound_id);


--
-- Name: bio_df_disease_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_disease
    ADD CONSTRAINT bio_df_disease_fk FOREIGN KEY (bio_disease_id) REFERENCES bio_disease(bio_disease_id);


--
-- Name: bio_exp_data_fact_samp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data
    ADD CONSTRAINT bio_exp_data_fact_samp_fk FOREIGN KEY (bio_sample_id) REFERENCES bio_sample(bio_sample_id);


--
-- Name: bio_ext_analys_ext_anl_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_curated_data
    ADD CONSTRAINT bio_ext_analys_ext_anl_fk FOREIGN KEY (bio_curation_dataset_id) REFERENCES bio_curation_dataset(bio_curation_dataset_id);


--
-- Name: bio_ext_anl_pltfm_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_curation_dataset
    ADD CONSTRAINT bio_ext_anl_pltfm_fk FOREIGN KEY (bio_asy_analysis_pltfm_id) REFERENCES bio_asy_analysis_pltfm(bio_asy_analysis_pltfm_id);


--
-- Name: bio_lit_alt_ref_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_alt_data
    ADD CONSTRAINT bio_lit_alt_ref_fk FOREIGN KEY (bio_lit_ref_data_id) REFERENCES bio_lit_ref_data(bio_lit_ref_data_id);


--
-- Name: bio_lit_amd_alt_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_amd_data
    ADD CONSTRAINT bio_lit_amd_alt_fk FOREIGN KEY (bio_lit_alt_data_id) REFERENCES bio_lit_alt_data(bio_lit_alt_data_id);


--
-- Name: bio_lit_curation_dataset_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_literature
    ADD CONSTRAINT bio_lit_curation_dataset_fk FOREIGN KEY (bio_curation_dataset_id) REFERENCES bio_curation_dataset(bio_curation_dataset_id);


--
-- Name: bio_lit_inh_ref_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_inh_data
    ADD CONSTRAINT bio_lit_inh_ref_fk FOREIGN KEY (bio_lit_ref_data_id) REFERENCES bio_lit_ref_data(bio_lit_ref_data_id);


--
-- Name: bio_lit_int_ref_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_int_data
    ADD CONSTRAINT bio_lit_int_ref_fk FOREIGN KEY (bio_lit_ref_data_id) REFERENCES bio_lit_ref_data(bio_lit_ref_data_id);


--
-- Name: bio_lit_pe_ref_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_pe_data
    ADD CONSTRAINT bio_lit_pe_ref_fk FOREIGN KEY (bio_lit_ref_data_id) REFERENCES bio_lit_ref_data(bio_lit_ref_data_id);


--
-- Name: bio_marker_link_bio_marker_rel; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_correlation
    ADD CONSTRAINT bio_marker_link_bio_marker_rel FOREIGN KEY (bio_data_correl_descr_id) REFERENCES bio_data_correl_descr(bio_data_correl_descr_id);


--
-- Name: bio_patient_bio_clinic_tri_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient
    ADD CONSTRAINT bio_patient_bio_clinic_tri_fk FOREIGN KEY (bio_clinical_trial_p_group_id) REFERENCES bio_clinc_trial_pt_group(bio_clinical_trial_p_group_id);


--
-- Name: bio_patient_bio_clinical_trial; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient
    ADD CONSTRAINT bio_patient_bio_clinical_trial FOREIGN KEY (bio_experiment_id) REFERENCES bio_clinical_trial(bio_experiment_id);


--
-- Name: bio_patient_bio_subject_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient
    ADD CONSTRAINT bio_patient_bio_subject_fk FOREIGN KEY (bio_patient_id) REFERENCES bio_subject(bio_subject_id);


--
-- Name: bio_pt_attr_trl_attr_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient_event_attr
    ADD CONSTRAINT bio_pt_attr_trl_attr_fk FOREIGN KEY (bio_clinic_trial_attr_id) REFERENCES bio_clinc_trial_attr(bio_clinc_trial_attr_id);


--
-- Name: bio_pt_event_attr_evt_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient_event_attr
    ADD CONSTRAINT bio_pt_event_attr_evt_fk FOREIGN KEY (bio_patient_event_id) REFERENCES bio_patient_event(bio_patient_event_id);


--
-- Name: bio_pt_event_bio_pt_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient_event
    ADD CONSTRAINT bio_pt_event_bio_pt_fk FOREIGN KEY (bio_patient_id) REFERENCES bio_patient(bio_patient_id);


--
-- Name: bio_pt_event_bio_trl_tp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient_event
    ADD CONSTRAINT bio_pt_event_bio_trl_tp_fk FOREIGN KEY (bio_clinic_trial_timepoint_id) REFERENCES bio_clinc_trial_time_pt(bio_clinc_trial_tm_pt_id);


--
-- Name: bio_sample_bio_subject_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_sample
    ADD CONSTRAINT bio_sample_bio_subject_fk FOREIGN KEY (bio_subject_id) REFERENCES bio_subject(bio_subject_id);


--
-- Name: bio_sample_cl_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_sample
    ADD CONSTRAINT bio_sample_cl_fk FOREIGN KEY (bio_cell_line_id) REFERENCES bio_cell_line(bio_cell_line_id);


--
-- Name: bio_sample_pt_evt_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_sample
    ADD CONSTRAINT bio_sample_pt_evt_fk FOREIGN KEY (bio_patient_event_id) REFERENCES bio_patient_event(bio_patient_event_id);


--
-- Name: bio_taxon_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_taxonomy
    ADD CONSTRAINT bio_taxon_fk FOREIGN KEY (bio_taxonomy_id) REFERENCES bio_taxonomy(bio_taxonomy_id);


--
-- Name: cd_disease_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_cell_line
    ADD CONSTRAINT cd_disease_fk FOREIGN KEY (bio_disease_id) REFERENCES bio_disease(bio_disease_id);


--
-- Name: dataset_experiment_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay
    ADD CONSTRAINT dataset_experiment_fk FOREIGN KEY (experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: ext_file_cnt_cnt_repo_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_content
    ADD CONSTRAINT ext_file_cnt_cnt_repo_fk FOREIGN KEY (repository_id) REFERENCES bio_content_repository(bio_content_repo_id);


SET search_path = deapp, pg_catalog;

--
-- Name: de_chromosomal_region_gpl_id_fkey; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_chromosomal_region
    ADD CONSTRAINT de_chromosomal_region_gpl_id_fkey FOREIGN KEY (gpl_id) REFERENCES de_gpl_info(platform);


--
-- Name: de_subject_acgh_data_region_id_fkey; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_subject_acgh_data
    ADD CONSTRAINT de_subject_acgh_data_region_id_fkey FOREIGN KEY (region_id) REFERENCES de_chromosomal_region(region_id);


--
-- Name: fk_snp_gene_map_snp_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_snp_gene_map
    ADD CONSTRAINT fk_snp_gene_map_snp_id FOREIGN KEY (snp_id) REFERENCES de_snp_info(snp_info_id);


--
-- Name: fk_snp_loc_dataset_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_snp_data_dataset_loc
    ADD CONSTRAINT fk_snp_loc_dataset_id FOREIGN KEY (snp_dataset_id) REFERENCES de_subject_snp_dataset(subject_snp_dataset_id);


--
-- Name: fk_snp_probe_snp_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_snp_probe
    ADD CONSTRAINT fk_snp_probe_snp_id FOREIGN KEY (snp_id) REFERENCES de_snp_info(snp_info_id);


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: fk_up_set_type_id; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY set_upload_status
    ADD CONSTRAINT fk_up_set_type_id FOREIGN KEY (set_type_id) REFERENCES set_type(id);


--
-- Name: qt_fk_pesc_ri; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_patient_enc_collection
    ADD CONSTRAINT qt_fk_pesc_ri FOREIGN KEY (result_instance_id) REFERENCES qt_query_result_instance(result_instance_id);


--
-- Name: qt_fk_psc_ri; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_patient_set_collection
    ADD CONSTRAINT qt_fk_psc_ri FOREIGN KEY (result_instance_id) REFERENCES qt_query_result_instance(result_instance_id);


--
-- Name: qt_fk_qi_mid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_instance
    ADD CONSTRAINT qt_fk_qi_mid FOREIGN KEY (query_master_id) REFERENCES qt_query_master(query_master_id);


--
-- Name: qt_fk_qi_stid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_instance
    ADD CONSTRAINT qt_fk_qi_stid FOREIGN KEY (status_type_id) REFERENCES qt_query_status_type(status_type_id);


--
-- Name: qt_fk_qri_rid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_result_instance
    ADD CONSTRAINT qt_fk_qri_rid FOREIGN KEY (query_instance_id) REFERENCES qt_query_instance(query_instance_id);


--
-- Name: qt_fk_qri_rtid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_result_instance
    ADD CONSTRAINT qt_fk_qri_rtid FOREIGN KEY (result_type_id) REFERENCES qt_query_result_type(result_type_id);


--
-- Name: qt_fk_qri_stid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_result_instance
    ADD CONSTRAINT qt_fk_qri_stid FOREIGN KEY (status_type_id) REFERENCES qt_query_status_type(status_type_id);


--
-- Name: qt_fk_xmlr_riid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_xml_result
    ADD CONSTRAINT qt_fk_xmlr_riid FOREIGN KEY (result_instance_id) REFERENCES qt_query_result_instance(result_instance_id);


SET search_path = searchapp, pg_catalog;

--
-- Name: fkfb14ef79287e0cac; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_role_auth_user
    ADD CONSTRAINT fkfb14ef79287e0cac FOREIGN KEY (authorities_id) REFERENCES search_auth_user(id);


--
-- Name: fkfb14ef798f01f561; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_role_auth_user
    ADD CONSTRAINT fkfb14ef798f01f561 FOREIGN KEY (people_id) REFERENCES search_role(id);


--
-- Name: gene_sig_create_auth_user_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT gene_sig_create_auth_user_fk1 FOREIGN KEY (created_by_auth_user_id) REFERENCES search_auth_user(id);


--
-- Name: gene_sig_file_schema_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT gene_sig_file_schema_fk1 FOREIGN KEY (search_gene_sig_file_schema_id) REFERENCES search_gene_sig_file_schema(search_gene_sig_file_schema_id);


--
-- Name: gene_sig_mod_auth_user_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT gene_sig_mod_auth_user_fk1 FOREIGN KEY (modified_by_auth_user_id) REFERENCES search_auth_user(id);


--
-- Name: gene_sig_parent_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT gene_sig_parent_fk1 FOREIGN KEY (parent_gene_signature_id) REFERENCES search_gene_signature(search_gene_signature_id);


--
-- Name: plugin_module_plugin_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY plugin_module
    ADD CONSTRAINT plugin_module_plugin_fk1 FOREIGN KEY (plugin_seq) REFERENCES plugin(plugin_seq);


--
-- Name: sch_sec_a_u_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_sec_object_access
    ADD CONSTRAINT sch_sec_a_u_fk FOREIGN KEY (auth_principal_id) REFERENCES search_auth_principal(id);


--
-- Name: sch_sec_s_a_l_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_sec_object_access
    ADD CONSTRAINT sch_sec_s_a_l_fk FOREIGN KEY (secure_access_level_id) REFERENCES search_sec_access_level(search_sec_access_level_id);


--
-- Name: sch_sec_s_o_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_sec_object_access
    ADD CONSTRAINT sch_sec_s_o_fk FOREIGN KEY (secure_object_id) REFERENCES search_secure_object(search_secure_object_id);


--
-- Name: sch_user_gp_m_grp_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_group_member
    ADD CONSTRAINT sch_user_gp_m_grp_fk FOREIGN KEY (auth_group_id) REFERENCES search_auth_group(id);


--
-- Name: sch_user_gp_m_usr_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_group_member
    ADD CONSTRAINT sch_user_gp_m_usr_fk FOREIGN KEY (auth_user_id) REFERENCES search_auth_principal(id);


--
-- Name: search_kw_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_keyword_term
    ADD CONSTRAINT search_kw_fk FOREIGN KEY (search_keyword_id) REFERENCES search_keyword(search_keyword_id);


--
-- Name: search_sec_a_u_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_user_sec_access
    ADD CONSTRAINT search_sec_a_u_fk FOREIGN KEY (search_auth_user_id) REFERENCES search_auth_user(id);


--
-- Name: search_sec_s_a_l_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_user_sec_access
    ADD CONSTRAINT search_sec_s_a_l_fk FOREIGN KEY (search_sec_access_level_id) REFERENCES search_sec_access_level(search_sec_access_level_id);


--
-- Name: search_sec_s_o_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_user_sec_access
    ADD CONSTRAINT search_sec_s_o_fk FOREIGN KEY (search_secure_object_id) REFERENCES search_secure_object(search_secure_object_id);


--
-- Name: sh_auth_gp_id_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_group
    ADD CONSTRAINT sh_auth_gp_id_fk FOREIGN KEY (id) REFERENCES search_auth_principal(id);


--
-- Name: sh_auth_user_id_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_user
    ADD CONSTRAINT sh_auth_user_id_fk FOREIGN KEY (id) REFERENCES search_auth_principal(id);


--
-- Name: biomart; Type: ACL; Schema: -; Owner: biomart
--

REVOKE ALL ON SCHEMA biomart FROM PUBLIC;
REVOKE ALL ON SCHEMA biomart FROM biomart;
GRANT ALL ON SCHEMA biomart TO biomart;
GRANT ALL ON SCHEMA biomart TO biomart_user;
GRANT ALL ON SCHEMA biomart TO tm_cz;


--
-- Name: deapp; Type: ACL; Schema: -; Owner: deapp
--

REVOKE ALL ON SCHEMA deapp FROM PUBLIC;
REVOKE ALL ON SCHEMA deapp FROM deapp;
GRANT ALL ON SCHEMA deapp TO deapp;
GRANT ALL ON SCHEMA deapp TO biomart_user;
GRANT ALL ON SCHEMA deapp TO tm_cz;


--
-- Name: i2b2demodata; Type: ACL; Schema: -; Owner: i2b2demodata
--

REVOKE ALL ON SCHEMA i2b2demodata FROM PUBLIC;
REVOKE ALL ON SCHEMA i2b2demodata FROM i2b2demodata;
GRANT ALL ON SCHEMA i2b2demodata TO i2b2demodata;
GRANT ALL ON SCHEMA i2b2demodata TO biomart_user;
GRANT ALL ON SCHEMA i2b2demodata TO tm_cz;


--
-- Name: i2b2hive; Type: ACL; Schema: -; Owner: i2b2hive
--

REVOKE ALL ON SCHEMA i2b2hive FROM PUBLIC;
REVOKE ALL ON SCHEMA i2b2hive FROM i2b2hive;
GRANT ALL ON SCHEMA i2b2hive TO i2b2hive;
GRANT ALL ON SCHEMA i2b2hive TO biomart_user;


--
-- Name: i2b2metadata; Type: ACL; Schema: -; Owner: i2b2metadata
--

REVOKE ALL ON SCHEMA i2b2metadata FROM PUBLIC;
REVOKE ALL ON SCHEMA i2b2metadata FROM i2b2metadata;
GRANT ALL ON SCHEMA i2b2metadata TO i2b2metadata;
GRANT ALL ON SCHEMA i2b2metadata TO biomart_user;
GRANT ALL ON SCHEMA i2b2metadata TO tm_cz;


--
-- Name: i2b2pm; Type: ACL; Schema: -; Owner: i2b2pm
--

REVOKE ALL ON SCHEMA i2b2pm FROM PUBLIC;
REVOKE ALL ON SCHEMA i2b2pm FROM i2b2pm;
GRANT ALL ON SCHEMA i2b2pm TO i2b2pm;
GRANT ALL ON SCHEMA i2b2pm TO biomart_user;


--
-- Name: i2b2workdata; Type: ACL; Schema: -; Owner: i2b2workdata
--

REVOKE ALL ON SCHEMA i2b2workdata FROM PUBLIC;
REVOKE ALL ON SCHEMA i2b2workdata FROM i2b2workdata;
GRANT ALL ON SCHEMA i2b2workdata TO i2b2workdata;
GRANT ALL ON SCHEMA i2b2workdata TO biomart_user;


--
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- Name: searchapp; Type: ACL; Schema: -; Owner: searchapp
--

REVOKE ALL ON SCHEMA searchapp FROM PUBLIC;
REVOKE ALL ON SCHEMA searchapp FROM searchapp;
GRANT ALL ON SCHEMA searchapp TO searchapp;
GRANT ALL ON SCHEMA searchapp TO biomart_user;
GRANT ALL ON SCHEMA searchapp TO tm_cz;


--
-- Name: tm_lz; Type: ACL; Schema: -; Owner: tm_lz
--

REVOKE ALL ON SCHEMA tm_lz FROM PUBLIC;
REVOKE ALL ON SCHEMA tm_lz FROM tm_lz;
GRANT ALL ON SCHEMA tm_lz TO tm_lz;
GRANT ALL ON SCHEMA tm_lz TO tm_cz;


--
-- Name: tm_wz; Type: ACL; Schema: -; Owner: tm_wz
--

REVOKE ALL ON SCHEMA tm_wz FROM PUBLIC;
REVOKE ALL ON SCHEMA tm_wz FROM tm_wz;
GRANT ALL ON SCHEMA tm_wz TO tm_wz;
GRANT ALL ON SCHEMA tm_wz TO tm_cz;


SET search_path = biomart, pg_catalog;

--
-- Name: bio_assay_analysis_uid(text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_assay_analysis_uid(analysis_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_assay_analysis_uid(analysis_name text) FROM biomart;
GRANT ALL ON FUNCTION bio_assay_analysis_uid(analysis_name text) TO biomart;
GRANT ALL ON FUNCTION bio_assay_analysis_uid(analysis_name text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_assay_analysis_uid(analysis_name text) TO biomart_user;


--
-- Name: bio_assay_platform_uid(text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_assay_platform_uid(platform_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_assay_platform_uid(platform_name text) FROM biomart;
GRANT ALL ON FUNCTION bio_assay_platform_uid(platform_name text) TO biomart;
GRANT ALL ON FUNCTION bio_assay_platform_uid(platform_name text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_assay_platform_uid(platform_name text) TO biomart_user;


--
-- Name: bio_asy_analysis_pltfm_uid(text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name text) FROM biomart;
GRANT ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name text) TO biomart;
GRANT ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name text) TO biomart_user;


--
-- Name: bio_compound_uid(text, text, text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) FROM biomart;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) TO biomart;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) TO biomart_user;


--
-- Name: bio_curation_dataset_uid(text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type text) FROM biomart;
GRANT ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type text) TO biomart;
GRANT ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type text) TO biomart_user;


--
-- Name: bio_disease_uid(text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_disease_uid(mesh_code text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_disease_uid(mesh_code text) FROM biomart;
GRANT ALL ON FUNCTION bio_disease_uid(mesh_code text) TO biomart;
GRANT ALL ON FUNCTION bio_disease_uid(mesh_code text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_disease_uid(mesh_code text) TO biomart_user;


--
-- Name: bio_experiment_uid(text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_experiment_uid(primary_id text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_experiment_uid(primary_id text) FROM biomart;
GRANT ALL ON FUNCTION bio_experiment_uid(primary_id text) TO biomart;
GRANT ALL ON FUNCTION bio_experiment_uid(primary_id text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_experiment_uid(primary_id text) TO biomart_user;


--
-- Name: bio_jub_oncol_data_uid(bigint, text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_jub_oncol_data_uid(record_id bigint, bio_curation_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_jub_oncol_data_uid(record_id bigint, bio_curation_name text) FROM biomart;
GRANT ALL ON FUNCTION bio_jub_oncol_data_uid(record_id bigint, bio_curation_name text) TO biomart;
GRANT ALL ON FUNCTION bio_jub_oncol_data_uid(record_id bigint, bio_curation_name text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_jub_oncol_data_uid(record_id bigint, bio_curation_name text) TO biomart_user;


--
-- Name: bio_jub_oncol_sum_data_uid(bigint, text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id bigint, bio_curation_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id bigint, bio_curation_name text) FROM biomart;
GRANT ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id bigint, bio_curation_name text) TO biomart;
GRANT ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id bigint, bio_curation_name text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id bigint, bio_curation_name text) TO biomart_user;


--
-- Name: biomarker_gene_uid(text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION biomarker_gene_uid(gene_id text) FROM PUBLIC;
REVOKE ALL ON FUNCTION biomarker_gene_uid(gene_id text) FROM biomart;
GRANT ALL ON FUNCTION biomarker_gene_uid(gene_id text) TO biomart;
GRANT ALL ON FUNCTION biomarker_gene_uid(gene_id text) TO PUBLIC;
GRANT ALL ON FUNCTION biomarker_gene_uid(gene_id text) TO biomart_user;


--
-- Name: biomarker_pathway_uid(text, text); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION biomarker_pathway_uid(p_source text, pathway_id text) FROM PUBLIC;
REVOKE ALL ON FUNCTION biomarker_pathway_uid(p_source text, pathway_id text) FROM biomart;
GRANT ALL ON FUNCTION biomarker_pathway_uid(p_source text, pathway_id text) TO biomart;
GRANT ALL ON FUNCTION biomarker_pathway_uid(p_source text, pathway_id text) TO PUBLIC;
GRANT ALL ON FUNCTION biomarker_pathway_uid(p_source text, pathway_id text) TO biomart_user;


--
-- Name: cum_normal_dist(numeric, numeric, numeric); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) FROM biomart;
GRANT ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) TO biomart;
GRANT ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) TO PUBLIC;
GRANT ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) TO biomart_user;


--
-- Name: fract_error_dist(numeric); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION fract_error_dist(norminput numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION fract_error_dist(norminput numeric) FROM biomart;
GRANT ALL ON FUNCTION fract_error_dist(norminput numeric) TO biomart;
GRANT ALL ON FUNCTION fract_error_dist(norminput numeric) TO PUBLIC;
GRANT ALL ON FUNCTION fract_error_dist(norminput numeric) TO biomart_user;


--
-- Name: refresh_bio_lit_int_model_mv(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION refresh_bio_lit_int_model_mv() FROM PUBLIC;
REVOKE ALL ON FUNCTION refresh_bio_lit_int_model_mv() FROM biomart;
GRANT ALL ON FUNCTION refresh_bio_lit_int_model_mv() TO biomart;
GRANT ALL ON FUNCTION refresh_bio_lit_int_model_mv() TO PUBLIC;
GRANT ALL ON FUNCTION refresh_bio_lit_int_model_mv() TO biomart_user;


--
-- Name: refresh_bio_marker_correl_mv(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION refresh_bio_marker_correl_mv() FROM PUBLIC;
REVOKE ALL ON FUNCTION refresh_bio_marker_correl_mv() FROM biomart;
GRANT ALL ON FUNCTION refresh_bio_marker_correl_mv() TO biomart;
GRANT ALL ON FUNCTION refresh_bio_marker_correl_mv() TO PUBLIC;
GRANT ALL ON FUNCTION refresh_bio_marker_correl_mv() TO biomart_user;


--
-- Name: tea_npv_precompute(numeric, numeric, numeric); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) FROM biomart;
GRANT ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) TO biomart;
GRANT ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) TO PUBLIC;
GRANT ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) TO biomart_user;


--
-- Name: tf_trg_bio_assay_analysis_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_analysis_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_analysis_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_analysis_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_analysis_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_assay_analysis_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_data_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_assay_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_dataset_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_dataset_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_dataset_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_dataset_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_dataset_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_assay_dataset_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_f_g_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_f_g_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_f_g_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_f_g_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_f_g_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_assay_f_g_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_assay_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_platform_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_platform_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_platform_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_platform_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_platform_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_assay_platform_id() TO biomart_user;


--
-- Name: tf_trg_bio_asy_analysis_pltfm_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() TO biomart_user;


--
-- Name: tf_trg_bio_asy_dt_stats_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() TO biomart_user;


--
-- Name: tf_trg_bio_cell_line_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_cell_line_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_cell_line_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cell_line_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cell_line_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_cell_line_id() TO biomart_user;


--
-- Name: tf_trg_bio_cl_trl_time_pt_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() TO biomart_user;


--
-- Name: tf_trg_bio_clin_trl_pt_grp_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() TO biomart_user;


--
-- Name: tf_trg_bio_cln_trl_attr_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() TO biomart_user;


--
-- Name: tf_trg_bio_compound_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_compound_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_compound_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_compound_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_compound_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_compound_id() TO biomart_user;


--
-- Name: tf_trg_bio_concept_code_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_concept_code_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_concept_code_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_concept_code_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_concept_code_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_concept_code_id() TO biomart_user;


--
-- Name: tf_trg_bio_content_ref_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_content_ref_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_content_ref_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_content_ref_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_content_ref_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_content_ref_id() TO biomart_user;


--
-- Name: tf_trg_bio_content_repo_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_content_repo_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_content_repo_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_content_repo_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_content_repo_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_content_repo_id() TO biomart_user;


--
-- Name: tf_trg_bio_curation_dataset_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_curation_dataset_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_curation_dataset_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_curation_dataset_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_curation_dataset_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_curation_dataset_id() TO biomart_user;


--
-- Name: tf_trg_bio_data_attr_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_data_attr_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_data_attr_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_attr_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_attr_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_data_attr_id() TO biomart_user;


--
-- Name: tf_trg_bio_data_correl_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_data_correl_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_data_correl_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_correl_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_correl_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_data_correl_id() TO biomart_user;


--
-- Name: tf_trg_bio_data_ext_code_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_data_ext_code_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_data_ext_code_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_ext_code_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_ext_code_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_data_ext_code_id() TO biomart_user;


--
-- Name: tf_trg_bio_disease_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_disease_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_disease_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_disease_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_disease_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_disease_id() TO biomart_user;


--
-- Name: tf_trg_bio_experiment_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_experiment_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_experiment_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_experiment_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_experiment_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_experiment_id() TO biomart_user;


--
-- Name: tf_trg_bio_file_content_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_file_content_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_file_content_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_file_content_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_file_content_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_file_content_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_alt_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_amd_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_inh_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_int_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_int_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_int_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_int_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_int_data_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_lit_int_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_model_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_model_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_model_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_model_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_model_data_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_lit_model_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_pe_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_ref_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_sum_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_marker_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_marker_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_marker_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_marker_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_marker_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_marker_id() TO biomart_user;


--
-- Name: tf_trg_bio_mkr_correl_descr_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() TO biomart_user;


--
-- Name: tf_trg_bio_patient_event_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_patient_event_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_patient_event_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_patient_event_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_patient_event_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_patient_event_id() TO biomart_user;


--
-- Name: tf_trg_bio_patient_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_patient_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_patient_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_patient_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_patient_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_patient_id() TO biomart_user;


--
-- Name: tf_trg_bio_pt_evt_attr_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() TO biomart_user;


--
-- Name: tf_trg_bio_sample_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_sample_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_sample_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_sample_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_sample_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_sample_id() TO biomart_user;


--
-- Name: tf_trg_bio_subject_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_subject_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_subject_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_subject_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_subject_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_subject_id() TO biomart_user;


--
-- Name: tf_trg_bio_taxon_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_taxon_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_taxon_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_taxon_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_taxon_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_bio_taxon_id() TO biomart_user;


--
-- Name: tf_trg_ctd2_clin_inhib_effect(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() TO biomart_user;


--
-- Name: tf_trg_ctd2_disease(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_disease() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_disease() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_disease() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_disease() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_ctd2_disease() TO biomart_user;


--
-- Name: tf_trg_ctd2_inhib_details(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_inhib_details() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_inhib_details() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_inhib_details() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_inhib_details() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_ctd2_inhib_details() TO biomart_user;


--
-- Name: tf_trg_ctd2_study_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_study_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_study_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_study_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_study_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_ctd2_study_id() TO biomart_user;


--
-- Name: tf_trg_ctd2_trial_details(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_trial_details() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_trial_details() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_trial_details() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_trial_details() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_ctd2_trial_details() TO biomart_user;


--
-- Name: tf_trig_clinical_trial_design_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trig_clinical_trial_design_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trig_clinical_trial_design_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trig_clinical_trial_design_id() TO biomart;
GRANT ALL ON FUNCTION tf_trig_clinical_trial_design_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trig_clinical_trial_design_id() TO biomart_user;


SET search_path = deapp, pg_catalog;

--
-- Name: tf_de_parent_cd_trg(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_de_parent_cd_trg() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_de_parent_cd_trg() FROM deapp;
GRANT ALL ON FUNCTION tf_de_parent_cd_trg() TO deapp;
GRANT ALL ON FUNCTION tf_de_parent_cd_trg() TO PUBLIC;
GRANT ALL ON FUNCTION tf_de_parent_cd_trg() TO biomart_user;


--
-- Name: tf_trg_de_snp_info_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_snp_info_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_snp_info_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_info_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_info_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_de_snp_info_id() TO biomart_user;


--
-- Name: tf_trg_de_snp_probe_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_snp_probe_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_snp_probe_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_id() TO biomart_user;


--
-- Name: tf_trg_de_snp_probe_sorted_def_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() TO biomart_user;


--
-- Name: tf_trg_de_subject_snp_dataset_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() TO biomart_user;


--
-- Name: tf_trg_de_subject_sorted_def_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() TO biomart_user;


--
-- Name: tf_trg_snp_data_by_patient_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_snp_data_by_patient_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_snp_data_by_patient_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_patient_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_patient_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_patient_id() TO biomart_user;


--
-- Name: tf_trg_snp_data_by_pprobe_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() TO biomart_user;


--
-- Name: tf_trg_snp_subject_sorted_def_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() TO biomart_user;


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: create_temp_concept_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_eid_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_patient_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_pid_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_provider_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_visit_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_concept_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_eid_map_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_encountervisit_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_modifier_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_patient_map_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_pid_map_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_provider_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: remove_temp_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION remove_temp_table(temptablename character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION remove_temp_table(temptablename character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION remove_temp_table(temptablename character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION remove_temp_table(temptablename character varying) TO PUBLIC;
GRANT ALL ON FUNCTION remove_temp_table(temptablename character varying) TO biomart_user;


--
-- Name: sync_clear_concept_table(character varying, character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: sync_clear_provider_table(character varying, character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: update_observation_fact(character varying, numeric, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) TO PUBLIC;
GRANT ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) TO biomart_user;


SET search_path = searchapp, pg_catalog;

--
-- Name: bio_clinical_trial_uid(text, text, text); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION bio_clinical_trial_uid(trial_number text, title text, condition text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_clinical_trial_uid(trial_number text, title text, condition text) FROM searchapp;
GRANT ALL ON FUNCTION bio_clinical_trial_uid(trial_number text, title text, condition text) TO searchapp;
GRANT ALL ON FUNCTION bio_clinical_trial_uid(trial_number text, title text, condition text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_clinical_trial_uid(trial_number text, title text, condition text) TO biomart_user;


--
-- Name: bio_compound_uid(text, text, text); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) FROM searchapp;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) TO searchapp;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) TO PUBLIC;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry text, jnj_number text, cnto_number text) TO biomart_user;


--
-- Name: refresh_search_bio_mkr_correl_fast_mv(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() FROM PUBLIC;
REVOKE ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() FROM searchapp;
GRANT ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() TO searchapp;
GRANT ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() TO PUBLIC;
GRANT ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() TO biomart_user;


--
-- Name: tf_trgi_search_a_u_sec_access_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_a_u_sec_access_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_a_u_sec_access_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_a_u_sec_access_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_a_u_sec_access_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_a_u_sec_access_id() TO biomart_user;


--
-- Name: tf_trgi_search_au_obj_access_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_au_obj_access_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_au_obj_access_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_au_obj_access_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_au_obj_access_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_au_obj_access_id() TO biomart_user;


--
-- Name: tf_trgi_search_au_prcpl_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_au_prcpl_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_au_prcpl_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_au_prcpl_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_au_prcpl_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_au_prcpl_id() TO biomart_user;


--
-- Name: tf_trgi_search_cust_fil_item_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_cust_fil_item_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_cust_fil_item_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_cust_fil_item_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_cust_fil_item_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_cust_fil_item_id() TO biomart_user;


--
-- Name: tf_trgi_search_custom_filter_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_custom_filter_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_custom_filter_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_custom_filter_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_custom_filter_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_custom_filter_id() TO biomart_user;


--
-- Name: tf_trgi_search_keyword_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_keyword_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_keyword_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_keyword_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_keyword_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_keyword_id() TO biomart_user;


--
-- Name: tf_trgi_search_keyword_term_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_keyword_term_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_keyword_term_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_keyword_term_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_keyword_term_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_keyword_term_id() TO biomart_user;


--
-- Name: tf_trgi_search_sec_acc_level_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_sec_acc_level_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_sec_acc_level_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_sec_acc_level_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_sec_acc_level_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_sec_acc_level_id() TO biomart_user;


--
-- Name: tf_trgi_search_sec_obj_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_sec_obj_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_sec_obj_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_sec_obj_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_sec_obj_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_sec_obj_id() TO biomart_user;


--
-- Name: tf_trgi_search_sec_obj_path_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trgi_search_sec_obj_path_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trgi_search_sec_obj_path_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_sec_obj_path_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trgi_search_sec_obj_path_id() TO PUBLIC;
GRANT ALL ON FUNCTION tf_trgi_search_sec_obj_path_id() TO biomart_user;


SET search_path = biomart, pg_catalog;

--
-- Name: bio_assay; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay FROM biomart;
GRANT ALL ON TABLE bio_assay TO biomart;
GRANT ALL ON TABLE bio_assay TO biomart_user;
GRANT ALL ON TABLE bio_assay TO tm_cz;


--
-- Name: bio_assay_analysis; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_analysis FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis FROM biomart;
GRANT ALL ON TABLE bio_assay_analysis TO biomart;
GRANT ALL ON TABLE bio_assay_analysis TO biomart_user;
GRANT ALL ON TABLE bio_assay_analysis TO tm_cz;


--
-- Name: bio_assay_analysis_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_analysis_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis_data FROM biomart;
GRANT ALL ON TABLE bio_assay_analysis_data TO biomart;
GRANT ALL ON TABLE bio_assay_analysis_data TO biomart_user;
GRANT ALL ON TABLE bio_assay_analysis_data TO tm_cz;


--
-- Name: bio_assay_analysis_data_tea; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_analysis_data_tea FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis_data_tea FROM biomart;
GRANT ALL ON TABLE bio_assay_analysis_data_tea TO biomart;
GRANT ALL ON TABLE bio_assay_analysis_data_tea TO biomart_user;
GRANT ALL ON TABLE bio_assay_analysis_data_tea TO tm_cz;


--
-- Name: bio_assay_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_data FROM biomart;
GRANT ALL ON TABLE bio_assay_data TO biomart;
GRANT ALL ON TABLE bio_assay_data TO biomart_user;
GRANT ALL ON TABLE bio_assay_data TO tm_cz;


--
-- Name: bio_assay_data_annotation; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_data_annotation FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_data_annotation FROM biomart;
GRANT ALL ON TABLE bio_assay_data_annotation TO biomart;
GRANT ALL ON TABLE bio_assay_data_annotation TO biomart_user;
GRANT ALL ON TABLE bio_assay_data_annotation TO tm_cz;


--
-- Name: bio_assay_data_stats; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_data_stats FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_data_stats FROM biomart;
GRANT ALL ON TABLE bio_assay_data_stats TO biomart;
GRANT ALL ON TABLE bio_assay_data_stats TO biomart_user;
GRANT ALL ON TABLE bio_assay_data_stats TO tm_cz;


--
-- Name: bio_assay_data_stats_seq; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE bio_assay_data_stats_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE bio_assay_data_stats_seq FROM biomart;
GRANT ALL ON SEQUENCE bio_assay_data_stats_seq TO biomart;
GRANT ALL ON SEQUENCE bio_assay_data_stats_seq TO biomart_user;
GRANT ALL ON SEQUENCE bio_assay_data_stats_seq TO tm_cz;


--
-- Name: bio_assay_dataset; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_dataset FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_dataset FROM biomart;
GRANT ALL ON TABLE bio_assay_dataset TO biomart;
GRANT ALL ON TABLE bio_assay_dataset TO biomart_user;
GRANT ALL ON TABLE bio_assay_dataset TO tm_cz;


--
-- Name: bio_assay_feature_group; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_feature_group FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_feature_group FROM biomart;
GRANT ALL ON TABLE bio_assay_feature_group TO biomart;
GRANT ALL ON TABLE bio_assay_feature_group TO biomart_user;
GRANT ALL ON TABLE bio_assay_feature_group TO tm_cz;


--
-- Name: bio_assay_platform; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_platform FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_platform FROM biomart;
GRANT ALL ON TABLE bio_assay_platform TO biomart;
GRANT ALL ON TABLE bio_assay_platform TO biomart_user;
GRANT ALL ON TABLE bio_assay_platform TO tm_cz;


--
-- Name: bio_assay_sample; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_sample FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_sample FROM biomart;
GRANT ALL ON TABLE bio_assay_sample TO biomart;
GRANT ALL ON TABLE bio_assay_sample TO biomart_user;
GRANT ALL ON TABLE bio_assay_sample TO tm_cz;


--
-- Name: bio_asy_analysis_dataset; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_asy_analysis_dataset FROM PUBLIC;
REVOKE ALL ON TABLE bio_asy_analysis_dataset FROM biomart;
GRANT ALL ON TABLE bio_asy_analysis_dataset TO biomart;
GRANT ALL ON TABLE bio_asy_analysis_dataset TO biomart_user;
GRANT ALL ON TABLE bio_asy_analysis_dataset TO tm_cz;


--
-- Name: bio_asy_analysis_pltfm; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_asy_analysis_pltfm FROM PUBLIC;
REVOKE ALL ON TABLE bio_asy_analysis_pltfm FROM biomart;
GRANT ALL ON TABLE bio_asy_analysis_pltfm TO biomart;
GRANT ALL ON TABLE bio_asy_analysis_pltfm TO biomart_user;
GRANT ALL ON TABLE bio_asy_analysis_pltfm TO tm_cz;


--
-- Name: bio_asy_data_stats_all; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_asy_data_stats_all FROM PUBLIC;
REVOKE ALL ON TABLE bio_asy_data_stats_all FROM biomart;
GRANT ALL ON TABLE bio_asy_data_stats_all TO biomart;
GRANT ALL ON TABLE bio_asy_data_stats_all TO biomart_user;
GRANT ALL ON TABLE bio_asy_data_stats_all TO tm_cz;


--
-- Name: bio_cell_line; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_cell_line FROM PUBLIC;
REVOKE ALL ON TABLE bio_cell_line FROM biomart;
GRANT ALL ON TABLE bio_cell_line TO biomart;
GRANT ALL ON TABLE bio_cell_line TO biomart_user;
GRANT ALL ON TABLE bio_cell_line TO tm_cz;


--
-- Name: bio_cgdcp_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_cgdcp_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_cgdcp_data FROM biomart;
GRANT ALL ON TABLE bio_cgdcp_data TO biomart;
GRANT ALL ON TABLE bio_cgdcp_data TO biomart_user;
GRANT ALL ON TABLE bio_cgdcp_data TO tm_cz;


--
-- Name: bio_clinc_trial_attr; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinc_trial_attr FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinc_trial_attr FROM biomart;
GRANT ALL ON TABLE bio_clinc_trial_attr TO biomart;
GRANT ALL ON TABLE bio_clinc_trial_attr TO biomart_user;
GRANT ALL ON TABLE bio_clinc_trial_attr TO tm_cz;


--
-- Name: bio_clinc_trial_pt_group; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinc_trial_pt_group FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinc_trial_pt_group FROM biomart;
GRANT ALL ON TABLE bio_clinc_trial_pt_group TO biomart;
GRANT ALL ON TABLE bio_clinc_trial_pt_group TO biomart_user;
GRANT ALL ON TABLE bio_clinc_trial_pt_group TO tm_cz;


--
-- Name: bio_clinc_trial_time_pt; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinc_trial_time_pt FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinc_trial_time_pt FROM biomart;
GRANT ALL ON TABLE bio_clinc_trial_time_pt TO biomart;
GRANT ALL ON TABLE bio_clinc_trial_time_pt TO biomart_user;
GRANT ALL ON TABLE bio_clinc_trial_time_pt TO tm_cz;


--
-- Name: bio_clinical_trial; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinical_trial FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinical_trial FROM biomart;
GRANT ALL ON TABLE bio_clinical_trial TO biomart;
GRANT ALL ON TABLE bio_clinical_trial TO biomart_user;
GRANT ALL ON TABLE bio_clinical_trial TO tm_cz;


--
-- Name: bio_clinical_trial_design; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinical_trial_design FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinical_trial_design FROM biomart;
GRANT ALL ON TABLE bio_clinical_trial_design TO biomart;
GRANT ALL ON TABLE bio_clinical_trial_design TO biomart_user;
GRANT ALL ON TABLE bio_clinical_trial_design TO tm_cz;


--
-- Name: bio_compound; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_compound FROM PUBLIC;
REVOKE ALL ON TABLE bio_compound FROM biomart;
GRANT ALL ON TABLE bio_compound TO biomart;
GRANT ALL ON TABLE bio_compound TO biomart_user;
GRANT ALL ON TABLE bio_compound TO tm_cz;


--
-- Name: bio_concept_code; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_concept_code FROM PUBLIC;
REVOKE ALL ON TABLE bio_concept_code FROM biomart;
GRANT ALL ON TABLE bio_concept_code TO biomart;
GRANT ALL ON TABLE bio_concept_code TO biomart_user;
GRANT ALL ON TABLE bio_concept_code TO tm_cz;


--
-- Name: bio_content; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_content FROM PUBLIC;
REVOKE ALL ON TABLE bio_content FROM biomart;
GRANT ALL ON TABLE bio_content TO biomart;
GRANT ALL ON TABLE bio_content TO biomart_user;
GRANT ALL ON TABLE bio_content TO tm_cz;


--
-- Name: bio_content_reference; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_content_reference FROM PUBLIC;
REVOKE ALL ON TABLE bio_content_reference FROM biomart;
GRANT ALL ON TABLE bio_content_reference TO biomart;
GRANT ALL ON TABLE bio_content_reference TO biomart_user;
GRANT ALL ON TABLE bio_content_reference TO tm_cz;


--
-- Name: bio_content_repository; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_content_repository FROM PUBLIC;
REVOKE ALL ON TABLE bio_content_repository FROM biomart;
GRANT ALL ON TABLE bio_content_repository TO biomart;
GRANT ALL ON TABLE bio_content_repository TO biomart_user;
GRANT ALL ON TABLE bio_content_repository TO tm_cz;


--
-- Name: bio_curated_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_curated_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_curated_data FROM biomart;
GRANT ALL ON TABLE bio_curated_data TO biomart;
GRANT ALL ON TABLE bio_curated_data TO biomart_user;
GRANT ALL ON TABLE bio_curated_data TO tm_cz;


--
-- Name: bio_curation_dataset; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_curation_dataset FROM PUBLIC;
REVOKE ALL ON TABLE bio_curation_dataset FROM biomart;
GRANT ALL ON TABLE bio_curation_dataset TO biomart;
GRANT ALL ON TABLE bio_curation_dataset TO biomart_user;
GRANT ALL ON TABLE bio_curation_dataset TO tm_cz;


--
-- Name: bio_data_attribute; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_attribute FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_attribute FROM biomart;
GRANT ALL ON TABLE bio_data_attribute TO biomart;
GRANT ALL ON TABLE bio_data_attribute TO biomart_user;
GRANT ALL ON TABLE bio_data_attribute TO tm_cz;


--
-- Name: bio_data_compound; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_compound FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_compound FROM biomart;
GRANT ALL ON TABLE bio_data_compound TO biomart;
GRANT ALL ON TABLE bio_data_compound TO biomart_user;
GRANT ALL ON TABLE bio_data_compound TO tm_cz;


--
-- Name: bio_data_correl_descr; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_correl_descr FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_correl_descr FROM biomart;
GRANT ALL ON TABLE bio_data_correl_descr TO biomart;
GRANT ALL ON TABLE bio_data_correl_descr TO biomart_user;
GRANT ALL ON TABLE bio_data_correl_descr TO tm_cz;


--
-- Name: bio_data_correlation; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_correlation FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_correlation FROM biomart;
GRANT ALL ON TABLE bio_data_correlation TO biomart;
GRANT ALL ON TABLE bio_data_correlation TO biomart_user;
GRANT ALL ON TABLE bio_data_correlation TO tm_cz;


--
-- Name: bio_data_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_disease FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_disease FROM biomart;
GRANT ALL ON TABLE bio_data_disease TO biomart;
GRANT ALL ON TABLE bio_data_disease TO biomart_user;
GRANT ALL ON TABLE bio_data_disease TO tm_cz;


--
-- Name: bio_data_ext_code; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_ext_code FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_ext_code FROM biomart;
GRANT ALL ON TABLE bio_data_ext_code TO biomart;
GRANT ALL ON TABLE bio_data_ext_code TO biomart_user;
GRANT ALL ON TABLE bio_data_ext_code TO tm_cz;


--
-- Name: bio_data_literature; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_literature FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_literature FROM biomart;
GRANT ALL ON TABLE bio_data_literature TO biomart;
GRANT ALL ON TABLE bio_data_literature TO biomart_user;
GRANT ALL ON TABLE bio_data_literature TO tm_cz;


--
-- Name: bio_data_omic_marker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_omic_marker FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_omic_marker FROM biomart;
GRANT ALL ON TABLE bio_data_omic_marker TO biomart;
GRANT ALL ON TABLE bio_data_omic_marker TO biomart_user;
GRANT ALL ON TABLE bio_data_omic_marker TO tm_cz;


--
-- Name: bio_data_taxonomy; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_taxonomy FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_taxonomy FROM biomart;
GRANT ALL ON TABLE bio_data_taxonomy TO biomart;
GRANT ALL ON TABLE bio_data_taxonomy TO biomart_user;
GRANT ALL ON TABLE bio_data_taxonomy TO tm_cz;


--
-- Name: bio_data_uid; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_uid FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_uid FROM biomart;
GRANT ALL ON TABLE bio_data_uid TO biomart;
GRANT ALL ON TABLE bio_data_uid TO biomart_user;
GRANT ALL ON TABLE bio_data_uid TO tm_cz;


--
-- Name: bio_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_disease FROM PUBLIC;
REVOKE ALL ON TABLE bio_disease FROM biomart;
GRANT ALL ON TABLE bio_disease TO biomart;
GRANT ALL ON TABLE bio_disease TO biomart_user;
GRANT ALL ON TABLE bio_disease TO tm_cz;


--
-- Name: bio_experiment; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_experiment FROM PUBLIC;
REVOKE ALL ON TABLE bio_experiment FROM biomart;
GRANT ALL ON TABLE bio_experiment TO biomart;
GRANT ALL ON TABLE bio_experiment TO biomart_user;
GRANT ALL ON TABLE bio_experiment TO tm_cz;


--
-- Name: bio_lit_alt_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_alt_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_alt_data FROM biomart;
GRANT ALL ON TABLE bio_lit_alt_data TO biomart;
GRANT ALL ON TABLE bio_lit_alt_data TO biomart_user;
GRANT ALL ON TABLE bio_lit_alt_data TO tm_cz;


--
-- Name: bio_lit_amd_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_amd_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_amd_data FROM biomart;
GRANT ALL ON TABLE bio_lit_amd_data TO biomart;
GRANT ALL ON TABLE bio_lit_amd_data TO biomart_user;
GRANT ALL ON TABLE bio_lit_amd_data TO tm_cz;


--
-- Name: bio_lit_inh_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_inh_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_inh_data FROM biomart;
GRANT ALL ON TABLE bio_lit_inh_data TO biomart;
GRANT ALL ON TABLE bio_lit_inh_data TO biomart_user;
GRANT ALL ON TABLE bio_lit_inh_data TO tm_cz;


--
-- Name: bio_lit_int_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_int_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_int_data FROM biomart;
GRANT ALL ON TABLE bio_lit_int_data TO biomart;
GRANT ALL ON TABLE bio_lit_int_data TO biomart_user;
GRANT ALL ON TABLE bio_lit_int_data TO tm_cz;


--
-- Name: bio_lit_int_model_mv; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_int_model_mv FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_int_model_mv FROM biomart;
GRANT ALL ON TABLE bio_lit_int_model_mv TO biomart;
GRANT ALL ON TABLE bio_lit_int_model_mv TO biomart_user;
GRANT ALL ON TABLE bio_lit_int_model_mv TO tm_cz;


--
-- Name: bio_lit_model_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_model_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_model_data FROM biomart;
GRANT ALL ON TABLE bio_lit_model_data TO biomart;
GRANT ALL ON TABLE bio_lit_model_data TO biomart_user;
GRANT ALL ON TABLE bio_lit_model_data TO tm_cz;


--
-- Name: bio_lit_int_model_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_int_model_view FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_int_model_view FROM biomart;
GRANT ALL ON TABLE bio_lit_int_model_view TO biomart;
GRANT ALL ON TABLE bio_lit_int_model_view TO biomart_user;
GRANT ALL ON TABLE bio_lit_int_model_view TO tm_cz;


--
-- Name: bio_lit_pe_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_pe_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_pe_data FROM biomart;
GRANT ALL ON TABLE bio_lit_pe_data TO biomart;
GRANT ALL ON TABLE bio_lit_pe_data TO biomart_user;
GRANT ALL ON TABLE bio_lit_pe_data TO tm_cz;


--
-- Name: bio_lit_ref_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_ref_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_ref_data FROM biomart;
GRANT ALL ON TABLE bio_lit_ref_data TO biomart;
GRANT ALL ON TABLE bio_lit_ref_data TO biomart_user;
GRANT ALL ON TABLE bio_lit_ref_data TO tm_cz;


--
-- Name: bio_lit_sum_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_sum_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_sum_data FROM biomart;
GRANT ALL ON TABLE bio_lit_sum_data TO biomart;
GRANT ALL ON TABLE bio_lit_sum_data TO biomart_user;
GRANT ALL ON TABLE bio_lit_sum_data TO tm_cz;


--
-- Name: bio_marker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_marker FROM PUBLIC;
REVOKE ALL ON TABLE bio_marker FROM biomart;
GRANT ALL ON TABLE bio_marker TO biomart;
GRANT ALL ON TABLE bio_marker TO biomart_user;
GRANT ALL ON TABLE bio_marker TO tm_cz;


--
-- Name: bio_marker_correl_mv; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_marker_correl_mv FROM PUBLIC;
REVOKE ALL ON TABLE bio_marker_correl_mv FROM biomart;
GRANT ALL ON TABLE bio_marker_correl_mv TO biomart;
GRANT ALL ON TABLE bio_marker_correl_mv TO biomart_user;
GRANT ALL ON TABLE bio_marker_correl_mv TO tm_cz;


--
-- Name: bio_marker_correl_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_marker_correl_view FROM PUBLIC;
REVOKE ALL ON TABLE bio_marker_correl_view FROM biomart;
GRANT ALL ON TABLE bio_marker_correl_view TO biomart;
GRANT ALL ON TABLE bio_marker_correl_view TO biomart_user;
GRANT ALL ON TABLE bio_marker_correl_view TO tm_cz;


--
-- Name: bio_marker_exp_analysis_mv; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_marker_exp_analysis_mv FROM PUBLIC;
REVOKE ALL ON TABLE bio_marker_exp_analysis_mv FROM biomart;
GRANT ALL ON TABLE bio_marker_exp_analysis_mv TO biomart;
GRANT ALL ON TABLE bio_marker_exp_analysis_mv TO biomart_user;
GRANT ALL ON TABLE bio_marker_exp_analysis_mv TO tm_cz;


--
-- Name: bio_patient; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_patient FROM PUBLIC;
REVOKE ALL ON TABLE bio_patient FROM biomart;
GRANT ALL ON TABLE bio_patient TO biomart;
GRANT ALL ON TABLE bio_patient TO biomart_user;
GRANT ALL ON TABLE bio_patient TO tm_cz;


--
-- Name: bio_patient_event; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_patient_event FROM PUBLIC;
REVOKE ALL ON TABLE bio_patient_event FROM biomart;
GRANT ALL ON TABLE bio_patient_event TO biomart;
GRANT ALL ON TABLE bio_patient_event TO biomart_user;
GRANT ALL ON TABLE bio_patient_event TO tm_cz;


--
-- Name: bio_patient_event_attr; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_patient_event_attr FROM PUBLIC;
REVOKE ALL ON TABLE bio_patient_event_attr FROM biomart;
GRANT ALL ON TABLE bio_patient_event_attr TO biomart;
GRANT ALL ON TABLE bio_patient_event_attr TO biomart_user;
GRANT ALL ON TABLE bio_patient_event_attr TO tm_cz;


--
-- Name: bio_sample; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_sample FROM PUBLIC;
REVOKE ALL ON TABLE bio_sample FROM biomart;
GRANT ALL ON TABLE bio_sample TO biomart;
GRANT ALL ON TABLE bio_sample TO biomart_user;
GRANT ALL ON TABLE bio_sample TO tm_cz;


--
-- Name: bio_stats_exp_marker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_stats_exp_marker FROM PUBLIC;
REVOKE ALL ON TABLE bio_stats_exp_marker FROM biomart;
GRANT ALL ON TABLE bio_stats_exp_marker TO biomart;
GRANT ALL ON TABLE bio_stats_exp_marker TO biomart_user;
GRANT ALL ON TABLE bio_stats_exp_marker TO tm_cz;


--
-- Name: bio_subject; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_subject FROM PUBLIC;
REVOKE ALL ON TABLE bio_subject FROM biomart;
GRANT ALL ON TABLE bio_subject TO biomart;
GRANT ALL ON TABLE bio_subject TO biomart_user;
GRANT ALL ON TABLE bio_subject TO tm_cz;


--
-- Name: bio_taxonomy; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_taxonomy FROM PUBLIC;
REVOKE ALL ON TABLE bio_taxonomy FROM biomart;
GRANT ALL ON TABLE bio_taxonomy TO biomart;
GRANT ALL ON TABLE bio_taxonomy TO biomart_user;
GRANT ALL ON TABLE bio_taxonomy TO tm_cz;


--
-- Name: biobank_sample; Type: ACL; Schema: biomart; Owner: biomart_user
--

REVOKE ALL ON TABLE biobank_sample FROM PUBLIC;
REVOKE ALL ON TABLE biobank_sample FROM biomart_user;
GRANT ALL ON TABLE biobank_sample TO biomart_user;
GRANT ALL ON TABLE biobank_sample TO tm_cz;


--
-- Name: ctd2_clin_inhib_effect; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_clin_inhib_effect FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_clin_inhib_effect FROM biomart;
GRANT ALL ON TABLE ctd2_clin_inhib_effect TO biomart;
GRANT ALL ON TABLE ctd2_clin_inhib_effect TO biomart_user;
GRANT ALL ON TABLE ctd2_clin_inhib_effect TO tm_cz;


--
-- Name: ctd2_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_disease FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_disease FROM biomart;
GRANT ALL ON TABLE ctd2_disease TO biomart;
GRANT ALL ON TABLE ctd2_disease TO biomart_user;
GRANT ALL ON TABLE ctd2_disease TO tm_cz;


--
-- Name: ctd2_inhib_details; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_inhib_details FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_inhib_details FROM biomart;
GRANT ALL ON TABLE ctd2_inhib_details TO biomart;
GRANT ALL ON TABLE ctd2_inhib_details TO biomart_user;
GRANT ALL ON TABLE ctd2_inhib_details TO tm_cz;


--
-- Name: ctd2_study; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_study FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_study FROM biomart;
GRANT ALL ON TABLE ctd2_study TO biomart;
GRANT ALL ON TABLE ctd2_study TO biomart_user;
GRANT ALL ON TABLE ctd2_study TO tm_cz;


--
-- Name: ctd2_trial_details; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_trial_details FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_trial_details FROM biomart;
GRANT ALL ON TABLE ctd2_trial_details TO biomart;
GRANT ALL ON TABLE ctd2_trial_details TO biomart_user;
GRANT ALL ON TABLE ctd2_trial_details TO tm_cz;


--
-- Name: ctd_allowed_meds_treatment; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_allowed_meds_treatment FROM PUBLIC;
REVOKE ALL ON TABLE ctd_allowed_meds_treatment FROM biomart;
GRANT ALL ON TABLE ctd_allowed_meds_treatment TO biomart;
GRANT ALL ON TABLE ctd_allowed_meds_treatment TO biomart_user;
GRANT ALL ON TABLE ctd_allowed_meds_treatment TO tm_cz;


--
-- Name: ctd_full; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_full FROM PUBLIC;
REVOKE ALL ON TABLE ctd_full FROM biomart;
GRANT ALL ON TABLE ctd_full TO biomart;
GRANT ALL ON TABLE ctd_full TO biomart_user;
GRANT ALL ON TABLE ctd_full TO tm_cz;


--
-- Name: ctd_arm_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_arm_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_arm_view FROM biomart;
GRANT ALL ON TABLE ctd_arm_view TO biomart;
GRANT ALL ON TABLE ctd_arm_view TO biomart_user;
GRANT ALL ON TABLE ctd_arm_view TO tm_cz;


--
-- Name: ctd_biomarker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_biomarker FROM PUBLIC;
REVOKE ALL ON TABLE ctd_biomarker FROM biomart;
GRANT ALL ON TABLE ctd_biomarker TO biomart;
GRANT ALL ON TABLE ctd_biomarker TO biomart_user;
GRANT ALL ON TABLE ctd_biomarker TO tm_cz;


--
-- Name: ctd_biomarker_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_biomarker_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_biomarker_view FROM biomart;
GRANT ALL ON TABLE ctd_biomarker_view TO biomart;
GRANT ALL ON TABLE ctd_biomarker_view TO biomart_user;
GRANT ALL ON TABLE ctd_biomarker_view TO tm_cz;


--
-- Name: ctd_cell_info_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_cell_info_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_cell_info_view FROM biomart;
GRANT ALL ON TABLE ctd_cell_info_view TO biomart;
GRANT ALL ON TABLE ctd_cell_info_view TO biomart_user;
GRANT ALL ON TABLE ctd_cell_info_view TO tm_cz;


--
-- Name: ctd_clinical_chars_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_clinical_chars_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_clinical_chars_view FROM biomart;
GRANT ALL ON TABLE ctd_clinical_chars_view TO biomart;
GRANT ALL ON TABLE ctd_clinical_chars_view TO biomart_user;
GRANT ALL ON TABLE ctd_clinical_chars_view TO tm_cz;


--
-- Name: ctd_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_disease FROM PUBLIC;
REVOKE ALL ON TABLE ctd_disease FROM biomart;
GRANT ALL ON TABLE ctd_disease TO biomart;
GRANT ALL ON TABLE ctd_disease TO biomart_user;
GRANT ALL ON TABLE ctd_disease TO tm_cz;


--
-- Name: ctd_drug_effects_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_drug_effects_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_drug_effects_view FROM biomart;
GRANT ALL ON TABLE ctd_drug_effects_view TO biomart;
GRANT ALL ON TABLE ctd_drug_effects_view TO biomart_user;
GRANT ALL ON TABLE ctd_drug_effects_view TO tm_cz;


--
-- Name: ctd_drug_inhib; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_drug_inhib FROM PUBLIC;
REVOKE ALL ON TABLE ctd_drug_inhib FROM biomart;
GRANT ALL ON TABLE ctd_drug_inhib TO biomart;
GRANT ALL ON TABLE ctd_drug_inhib TO biomart_user;
GRANT ALL ON TABLE ctd_drug_inhib TO tm_cz;


--
-- Name: ctd_drug_inhibitor_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_drug_inhibitor_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_drug_inhibitor_view FROM biomart;
GRANT ALL ON TABLE ctd_drug_inhibitor_view TO biomart;
GRANT ALL ON TABLE ctd_drug_inhibitor_view TO biomart_user;
GRANT ALL ON TABLE ctd_drug_inhibitor_view TO tm_cz;


--
-- Name: ctd_events_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_events_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_events_view FROM biomart;
GRANT ALL ON TABLE ctd_events_view TO biomart;
GRANT ALL ON TABLE ctd_events_view TO biomart_user;
GRANT ALL ON TABLE ctd_events_view TO tm_cz;


--
-- Name: ctd_experiments_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_experiments_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_experiments_view FROM biomart;
GRANT ALL ON TABLE ctd_experiments_view TO biomart;
GRANT ALL ON TABLE ctd_experiments_view TO biomart_user;
GRANT ALL ON TABLE ctd_experiments_view TO tm_cz;


--
-- Name: ctd_expr_after_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_expr_after_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_expr_after_view FROM biomart;
GRANT ALL ON TABLE ctd_expr_after_view TO biomart;
GRANT ALL ON TABLE ctd_expr_after_view TO biomart_user;
GRANT ALL ON TABLE ctd_expr_after_view TO tm_cz;


--
-- Name: ctd_expr_baseline_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_expr_baseline_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_expr_baseline_view FROM biomart;
GRANT ALL ON TABLE ctd_expr_baseline_view TO biomart;
GRANT ALL ON TABLE ctd_expr_baseline_view TO biomart_user;
GRANT ALL ON TABLE ctd_expr_baseline_view TO tm_cz;


--
-- Name: ctd_expr_bio_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_expr_bio_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_expr_bio_view FROM biomart;
GRANT ALL ON TABLE ctd_expr_bio_view TO biomart;
GRANT ALL ON TABLE ctd_expr_bio_view TO biomart_user;
GRANT ALL ON TABLE ctd_expr_bio_view TO tm_cz;


--
-- Name: ctd_expr_source_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_expr_source_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_expr_source_view FROM biomart;
GRANT ALL ON TABLE ctd_expr_source_view TO biomart;
GRANT ALL ON TABLE ctd_expr_source_view TO biomart_user;
GRANT ALL ON TABLE ctd_expr_source_view TO tm_cz;


--
-- Name: ctd_full_clinical_endpts_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_full_clinical_endpts_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_full_clinical_endpts_view FROM biomart;
GRANT ALL ON TABLE ctd_full_clinical_endpts_view TO biomart;
GRANT ALL ON TABLE ctd_full_clinical_endpts_view TO biomart_user;
GRANT ALL ON TABLE ctd_full_clinical_endpts_view TO tm_cz;


--
-- Name: ctd_full_search_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_full_search_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_full_search_view FROM biomart;
GRANT ALL ON TABLE ctd_full_search_view TO biomart;
GRANT ALL ON TABLE ctd_full_search_view TO biomart_user;
GRANT ALL ON TABLE ctd_full_search_view TO tm_cz;


--
-- Name: ctd_inclusion_criteria; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_inclusion_criteria FROM PUBLIC;
REVOKE ALL ON TABLE ctd_inclusion_criteria FROM biomart;
GRANT ALL ON TABLE ctd_inclusion_criteria TO biomart;
GRANT ALL ON TABLE ctd_inclusion_criteria TO biomart_user;
GRANT ALL ON TABLE ctd_inclusion_criteria TO tm_cz;


--
-- Name: ctd_primary_endpts; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_primary_endpts FROM PUBLIC;
REVOKE ALL ON TABLE ctd_primary_endpts FROM biomart;
GRANT ALL ON TABLE ctd_primary_endpts TO biomart;
GRANT ALL ON TABLE ctd_primary_endpts TO biomart_user;
GRANT ALL ON TABLE ctd_primary_endpts TO tm_cz;


--
-- Name: ctd_primary_endpts_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_primary_endpts_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_primary_endpts_view FROM biomart;
GRANT ALL ON TABLE ctd_primary_endpts_view TO biomart;
GRANT ALL ON TABLE ctd_primary_endpts_view TO biomart_user;
GRANT ALL ON TABLE ctd_primary_endpts_view TO tm_cz;


--
-- Name: ctd_prior_med_use_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_prior_med_use_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_prior_med_use_view FROM biomart;
GRANT ALL ON TABLE ctd_prior_med_use_view TO biomart;
GRANT ALL ON TABLE ctd_prior_med_use_view TO biomart_user;
GRANT ALL ON TABLE ctd_prior_med_use_view TO tm_cz;


--
-- Name: ctd_pulmonary_path_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_pulmonary_path_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_pulmonary_path_view FROM biomart;
GRANT ALL ON TABLE ctd_pulmonary_path_view TO biomart;
GRANT ALL ON TABLE ctd_pulmonary_path_view TO biomart_user;
GRANT ALL ON TABLE ctd_pulmonary_path_view TO tm_cz;


--
-- Name: ctd_quant_params_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_quant_params_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_quant_params_view FROM biomart;
GRANT ALL ON TABLE ctd_quant_params_view TO biomart;
GRANT ALL ON TABLE ctd_quant_params_view TO biomart_user;
GRANT ALL ON TABLE ctd_quant_params_view TO tm_cz;


--
-- Name: ctd_reference_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_reference_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_reference_view FROM biomart;
GRANT ALL ON TABLE ctd_reference_view TO biomart;
GRANT ALL ON TABLE ctd_reference_view TO biomart_user;
GRANT ALL ON TABLE ctd_reference_view TO tm_cz;


--
-- Name: ctd_runin_therapies_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_runin_therapies_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_runin_therapies_view FROM biomart;
GRANT ALL ON TABLE ctd_runin_therapies_view TO biomart;
GRANT ALL ON TABLE ctd_runin_therapies_view TO biomart_user;
GRANT ALL ON TABLE ctd_runin_therapies_view TO tm_cz;


--
-- Name: ctd_sec_endpts; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_sec_endpts FROM PUBLIC;
REVOKE ALL ON TABLE ctd_sec_endpts FROM biomart;
GRANT ALL ON TABLE ctd_sec_endpts TO biomart;
GRANT ALL ON TABLE ctd_sec_endpts TO biomart_user;
GRANT ALL ON TABLE ctd_sec_endpts TO tm_cz;


--
-- Name: ctd_secondary_endpts_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_secondary_endpts_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_secondary_endpts_view FROM biomart;
GRANT ALL ON TABLE ctd_secondary_endpts_view TO biomart;
GRANT ALL ON TABLE ctd_secondary_endpts_view TO biomart_user;
GRANT ALL ON TABLE ctd_secondary_endpts_view TO tm_cz;


--
-- Name: ctd_stats_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_stats_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_stats_view FROM biomart;
GRANT ALL ON TABLE ctd_stats_view TO biomart;
GRANT ALL ON TABLE ctd_stats_view TO biomart_user;
GRANT ALL ON TABLE ctd_stats_view TO tm_cz;


--
-- Name: ctd_study; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_study FROM PUBLIC;
REVOKE ALL ON TABLE ctd_study FROM biomart;
GRANT ALL ON TABLE ctd_study TO biomart;
GRANT ALL ON TABLE ctd_study TO biomart_user;
GRANT ALL ON TABLE ctd_study TO tm_cz;


--
-- Name: ctd_study_details_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_study_details_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_study_details_view FROM biomart;
GRANT ALL ON TABLE ctd_study_details_view TO biomart;
GRANT ALL ON TABLE ctd_study_details_view TO biomart_user;
GRANT ALL ON TABLE ctd_study_details_view TO tm_cz;


--
-- Name: ctd_td_design_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_design_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_design_view FROM biomart;
GRANT ALL ON TABLE ctd_td_design_view TO biomart;
GRANT ALL ON TABLE ctd_td_design_view TO biomart_user;
GRANT ALL ON TABLE ctd_td_design_view TO tm_cz;


--
-- Name: ctd_td_excl_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_excl_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_excl_view FROM biomart;
GRANT ALL ON TABLE ctd_td_excl_view TO biomart;
GRANT ALL ON TABLE ctd_td_excl_view TO biomart_user;
GRANT ALL ON TABLE ctd_td_excl_view TO tm_cz;


--
-- Name: ctd_td_inclusion_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_inclusion_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_inclusion_view FROM biomart;
GRANT ALL ON TABLE ctd_td_inclusion_view TO biomart;
GRANT ALL ON TABLE ctd_td_inclusion_view TO biomart_user;
GRANT ALL ON TABLE ctd_td_inclusion_view TO tm_cz;


--
-- Name: ctd_td_smoker_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_smoker_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_smoker_view FROM biomart;
GRANT ALL ON TABLE ctd_td_smoker_view TO biomart;
GRANT ALL ON TABLE ctd_td_smoker_view TO biomart_user;
GRANT ALL ON TABLE ctd_td_smoker_view TO tm_cz;


--
-- Name: ctd_td_sponsor_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_sponsor_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_sponsor_view FROM biomart;
GRANT ALL ON TABLE ctd_td_sponsor_view TO biomart;
GRANT ALL ON TABLE ctd_td_sponsor_view TO biomart_user;
GRANT ALL ON TABLE ctd_td_sponsor_view TO tm_cz;


--
-- Name: ctd_td_status_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_status_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_status_view FROM biomart;
GRANT ALL ON TABLE ctd_td_status_view TO biomart;
GRANT ALL ON TABLE ctd_td_status_view TO biomart_user;
GRANT ALL ON TABLE ctd_td_status_view TO tm_cz;


--
-- Name: ctd_treatment_phases_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_treatment_phases_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_treatment_phases_view FROM biomart;
GRANT ALL ON TABLE ctd_treatment_phases_view TO biomart;
GRANT ALL ON TABLE ctd_treatment_phases_view TO biomart_user;
GRANT ALL ON TABLE ctd_treatment_phases_view TO tm_cz;


--
-- Name: hibernate_sequence; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE hibernate_sequence FROM PUBLIC;
REVOKE ALL ON SEQUENCE hibernate_sequence FROM biomart;
GRANT ALL ON SEQUENCE hibernate_sequence TO biomart;
GRANT ALL ON SEQUENCE hibernate_sequence TO biomart_user;
GRANT ALL ON SEQUENCE hibernate_sequence TO tm_cz;


--
-- Name: seq_bio_data_fact_id; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE seq_bio_data_fact_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_bio_data_fact_id FROM biomart;
GRANT ALL ON SEQUENCE seq_bio_data_fact_id TO biomart;
GRANT ALL ON SEQUENCE seq_bio_data_fact_id TO biomart_user;
GRANT ALL ON SEQUENCE seq_bio_data_fact_id TO tm_cz;


--
-- Name: seq_bio_data_id; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE seq_bio_data_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_bio_data_id FROM biomart;
GRANT ALL ON SEQUENCE seq_bio_data_id TO biomart;
GRANT ALL ON SEQUENCE seq_bio_data_id TO biomart_user;
GRANT ALL ON SEQUENCE seq_bio_data_id TO tm_cz;


--
-- Name: seq_clinical_trial_design_id; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE seq_clinical_trial_design_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_clinical_trial_design_id FROM biomart;
GRANT ALL ON SEQUENCE seq_clinical_trial_design_id TO biomart;
GRANT ALL ON SEQUENCE seq_clinical_trial_design_id TO biomart_user;
GRANT ALL ON SEQUENCE seq_clinical_trial_design_id TO tm_cz;


--
-- Name: tmp_analysis_data_tea_rank; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE tmp_analysis_data_tea_rank FROM PUBLIC;
REVOKE ALL ON TABLE tmp_analysis_data_tea_rank FROM biomart;
GRANT ALL ON TABLE tmp_analysis_data_tea_rank TO biomart;
GRANT ALL ON TABLE tmp_analysis_data_tea_rank TO biomart_user;
GRANT ALL ON TABLE tmp_analysis_data_tea_rank TO tm_cz;


SET search_path = deapp, pg_catalog;

--
-- Name: de_chromosomal_region; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_chromosomal_region FROM PUBLIC;
REVOKE ALL ON TABLE de_chromosomal_region FROM deapp;
GRANT ALL ON TABLE de_chromosomal_region TO deapp;
GRANT ALL ON TABLE de_chromosomal_region TO biomart_user;


--
-- Name: de_chromosomal_region_region_id_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_chromosomal_region_region_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_chromosomal_region_region_id_seq FROM deapp;
GRANT ALL ON SEQUENCE de_chromosomal_region_region_id_seq TO deapp;
GRANT ALL ON SEQUENCE de_chromosomal_region_region_id_seq TO biomart_user;


--
-- Name: de_gpl_info; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_gpl_info FROM PUBLIC;
REVOKE ALL ON TABLE de_gpl_info FROM deapp;
GRANT ALL ON TABLE de_gpl_info TO deapp;
GRANT ALL ON TABLE de_gpl_info TO biomart_user;


--
-- Name: de_mrna_annotation; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_mrna_annotation FROM PUBLIC;
REVOKE ALL ON TABLE de_mrna_annotation FROM deapp;
GRANT ALL ON TABLE de_mrna_annotation TO deapp;
GRANT ALL ON TABLE de_mrna_annotation TO biomart_user;


--
-- Name: de_parent_cd_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_parent_cd_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_parent_cd_seq FROM deapp;
GRANT ALL ON SEQUENCE de_parent_cd_seq TO deapp;
GRANT ALL ON SEQUENCE de_parent_cd_seq TO biomart_user;


--
-- Name: de_pathway; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_pathway FROM PUBLIC;
REVOKE ALL ON TABLE de_pathway FROM deapp;
GRANT ALL ON TABLE de_pathway TO deapp;
GRANT ALL ON TABLE de_pathway TO biomart_user;


--
-- Name: de_pathway_gene; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_pathway_gene FROM PUBLIC;
REVOKE ALL ON TABLE de_pathway_gene FROM deapp;
GRANT ALL ON TABLE de_pathway_gene TO deapp;
GRANT ALL ON TABLE de_pathway_gene TO biomart_user;


--
-- Name: de_saved_comparison; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_saved_comparison FROM PUBLIC;
REVOKE ALL ON TABLE de_saved_comparison FROM deapp;
GRANT ALL ON TABLE de_saved_comparison TO deapp;
GRANT ALL ON TABLE de_saved_comparison TO biomart_user;


--
-- Name: de_snp_calls_by_gsm; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_calls_by_gsm FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_calls_by_gsm FROM deapp;
GRANT ALL ON TABLE de_snp_calls_by_gsm TO deapp;
GRANT ALL ON TABLE de_snp_calls_by_gsm TO biomart_user;


--
-- Name: de_snp_copy_number; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_copy_number FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_copy_number FROM deapp;
GRANT ALL ON TABLE de_snp_copy_number TO deapp;
GRANT ALL ON TABLE de_snp_copy_number TO biomart_user;


--
-- Name: de_snp_data_by_patient; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_data_by_patient FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_data_by_patient FROM deapp;
GRANT ALL ON TABLE de_snp_data_by_patient TO deapp;
GRANT ALL ON TABLE de_snp_data_by_patient TO biomart_user;


--
-- Name: de_snp_data_by_probe; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_data_by_probe FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_data_by_probe FROM deapp;
GRANT ALL ON TABLE de_snp_data_by_probe TO deapp;
GRANT ALL ON TABLE de_snp_data_by_probe TO biomart_user;


--
-- Name: de_snp_data_dataset_loc; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_data_dataset_loc FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_data_dataset_loc FROM deapp;
GRANT ALL ON TABLE de_snp_data_dataset_loc TO deapp;
GRANT ALL ON TABLE de_snp_data_dataset_loc TO biomart_user;


--
-- Name: de_snp_gene_map; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_gene_map FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_gene_map FROM deapp;
GRANT ALL ON TABLE de_snp_gene_map TO deapp;
GRANT ALL ON TABLE de_snp_gene_map TO biomart_user;


--
-- Name: de_snp_info; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_info FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_info FROM deapp;
GRANT ALL ON TABLE de_snp_info TO deapp;
GRANT ALL ON TABLE de_snp_info TO biomart_user;


--
-- Name: de_snp_probe; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_probe FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_probe FROM deapp;
GRANT ALL ON TABLE de_snp_probe TO deapp;
GRANT ALL ON TABLE de_snp_probe TO biomart_user;


--
-- Name: de_snp_probe_sorted_def; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_probe_sorted_def FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_probe_sorted_def FROM deapp;
GRANT ALL ON TABLE de_snp_probe_sorted_def TO deapp;
GRANT ALL ON TABLE de_snp_probe_sorted_def TO biomart_user;


--
-- Name: de_snp_subject_sorted_def; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_subject_sorted_def FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_subject_sorted_def FROM deapp;
GRANT ALL ON TABLE de_snp_subject_sorted_def TO deapp;
GRANT ALL ON TABLE de_snp_subject_sorted_def TO biomart_user;


--
-- Name: de_subject_acgh_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_acgh_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_acgh_data FROM deapp;
GRANT ALL ON TABLE de_subject_acgh_data TO deapp;
GRANT ALL ON TABLE de_subject_acgh_data TO biomart_user;


--
-- Name: de_subject_microarray_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_microarray_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_microarray_data FROM deapp;
GRANT ALL ON TABLE de_subject_microarray_data TO deapp;
GRANT ALL ON TABLE de_subject_microarray_data TO biomart_user;
GRANT ALL ON TABLE de_subject_microarray_data TO tm_cz;


--
-- Name: de_subject_microarray_logs; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_microarray_logs FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_microarray_logs FROM deapp;
GRANT ALL ON TABLE de_subject_microarray_logs TO deapp;
GRANT ALL ON TABLE de_subject_microarray_logs TO biomart_user;


--
-- Name: de_subject_microarray_med; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_microarray_med FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_microarray_med FROM deapp;
GRANT ALL ON TABLE de_subject_microarray_med TO deapp;
GRANT ALL ON TABLE de_subject_microarray_med TO biomart_user;


--
-- Name: de_subject_protein_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_protein_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_protein_data FROM deapp;
GRANT ALL ON TABLE de_subject_protein_data TO deapp;
GRANT ALL ON TABLE de_subject_protein_data TO biomart_user;


--
-- Name: de_subject_rbm_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_rbm_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_rbm_data FROM deapp;
GRANT ALL ON TABLE de_subject_rbm_data TO deapp;
GRANT ALL ON TABLE de_subject_rbm_data TO biomart_user;


--
-- Name: de_subject_sample_mapping; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_sample_mapping FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_sample_mapping FROM deapp;
GRANT ALL ON TABLE de_subject_sample_mapping TO deapp;
GRANT ALL ON TABLE de_subject_sample_mapping TO biomart_user;
GRANT ALL ON TABLE de_subject_sample_mapping TO tm_cz;


--
-- Name: de_subject_snp_dataset; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_snp_dataset FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_snp_dataset FROM deapp;
GRANT ALL ON TABLE de_subject_snp_dataset TO deapp;
GRANT ALL ON TABLE de_subject_snp_dataset TO biomart_user;


--
-- Name: de_xtrial_child_map; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_xtrial_child_map FROM PUBLIC;
REVOKE ALL ON TABLE de_xtrial_child_map FROM deapp;
GRANT ALL ON TABLE de_xtrial_child_map TO deapp;
GRANT ALL ON TABLE de_xtrial_child_map TO biomart_user;


--
-- Name: de_xtrial_parent_names; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_xtrial_parent_names FROM PUBLIC;
REVOKE ALL ON TABLE de_xtrial_parent_names FROM deapp;
GRANT ALL ON TABLE de_xtrial_parent_names TO deapp;
GRANT ALL ON TABLE de_xtrial_parent_names TO biomart_user;


--
-- Name: deapp_annotation; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE deapp_annotation FROM PUBLIC;
REVOKE ALL ON TABLE deapp_annotation FROM deapp;
GRANT ALL ON TABLE deapp_annotation TO deapp;
GRANT ALL ON TABLE deapp_annotation TO biomart_user;


--
-- Name: haploview_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE haploview_data FROM PUBLIC;
REVOKE ALL ON TABLE haploview_data FROM deapp;
GRANT ALL ON TABLE haploview_data TO deapp;
GRANT ALL ON TABLE haploview_data TO biomart_user;


--
-- Name: seq_assay_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_assay_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_assay_id FROM deapp;
GRANT ALL ON SEQUENCE seq_assay_id TO deapp;
GRANT ALL ON SEQUENCE seq_assay_id TO biomart_user;


--
-- Name: seq_data_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_data_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_data_id FROM deapp;
GRANT ALL ON SEQUENCE seq_data_id TO deapp;
GRANT ALL ON SEQUENCE seq_data_id TO biomart_user;


--
-- Name: seq_mrna_partition_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_mrna_partition_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_mrna_partition_id FROM deapp;
GRANT ALL ON SEQUENCE seq_mrna_partition_id TO deapp;
GRANT ALL ON SEQUENCE seq_mrna_partition_id TO biomart_user;


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: archive_observation_fact; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE archive_observation_fact FROM PUBLIC;
REVOKE ALL ON TABLE archive_observation_fact FROM i2b2demodata;
GRANT ALL ON TABLE archive_observation_fact TO i2b2demodata;
GRANT ALL ON TABLE archive_observation_fact TO biomart_user;
GRANT ALL ON TABLE archive_observation_fact TO tm_cz;


--
-- Name: async_job; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE async_job FROM PUBLIC;
REVOKE ALL ON TABLE async_job FROM i2b2demodata;
GRANT ALL ON TABLE async_job TO i2b2demodata;
GRANT ALL ON TABLE async_job TO biomart_user;
GRANT ALL ON TABLE async_job TO tm_cz;


--
-- Name: code_lookup; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE code_lookup FROM PUBLIC;
REVOKE ALL ON TABLE code_lookup FROM i2b2demodata;
GRANT ALL ON TABLE code_lookup TO i2b2demodata;
GRANT ALL ON TABLE code_lookup TO biomart_user;
GRANT ALL ON TABLE code_lookup TO tm_cz;


--
-- Name: concept_counts; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE concept_counts FROM PUBLIC;
REVOKE ALL ON TABLE concept_counts FROM i2b2demodata;
GRANT ALL ON TABLE concept_counts TO i2b2demodata;
GRANT ALL ON TABLE concept_counts TO biomart_user;
GRANT ALL ON TABLE concept_counts TO tm_cz;


--
-- Name: concept_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE concept_dimension FROM PUBLIC;
REVOKE ALL ON TABLE concept_dimension FROM i2b2demodata;
GRANT ALL ON TABLE concept_dimension TO i2b2demodata;
GRANT ALL ON TABLE concept_dimension TO biomart_user;
GRANT ALL ON TABLE concept_dimension TO tm_cz;


--
-- Name: concept_id; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE concept_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE concept_id FROM i2b2demodata;
GRANT ALL ON SEQUENCE concept_id TO i2b2demodata;
GRANT ALL ON SEQUENCE concept_id TO biomart_user;
GRANT ALL ON SEQUENCE concept_id TO tm_cz;


--
-- Name: datamart_report; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE datamart_report FROM PUBLIC;
REVOKE ALL ON TABLE datamart_report FROM i2b2demodata;
GRANT ALL ON TABLE datamart_report TO i2b2demodata;
GRANT ALL ON TABLE datamart_report TO biomart_user;
GRANT ALL ON TABLE datamart_report TO tm_cz;


--
-- Name: encounter_mapping; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE encounter_mapping FROM PUBLIC;
REVOKE ALL ON TABLE encounter_mapping FROM i2b2demodata;
GRANT ALL ON TABLE encounter_mapping TO i2b2demodata;
GRANT ALL ON TABLE encounter_mapping TO biomart_user;
GRANT ALL ON TABLE encounter_mapping TO tm_cz;


--
-- Name: modifier_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE modifier_dimension FROM PUBLIC;
REVOKE ALL ON TABLE modifier_dimension FROM i2b2demodata;
GRANT ALL ON TABLE modifier_dimension TO i2b2demodata;
GRANT ALL ON TABLE modifier_dimension TO biomart_user;
GRANT ALL ON TABLE modifier_dimension TO tm_cz;


--
-- Name: news_updates; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE news_updates FROM PUBLIC;
REVOKE ALL ON TABLE news_updates FROM i2b2demodata;
GRANT ALL ON TABLE news_updates TO i2b2demodata;
GRANT ALL ON TABLE news_updates TO biomart_user;
GRANT ALL ON TABLE news_updates TO tm_cz;


--
-- Name: observation_fact; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE observation_fact FROM PUBLIC;
REVOKE ALL ON TABLE observation_fact FROM i2b2demodata;
GRANT ALL ON TABLE observation_fact TO i2b2demodata;
GRANT ALL ON TABLE observation_fact TO biomart_user;
GRANT ALL ON TABLE observation_fact TO tm_cz;


--
-- Name: patient_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE patient_dimension FROM PUBLIC;
REVOKE ALL ON TABLE patient_dimension FROM i2b2demodata;
GRANT ALL ON TABLE patient_dimension TO i2b2demodata;
GRANT ALL ON TABLE patient_dimension TO biomart_user;
GRANT ALL ON TABLE patient_dimension TO tm_cz;


--
-- Name: patient_mapping; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE patient_mapping FROM PUBLIC;
REVOKE ALL ON TABLE patient_mapping FROM i2b2demodata;
GRANT ALL ON TABLE patient_mapping TO i2b2demodata;
GRANT ALL ON TABLE patient_mapping TO biomart_user;
GRANT ALL ON TABLE patient_mapping TO tm_cz;


--
-- Name: patient_trial; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE patient_trial FROM PUBLIC;
REVOKE ALL ON TABLE patient_trial FROM i2b2demodata;
GRANT ALL ON TABLE patient_trial TO i2b2demodata;
GRANT ALL ON TABLE patient_trial TO biomart_user;
GRANT ALL ON TABLE patient_trial TO tm_cz;


--
-- Name: provider_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE provider_dimension FROM PUBLIC;
REVOKE ALL ON TABLE provider_dimension FROM i2b2demodata;
GRANT ALL ON TABLE provider_dimension TO i2b2demodata;
GRANT ALL ON TABLE provider_dimension TO biomart_user;
GRANT ALL ON TABLE provider_dimension TO tm_cz;


--
-- Name: qt_analysis_plugin; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_analysis_plugin FROM PUBLIC;
REVOKE ALL ON TABLE qt_analysis_plugin FROM i2b2demodata;
GRANT ALL ON TABLE qt_analysis_plugin TO i2b2demodata;
GRANT ALL ON TABLE qt_analysis_plugin TO biomart_user;
GRANT ALL ON TABLE qt_analysis_plugin TO tm_cz;


--
-- Name: qt_analysis_plugin_result_type; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_analysis_plugin_result_type FROM PUBLIC;
REVOKE ALL ON TABLE qt_analysis_plugin_result_type FROM i2b2demodata;
GRANT ALL ON TABLE qt_analysis_plugin_result_type TO i2b2demodata;
GRANT ALL ON TABLE qt_analysis_plugin_result_type TO biomart_user;
GRANT ALL ON TABLE qt_analysis_plugin_result_type TO tm_cz;


--
-- Name: qt_breakdown_path; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_breakdown_path FROM PUBLIC;
REVOKE ALL ON TABLE qt_breakdown_path FROM i2b2demodata;
GRANT ALL ON TABLE qt_breakdown_path TO i2b2demodata;
GRANT ALL ON TABLE qt_breakdown_path TO biomart_user;
GRANT ALL ON TABLE qt_breakdown_path TO tm_cz;


--
-- Name: qt_sq_qper_pecid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qper_pecid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qper_pecid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qper_pecid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qper_pecid TO biomart_user;
GRANT ALL ON SEQUENCE qt_sq_qper_pecid TO tm_cz;


--
-- Name: qt_patient_enc_collection; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_patient_enc_collection FROM PUBLIC;
REVOKE ALL ON TABLE qt_patient_enc_collection FROM i2b2demodata;
GRANT ALL ON TABLE qt_patient_enc_collection TO i2b2demodata;
GRANT ALL ON TABLE qt_patient_enc_collection TO biomart_user;
GRANT ALL ON TABLE qt_patient_enc_collection TO tm_cz;


--
-- Name: qt_sq_qpr_pcid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qpr_pcid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qpr_pcid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qpr_pcid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qpr_pcid TO biomart_user;
GRANT ALL ON SEQUENCE qt_sq_qpr_pcid TO tm_cz;


--
-- Name: qt_patient_set_collection; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_patient_set_collection FROM PUBLIC;
REVOKE ALL ON TABLE qt_patient_set_collection FROM i2b2demodata;
GRANT ALL ON TABLE qt_patient_set_collection TO i2b2demodata;
GRANT ALL ON TABLE qt_patient_set_collection TO biomart_user;
GRANT ALL ON TABLE qt_patient_set_collection TO tm_cz;


--
-- Name: qt_sq_pqm_qmid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_pqm_qmid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_pqm_qmid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_pqm_qmid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_pqm_qmid TO biomart_user;
GRANT ALL ON SEQUENCE qt_sq_pqm_qmid TO tm_cz;


--
-- Name: qt_pdo_query_master; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_pdo_query_master FROM PUBLIC;
REVOKE ALL ON TABLE qt_pdo_query_master FROM i2b2demodata;
GRANT ALL ON TABLE qt_pdo_query_master TO i2b2demodata;
GRANT ALL ON TABLE qt_pdo_query_master TO biomart_user;
GRANT ALL ON TABLE qt_pdo_query_master TO tm_cz;


--
-- Name: qt_privilege; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_privilege FROM PUBLIC;
REVOKE ALL ON TABLE qt_privilege FROM i2b2demodata;
GRANT ALL ON TABLE qt_privilege TO i2b2demodata;
GRANT ALL ON TABLE qt_privilege TO biomart_user;
GRANT ALL ON TABLE qt_privilege TO tm_cz;


--
-- Name: qt_sq_qi_qiid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qi_qiid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qi_qiid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qi_qiid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qi_qiid TO biomart_user;
GRANT ALL ON SEQUENCE qt_sq_qi_qiid TO tm_cz;


--
-- Name: qt_query_instance; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_instance FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_instance FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_instance TO i2b2demodata;
GRANT ALL ON TABLE qt_query_instance TO biomart_user;
GRANT ALL ON TABLE qt_query_instance TO tm_cz;


--
-- Name: qt_sq_qm_qmid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qm_qmid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qm_qmid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qm_qmid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qm_qmid TO biomart_user;
GRANT ALL ON SEQUENCE qt_sq_qm_qmid TO tm_cz;


--
-- Name: qt_query_master; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_master FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_master FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_master TO i2b2demodata;
GRANT ALL ON TABLE qt_query_master TO biomart_user;
GRANT ALL ON TABLE qt_query_master TO tm_cz;


--
-- Name: qt_sq_qri_qriid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qri_qriid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qri_qriid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qri_qriid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qri_qriid TO biomart_user;
GRANT ALL ON SEQUENCE qt_sq_qri_qriid TO tm_cz;


--
-- Name: qt_query_result_instance; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_result_instance FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_result_instance FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_result_instance TO i2b2demodata;
GRANT ALL ON TABLE qt_query_result_instance TO biomart_user;
GRANT ALL ON TABLE qt_query_result_instance TO tm_cz;


--
-- Name: qt_sq_qr_qrid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qr_qrid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qr_qrid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qr_qrid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qr_qrid TO biomart_user;
GRANT ALL ON SEQUENCE qt_sq_qr_qrid TO tm_cz;


--
-- Name: qt_query_result_type; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_result_type FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_result_type FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_result_type TO i2b2demodata;
GRANT ALL ON TABLE qt_query_result_type TO biomart_user;
GRANT ALL ON TABLE qt_query_result_type TO tm_cz;


--
-- Name: qt_sq_qs_qsid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qs_qsid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qs_qsid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qs_qsid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qs_qsid TO biomart_user;
GRANT ALL ON SEQUENCE qt_sq_qs_qsid TO tm_cz;


--
-- Name: qt_query_status_type; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_status_type FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_status_type FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_status_type TO i2b2demodata;
GRANT ALL ON TABLE qt_query_status_type TO biomart_user;
GRANT ALL ON TABLE qt_query_status_type TO tm_cz;


--
-- Name: qt_sq_qxr_xrid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qxr_xrid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qxr_xrid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qxr_xrid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qxr_xrid TO biomart_user;
GRANT ALL ON SEQUENCE qt_sq_qxr_xrid TO tm_cz;


--
-- Name: qt_xml_result; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_xml_result FROM PUBLIC;
REVOKE ALL ON TABLE qt_xml_result FROM i2b2demodata;
GRANT ALL ON TABLE qt_xml_result TO i2b2demodata;
GRANT ALL ON TABLE qt_xml_result TO biomart_user;
GRANT ALL ON TABLE qt_xml_result TO tm_cz;


--
-- Name: sample_categories; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE sample_categories FROM PUBLIC;
REVOKE ALL ON TABLE sample_categories FROM i2b2demodata;
GRANT ALL ON TABLE sample_categories TO i2b2demodata;
GRANT ALL ON TABLE sample_categories TO biomart_user;
GRANT ALL ON TABLE sample_categories TO tm_cz;


--
-- Name: seq_patient_num; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE seq_patient_num FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_patient_num FROM i2b2demodata;
GRANT ALL ON SEQUENCE seq_patient_num TO i2b2demodata;
GRANT ALL ON SEQUENCE seq_patient_num TO biomart_user;
GRANT ALL ON SEQUENCE seq_patient_num TO tm_cz;


--
-- Name: sq_up_patdim_patientnum; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE sq_up_patdim_patientnum FROM PUBLIC;
REVOKE ALL ON SEQUENCE sq_up_patdim_patientnum FROM i2b2demodata;
GRANT ALL ON SEQUENCE sq_up_patdim_patientnum TO i2b2demodata;
GRANT ALL ON SEQUENCE sq_up_patdim_patientnum TO biomart_user;
GRANT ALL ON SEQUENCE sq_up_patdim_patientnum TO tm_cz;


--
-- Name: set_type; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE set_type FROM PUBLIC;
REVOKE ALL ON TABLE set_type FROM i2b2demodata;
GRANT ALL ON TABLE set_type TO i2b2demodata;
GRANT ALL ON TABLE set_type TO biomart_user;
GRANT ALL ON TABLE set_type TO tm_cz;


--
-- Name: set_upload_status; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE set_upload_status FROM PUBLIC;
REVOKE ALL ON TABLE set_upload_status FROM i2b2demodata;
GRANT ALL ON TABLE set_upload_status TO i2b2demodata;
GRANT ALL ON TABLE set_upload_status TO biomart_user;
GRANT ALL ON TABLE set_upload_status TO tm_cz;


--
-- Name: source_master; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE source_master FROM PUBLIC;
REVOKE ALL ON TABLE source_master FROM i2b2demodata;
GRANT ALL ON TABLE source_master TO i2b2demodata;
GRANT ALL ON TABLE source_master TO biomart_user;
GRANT ALL ON TABLE source_master TO tm_cz;


--
-- Name: sq_up_encdim_encounternum; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE sq_up_encdim_encounternum FROM PUBLIC;
REVOKE ALL ON SEQUENCE sq_up_encdim_encounternum FROM i2b2demodata;
GRANT ALL ON SEQUENCE sq_up_encdim_encounternum TO i2b2demodata;
GRANT ALL ON SEQUENCE sq_up_encdim_encounternum TO biomart_user;
GRANT ALL ON SEQUENCE sq_up_encdim_encounternum TO tm_cz;


--
-- Name: sq_uploadstatus_uploadid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE sq_uploadstatus_uploadid FROM PUBLIC;
REVOKE ALL ON SEQUENCE sq_uploadstatus_uploadid FROM i2b2demodata;
GRANT ALL ON SEQUENCE sq_uploadstatus_uploadid TO i2b2demodata;
GRANT ALL ON SEQUENCE sq_uploadstatus_uploadid TO biomart_user;
GRANT ALL ON SEQUENCE sq_uploadstatus_uploadid TO tm_cz;


--
-- Name: upload_status; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE upload_status FROM PUBLIC;
REVOKE ALL ON TABLE upload_status FROM i2b2demodata;
GRANT ALL ON TABLE upload_status TO i2b2demodata;
GRANT ALL ON TABLE upload_status TO biomart_user;
GRANT ALL ON TABLE upload_status TO tm_cz;


--
-- Name: visit_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE visit_dimension FROM PUBLIC;
REVOKE ALL ON TABLE visit_dimension FROM i2b2demodata;
GRANT ALL ON TABLE visit_dimension TO i2b2demodata;
GRANT ALL ON TABLE visit_dimension TO biomart_user;
GRANT ALL ON TABLE visit_dimension TO tm_cz;


SET search_path = i2b2hive, pg_catalog;

--
-- Name: crc_analysis_job; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE crc_analysis_job FROM PUBLIC;
REVOKE ALL ON TABLE crc_analysis_job FROM i2b2hive;
GRANT ALL ON TABLE crc_analysis_job TO i2b2hive;
GRANT ALL ON TABLE crc_analysis_job TO biomart_user;


--
-- Name: crc_db_lookup; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE crc_db_lookup FROM PUBLIC;
REVOKE ALL ON TABLE crc_db_lookup FROM i2b2hive;
GRANT ALL ON TABLE crc_db_lookup TO i2b2hive;
GRANT ALL ON TABLE crc_db_lookup TO biomart_user;


--
-- Name: hilosequences; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE hilosequences FROM PUBLIC;
REVOKE ALL ON TABLE hilosequences FROM i2b2hive;
GRANT ALL ON TABLE hilosequences TO i2b2hive;
GRANT ALL ON TABLE hilosequences TO biomart_user;


--
-- Name: jms_messages; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE jms_messages FROM PUBLIC;
REVOKE ALL ON TABLE jms_messages FROM i2b2hive;
GRANT ALL ON TABLE jms_messages TO i2b2hive;
GRANT ALL ON TABLE jms_messages TO biomart_user;


--
-- Name: jms_roles; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE jms_roles FROM PUBLIC;
REVOKE ALL ON TABLE jms_roles FROM i2b2hive;
GRANT ALL ON TABLE jms_roles TO i2b2hive;
GRANT ALL ON TABLE jms_roles TO biomart_user;


--
-- Name: jms_subscriptions; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE jms_subscriptions FROM PUBLIC;
REVOKE ALL ON TABLE jms_subscriptions FROM i2b2hive;
GRANT ALL ON TABLE jms_subscriptions TO i2b2hive;
GRANT ALL ON TABLE jms_subscriptions TO biomart_user;


--
-- Name: jms_transactions; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE jms_transactions FROM PUBLIC;
REVOKE ALL ON TABLE jms_transactions FROM i2b2hive;
GRANT ALL ON TABLE jms_transactions TO i2b2hive;
GRANT ALL ON TABLE jms_transactions TO biomart_user;


--
-- Name: jms_users; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE jms_users FROM PUBLIC;
REVOKE ALL ON TABLE jms_users FROM i2b2hive;
GRANT ALL ON TABLE jms_users TO i2b2hive;
GRANT ALL ON TABLE jms_users TO biomart_user;


--
-- Name: ont_db_lookup; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE ont_db_lookup FROM PUBLIC;
REVOKE ALL ON TABLE ont_db_lookup FROM i2b2hive;
GRANT ALL ON TABLE ont_db_lookup TO i2b2hive;
GRANT ALL ON TABLE ont_db_lookup TO biomart_user;


--
-- Name: timers; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE timers FROM PUBLIC;
REVOKE ALL ON TABLE timers FROM i2b2hive;
GRANT ALL ON TABLE timers TO i2b2hive;
GRANT ALL ON TABLE timers TO biomart_user;


--
-- Name: work_db_lookup; Type: ACL; Schema: i2b2hive; Owner: i2b2hive
--

REVOKE ALL ON TABLE work_db_lookup FROM PUBLIC;
REVOKE ALL ON TABLE work_db_lookup FROM i2b2hive;
GRANT ALL ON TABLE work_db_lookup TO i2b2hive;
GRANT ALL ON TABLE work_db_lookup TO biomart_user;


SET search_path = i2b2metadata, pg_catalog;

--
-- Name: birn; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE birn FROM PUBLIC;
REVOKE ALL ON TABLE birn FROM i2b2metadata;
GRANT ALL ON TABLE birn TO i2b2metadata;
GRANT ALL ON TABLE birn TO biomart_user;
GRANT ALL ON TABLE birn TO tm_cz;


--
-- Name: custom_meta; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE custom_meta FROM PUBLIC;
REVOKE ALL ON TABLE custom_meta FROM i2b2metadata;
GRANT ALL ON TABLE custom_meta TO i2b2metadata;
GRANT ALL ON TABLE custom_meta TO biomart_user;
GRANT ALL ON TABLE custom_meta TO tm_cz;


--
-- Name: i2b2; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE i2b2 FROM PUBLIC;
REVOKE ALL ON TABLE i2b2 FROM i2b2metadata;
GRANT ALL ON TABLE i2b2 TO i2b2metadata;
GRANT ALL ON TABLE i2b2 TO biomart_user;
GRANT ALL ON TABLE i2b2 TO tm_cz;


--
-- Name: i2b2_secure; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE i2b2_secure FROM PUBLIC;
REVOKE ALL ON TABLE i2b2_secure FROM i2b2metadata;
GRANT ALL ON TABLE i2b2_secure TO i2b2metadata;
GRANT ALL ON TABLE i2b2_secure TO biomart_user;
GRANT ALL ON TABLE i2b2_secure TO tm_cz;


--
-- Name: i2b2_tags; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE i2b2_tags FROM PUBLIC;
REVOKE ALL ON TABLE i2b2_tags FROM i2b2metadata;
GRANT ALL ON TABLE i2b2_tags TO i2b2metadata;
GRANT ALL ON TABLE i2b2_tags TO biomart_user;
GRANT ALL ON TABLE i2b2_tags TO tm_cz;


--
-- Name: ont_sq_ps_prid; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON SEQUENCE ont_sq_ps_prid FROM PUBLIC;
REVOKE ALL ON SEQUENCE ont_sq_ps_prid FROM i2b2metadata;
GRANT ALL ON SEQUENCE ont_sq_ps_prid TO i2b2metadata;
GRANT ALL ON SEQUENCE ont_sq_ps_prid TO biomart_user;
GRANT ALL ON SEQUENCE ont_sq_ps_prid TO tm_cz;


--
-- Name: ont_process_status; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE ont_process_status FROM PUBLIC;
REVOKE ALL ON TABLE ont_process_status FROM i2b2metadata;
GRANT ALL ON TABLE ont_process_status TO i2b2metadata;
GRANT ALL ON TABLE ont_process_status TO biomart_user;
GRANT ALL ON TABLE ont_process_status TO tm_cz;


--
-- Name: schemes; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE schemes FROM PUBLIC;
REVOKE ALL ON TABLE schemes FROM i2b2metadata;
GRANT ALL ON TABLE schemes TO i2b2metadata;
GRANT ALL ON TABLE schemes TO biomart_user;
GRANT ALL ON TABLE schemes TO tm_cz;


--
-- Name: seq_i2b2metadata; Type: ACL; Schema: i2b2metadata; Owner: postgres
--

REVOKE ALL ON SEQUENCE seq_i2b2metadata FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_i2b2metadata FROM postgres;
GRANT ALL ON SEQUENCE seq_i2b2metadata TO postgres;
GRANT ALL ON SEQUENCE seq_i2b2metadata TO tm_cz;


--
-- Name: table_access; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE table_access FROM PUBLIC;
REVOKE ALL ON TABLE table_access FROM i2b2metadata;
GRANT ALL ON TABLE table_access TO i2b2metadata;
GRANT ALL ON TABLE table_access TO biomart_user;
GRANT ALL ON TABLE table_access TO tm_cz;


SET search_path = i2b2pm, pg_catalog;

--
-- Name: pm_cell_data; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_cell_data FROM PUBLIC;
REVOKE ALL ON TABLE pm_cell_data FROM i2b2pm;
GRANT ALL ON TABLE pm_cell_data TO i2b2pm;
GRANT ALL ON TABLE pm_cell_data TO biomart_user;


--
-- Name: pm_params; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON SEQUENCE pm_params FROM PUBLIC;
REVOKE ALL ON SEQUENCE pm_params FROM i2b2pm;
GRANT ALL ON SEQUENCE pm_params TO i2b2pm;
GRANT ALL ON SEQUENCE pm_params TO biomart_user;


--
-- Name: pm_cell_params; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_cell_params FROM PUBLIC;
REVOKE ALL ON TABLE pm_cell_params FROM i2b2pm;
GRANT ALL ON TABLE pm_cell_params TO i2b2pm;
GRANT ALL ON TABLE pm_cell_params TO biomart_user;


--
-- Name: pm_global_params; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_global_params FROM PUBLIC;
REVOKE ALL ON TABLE pm_global_params FROM i2b2pm;
GRANT ALL ON TABLE pm_global_params TO i2b2pm;
GRANT ALL ON TABLE pm_global_params TO biomart_user;


--
-- Name: pm_hive_data; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_hive_data FROM PUBLIC;
REVOKE ALL ON TABLE pm_hive_data FROM i2b2pm;
GRANT ALL ON TABLE pm_hive_data TO i2b2pm;
GRANT ALL ON TABLE pm_hive_data TO biomart_user;


--
-- Name: pm_hive_params; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_hive_params FROM PUBLIC;
REVOKE ALL ON TABLE pm_hive_params FROM i2b2pm;
GRANT ALL ON TABLE pm_hive_params TO i2b2pm;
GRANT ALL ON TABLE pm_hive_params TO biomart_user;


--
-- Name: pm_project_data; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_project_data FROM PUBLIC;
REVOKE ALL ON TABLE pm_project_data FROM i2b2pm;
GRANT ALL ON TABLE pm_project_data TO i2b2pm;
GRANT ALL ON TABLE pm_project_data TO biomart_user;


--
-- Name: pm_project_params; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_project_params FROM PUBLIC;
REVOKE ALL ON TABLE pm_project_params FROM i2b2pm;
GRANT ALL ON TABLE pm_project_params TO i2b2pm;
GRANT ALL ON TABLE pm_project_params TO biomart_user;


--
-- Name: pm_project_user_params; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_project_user_params FROM PUBLIC;
REVOKE ALL ON TABLE pm_project_user_params FROM i2b2pm;
GRANT ALL ON TABLE pm_project_user_params TO i2b2pm;
GRANT ALL ON TABLE pm_project_user_params TO biomart_user;


--
-- Name: pm_project_user_roles; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_project_user_roles FROM PUBLIC;
REVOKE ALL ON TABLE pm_project_user_roles FROM i2b2pm;
GRANT ALL ON TABLE pm_project_user_roles TO i2b2pm;
GRANT ALL ON TABLE pm_project_user_roles TO biomart_user;


--
-- Name: pm_role_requirement; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_role_requirement FROM PUBLIC;
REVOKE ALL ON TABLE pm_role_requirement FROM i2b2pm;
GRANT ALL ON TABLE pm_role_requirement TO i2b2pm;
GRANT ALL ON TABLE pm_role_requirement TO biomart_user;


--
-- Name: pm_user_data; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_user_data FROM PUBLIC;
REVOKE ALL ON TABLE pm_user_data FROM i2b2pm;
GRANT ALL ON TABLE pm_user_data TO i2b2pm;
GRANT ALL ON TABLE pm_user_data TO biomart_user;


--
-- Name: pm_user_params; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_user_params FROM PUBLIC;
REVOKE ALL ON TABLE pm_user_params FROM i2b2pm;
GRANT ALL ON TABLE pm_user_params TO i2b2pm;
GRANT ALL ON TABLE pm_user_params TO biomart_user;


--
-- Name: pm_user_session; Type: ACL; Schema: i2b2pm; Owner: i2b2pm
--

REVOKE ALL ON TABLE pm_user_session FROM PUBLIC;
REVOKE ALL ON TABLE pm_user_session FROM i2b2pm;
GRANT ALL ON TABLE pm_user_session TO i2b2pm;
GRANT ALL ON TABLE pm_user_session TO biomart_user;


SET search_path = i2b2workdata, pg_catalog;

--
-- Name: workplace; Type: ACL; Schema: i2b2workdata; Owner: i2b2workdata
--

REVOKE ALL ON TABLE workplace FROM PUBLIC;
REVOKE ALL ON TABLE workplace FROM i2b2workdata;
GRANT ALL ON TABLE workplace TO i2b2workdata;
GRANT ALL ON TABLE workplace TO biomart_user;


--
-- Name: workplace_access; Type: ACL; Schema: i2b2workdata; Owner: i2b2workdata
--

REVOKE ALL ON TABLE workplace_access FROM PUBLIC;
REVOKE ALL ON TABLE workplace_access FROM i2b2workdata;
GRANT ALL ON TABLE workplace_access TO i2b2workdata;
GRANT ALL ON TABLE workplace_access TO biomart_user;


SET search_path = searchapp, pg_catalog;

--
-- Name: hibernate_sequence; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON SEQUENCE hibernate_sequence FROM PUBLIC;
REVOKE ALL ON SEQUENCE hibernate_sequence FROM searchapp;
GRANT ALL ON SEQUENCE hibernate_sequence TO searchapp;
GRANT ALL ON SEQUENCE hibernate_sequence TO biomart_user;
GRANT ALL ON SEQUENCE hibernate_sequence TO tm_cz;


--
-- Name: plugin; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE plugin FROM PUBLIC;
REVOKE ALL ON TABLE plugin FROM searchapp;
GRANT ALL ON TABLE plugin TO searchapp;
GRANT ALL ON TABLE plugin TO biomart_user;
GRANT ALL ON TABLE plugin TO tm_cz;


--
-- Name: plugin_module; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE plugin_module FROM PUBLIC;
REVOKE ALL ON TABLE plugin_module FROM searchapp;
GRANT ALL ON TABLE plugin_module TO searchapp;
GRANT ALL ON TABLE plugin_module TO biomart_user;
GRANT ALL ON TABLE plugin_module TO tm_cz;


--
-- Name: plugin_module_seq; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON SEQUENCE plugin_module_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE plugin_module_seq FROM searchapp;
GRANT ALL ON SEQUENCE plugin_module_seq TO searchapp;
GRANT ALL ON SEQUENCE plugin_module_seq TO biomart_user;
GRANT ALL ON SEQUENCE plugin_module_seq TO tm_cz;


--
-- Name: plugin_seq; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON SEQUENCE plugin_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE plugin_seq FROM searchapp;
GRANT ALL ON SEQUENCE plugin_seq TO searchapp;
GRANT ALL ON SEQUENCE plugin_seq TO biomart_user;
GRANT ALL ON SEQUENCE plugin_seq TO tm_cz;


--
-- Name: search_app_access_log; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_app_access_log FROM PUBLIC;
REVOKE ALL ON TABLE search_app_access_log FROM searchapp;
GRANT ALL ON TABLE search_app_access_log TO searchapp;
GRANT ALL ON TABLE search_app_access_log TO biomart_user;
GRANT ALL ON TABLE search_app_access_log TO tm_cz;


--
-- Name: search_auth_group; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_group FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_group FROM searchapp;
GRANT ALL ON TABLE search_auth_group TO searchapp;
GRANT ALL ON TABLE search_auth_group TO biomart_user;
GRANT ALL ON TABLE search_auth_group TO tm_cz;


--
-- Name: search_auth_group_member; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_group_member FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_group_member FROM searchapp;
GRANT ALL ON TABLE search_auth_group_member TO searchapp;
GRANT ALL ON TABLE search_auth_group_member TO biomart_user;
GRANT ALL ON TABLE search_auth_group_member TO tm_cz;


--
-- Name: search_auth_principal; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_principal FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_principal FROM searchapp;
GRANT ALL ON TABLE search_auth_principal TO searchapp;
GRANT ALL ON TABLE search_auth_principal TO biomart_user;
GRANT ALL ON TABLE search_auth_principal TO tm_cz;


--
-- Name: search_auth_sec_object_access; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_sec_object_access FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_sec_object_access FROM searchapp;
GRANT ALL ON TABLE search_auth_sec_object_access TO searchapp;
GRANT ALL ON TABLE search_auth_sec_object_access TO biomart_user;
GRANT ALL ON TABLE search_auth_sec_object_access TO tm_cz;


--
-- Name: search_auth_user; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_user FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_user FROM searchapp;
GRANT ALL ON TABLE search_auth_user TO searchapp;
GRANT ALL ON TABLE search_auth_user TO biomart_user;
GRANT ALL ON TABLE search_auth_user TO tm_cz;


--
-- Name: search_auth_user_sec_access; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_user_sec_access FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_user_sec_access FROM searchapp;
GRANT ALL ON TABLE search_auth_user_sec_access TO searchapp;
GRANT ALL ON TABLE search_auth_user_sec_access TO biomart_user;
GRANT ALL ON TABLE search_auth_user_sec_access TO tm_cz;


--
-- Name: search_auth_user_sec_access_v; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_user_sec_access_v FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_user_sec_access_v FROM searchapp;
GRANT ALL ON TABLE search_auth_user_sec_access_v TO searchapp;
GRANT ALL ON TABLE search_auth_user_sec_access_v TO biomart_user;
GRANT ALL ON TABLE search_auth_user_sec_access_v TO tm_cz;


--
-- Name: search_bio_mkr_correl_fast_mv; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_bio_mkr_correl_fast_mv FROM PUBLIC;
REVOKE ALL ON TABLE search_bio_mkr_correl_fast_mv FROM searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_mv TO searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_mv TO biomart_user;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_mv TO tm_cz;


--
-- Name: search_gene_signature; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_gene_signature FROM PUBLIC;
REVOKE ALL ON TABLE search_gene_signature FROM searchapp;
GRANT ALL ON TABLE search_gene_signature TO searchapp;
GRANT ALL ON TABLE search_gene_signature TO biomart_user;
GRANT ALL ON TABLE search_gene_signature TO tm_cz;


--
-- Name: search_gene_signature_item; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_gene_signature_item FROM PUBLIC;
REVOKE ALL ON TABLE search_gene_signature_item FROM searchapp;
GRANT ALL ON TABLE search_gene_signature_item TO searchapp;
GRANT ALL ON TABLE search_gene_signature_item TO biomart_user;
GRANT ALL ON TABLE search_gene_signature_item TO tm_cz;


--
-- Name: search_bio_mkr_correl_fast_view; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_bio_mkr_correl_fast_view FROM PUBLIC;
REVOKE ALL ON TABLE search_bio_mkr_correl_fast_view FROM searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_view TO searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_view TO biomart_user;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_view TO tm_cz;


--
-- Name: search_custom_filter; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_custom_filter FROM PUBLIC;
REVOKE ALL ON TABLE search_custom_filter FROM searchapp;
GRANT ALL ON TABLE search_custom_filter TO searchapp;
GRANT ALL ON TABLE search_custom_filter TO biomart_user;
GRANT ALL ON TABLE search_custom_filter TO tm_cz;


--
-- Name: search_custom_filter_item; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_custom_filter_item FROM PUBLIC;
REVOKE ALL ON TABLE search_custom_filter_item FROM searchapp;
GRANT ALL ON TABLE search_custom_filter_item TO searchapp;
GRANT ALL ON TABLE search_custom_filter_item TO biomart_user;
GRANT ALL ON TABLE search_custom_filter_item TO tm_cz;


--
-- Name: search_gene_sig_file_schema; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_gene_sig_file_schema FROM PUBLIC;
REVOKE ALL ON TABLE search_gene_sig_file_schema FROM searchapp;
GRANT ALL ON TABLE search_gene_sig_file_schema TO searchapp;
GRANT ALL ON TABLE search_gene_sig_file_schema TO biomart_user;
GRANT ALL ON TABLE search_gene_sig_file_schema TO tm_cz;


--
-- Name: search_keyword; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_keyword FROM PUBLIC;
REVOKE ALL ON TABLE search_keyword FROM searchapp;
GRANT ALL ON TABLE search_keyword TO searchapp;
GRANT ALL ON TABLE search_keyword TO biomart_user;
GRANT ALL ON TABLE search_keyword TO tm_cz;


--
-- Name: search_keyword_term; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_keyword_term FROM PUBLIC;
REVOKE ALL ON TABLE search_keyword_term FROM searchapp;
GRANT ALL ON TABLE search_keyword_term TO searchapp;
GRANT ALL ON TABLE search_keyword_term TO biomart_user;
GRANT ALL ON TABLE search_keyword_term TO tm_cz;


--
-- Name: search_request_map; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_request_map FROM PUBLIC;
REVOKE ALL ON TABLE search_request_map FROM searchapp;
GRANT ALL ON TABLE search_request_map TO searchapp;
GRANT ALL ON TABLE search_request_map TO biomart_user;
GRANT ALL ON TABLE search_request_map TO tm_cz;


--
-- Name: search_role; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_role FROM PUBLIC;
REVOKE ALL ON TABLE search_role FROM searchapp;
GRANT ALL ON TABLE search_role TO searchapp;
GRANT ALL ON TABLE search_role TO biomart_user;
GRANT ALL ON TABLE search_role TO tm_cz;


--
-- Name: search_role_auth_user; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_role_auth_user FROM PUBLIC;
REVOKE ALL ON TABLE search_role_auth_user FROM searchapp;
GRANT ALL ON TABLE search_role_auth_user TO searchapp;
GRANT ALL ON TABLE search_role_auth_user TO biomart_user;
GRANT ALL ON TABLE search_role_auth_user TO tm_cz;


--
-- Name: search_sec_access_level; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_sec_access_level FROM PUBLIC;
REVOKE ALL ON TABLE search_sec_access_level FROM searchapp;
GRANT ALL ON TABLE search_sec_access_level TO searchapp;
GRANT ALL ON TABLE search_sec_access_level TO biomart_user;
GRANT ALL ON TABLE search_sec_access_level TO tm_cz;


--
-- Name: search_secure_object; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_secure_object FROM PUBLIC;
REVOKE ALL ON TABLE search_secure_object FROM searchapp;
GRANT ALL ON TABLE search_secure_object TO searchapp;
GRANT ALL ON TABLE search_secure_object TO biomart_user;
GRANT ALL ON TABLE search_secure_object TO tm_cz;


--
-- Name: search_secure_object_path; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_secure_object_path FROM PUBLIC;
REVOKE ALL ON TABLE search_secure_object_path FROM searchapp;
GRANT ALL ON TABLE search_secure_object_path TO searchapp;
GRANT ALL ON TABLE search_secure_object_path TO biomart_user;
GRANT ALL ON TABLE search_secure_object_path TO tm_cz;


--
-- Name: search_user_settings; Type: ACL; Schema: searchapp; Owner: biomart_user
--

REVOKE ALL ON TABLE search_user_settings FROM PUBLIC;
REVOKE ALL ON TABLE search_user_settings FROM biomart_user;
GRANT ALL ON TABLE search_user_settings TO biomart_user;
GRANT ALL ON TABLE search_user_settings TO tm_cz;


--
-- Name: seq_search_data_id; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON SEQUENCE seq_search_data_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_search_data_id FROM searchapp;
GRANT ALL ON SEQUENCE seq_search_data_id TO searchapp;
GRANT ALL ON SEQUENCE seq_search_data_id TO biomart_user;
GRANT ALL ON SEQUENCE seq_search_data_id TO tm_cz;


SET search_path = tm_lz, pg_catalog;

--
-- Name: lt_src_clinical_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_clinical_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_clinical_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_clinical_data TO tm_lz;
GRANT ALL ON TABLE lt_src_clinical_data TO tm_cz;


--
-- Name: lt_src_deapp_annot; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_deapp_annot FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_deapp_annot FROM tm_lz;
GRANT ALL ON TABLE lt_src_deapp_annot TO tm_lz;
GRANT ALL ON TABLE lt_src_deapp_annot TO tm_cz;


--
-- Name: lt_src_mrna_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_mrna_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_mrna_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_mrna_data TO tm_lz;
GRANT ALL ON TABLE lt_src_mrna_data TO tm_cz;


--
-- Name: lt_src_mrna_subj_samp_map; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_mrna_subj_samp_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_mrna_subj_samp_map FROM tm_lz;
GRANT ALL ON TABLE lt_src_mrna_subj_samp_map TO tm_lz;
GRANT ALL ON TABLE lt_src_mrna_subj_samp_map TO tm_cz;


--
-- Name: lt_src_study_metadata; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_study_metadata FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_study_metadata FROM tm_lz;
GRANT ALL ON TABLE lt_src_study_metadata TO tm_lz;
GRANT ALL ON TABLE lt_src_study_metadata TO tm_cz;


SET search_path = tm_wz, pg_catalog;

--
-- Name: wrk_clinical_data; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wrk_clinical_data FROM PUBLIC;
REVOKE ALL ON TABLE wrk_clinical_data FROM tm_wz;
GRANT ALL ON TABLE wrk_clinical_data TO tm_wz;
GRANT ALL ON TABLE wrk_clinical_data TO tm_cz;


--
-- Name: wrk_mrna_data; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wrk_mrna_data FROM PUBLIC;
REVOKE ALL ON TABLE wrk_mrna_data FROM tm_wz;
GRANT ALL ON TABLE wrk_mrna_data TO tm_wz;
GRANT ALL ON TABLE wrk_mrna_data TO tm_cz;


--
-- Name: wt_clinical_data_dups; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_clinical_data_dups FROM PUBLIC;
REVOKE ALL ON TABLE wt_clinical_data_dups FROM tm_wz;
GRANT ALL ON TABLE wt_clinical_data_dups TO tm_wz;
GRANT ALL ON TABLE wt_clinical_data_dups TO tm_cz;


--
-- Name: wt_del_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_del_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_del_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_del_nodes TO tm_wz;
GRANT ALL ON TABLE wt_del_nodes TO tm_cz;


--
-- Name: wt_folder_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_folder_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_folder_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_folder_nodes TO tm_wz;
GRANT ALL ON TABLE wt_folder_nodes TO tm_cz;


--
-- Name: wt_mrna_node_values; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_mrna_node_values FROM PUBLIC;
REVOKE ALL ON TABLE wt_mrna_node_values FROM tm_wz;
GRANT ALL ON TABLE wt_mrna_node_values TO tm_wz;
GRANT ALL ON TABLE wt_mrna_node_values TO tm_cz;


--
-- Name: wt_mrna_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_mrna_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_mrna_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_mrna_nodes TO tm_wz;
GRANT ALL ON TABLE wt_mrna_nodes TO tm_cz;


--
-- Name: wt_num_data_types; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_num_data_types FROM PUBLIC;
REVOKE ALL ON TABLE wt_num_data_types FROM tm_wz;
GRANT ALL ON TABLE wt_num_data_types TO tm_wz;
GRANT ALL ON TABLE wt_num_data_types TO tm_cz;


--
-- Name: wt_subject_info; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_info FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_info FROM tm_wz;
GRANT ALL ON TABLE wt_subject_info TO tm_wz;
GRANT ALL ON TABLE wt_subject_info TO tm_cz;


--
-- Name: wt_subject_microarray_calcs; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_microarray_calcs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_microarray_calcs FROM tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_calcs TO tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_calcs TO tm_cz;


--
-- Name: wt_subject_microarray_logs; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_microarray_logs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_microarray_logs FROM tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_logs TO tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_logs TO tm_cz;


--
-- Name: wt_subject_microarray_med; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_microarray_med FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_microarray_med FROM tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_med TO tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_med TO tm_cz;


--
-- Name: wt_subject_mrna_data; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_mrna_data FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_mrna_data FROM tm_wz;
GRANT ALL ON TABLE wt_subject_mrna_data TO tm_wz;
GRANT ALL ON TABLE wt_subject_mrna_data TO tm_cz;


--
-- Name: wt_subject_mrna_probeset; Type: ACL; Schema: tm_wz; Owner: postgres
--

REVOKE ALL ON TABLE wt_subject_mrna_probeset FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_mrna_probeset FROM postgres;
GRANT ALL ON TABLE wt_subject_mrna_probeset TO postgres;
GRANT ALL ON TABLE wt_subject_mrna_probeset TO tm_cz;


--
-- Name: wt_trial_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_trial_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_trial_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_trial_nodes TO tm_wz;
GRANT ALL ON TABLE wt_trial_nodes TO tm_cz;


--
-- PostgreSQL database dump complete
--

